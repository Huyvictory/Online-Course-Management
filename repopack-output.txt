This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-11-25T16:31:45.187Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

For more information about Repopack, visit: https://github.com/yamadashy/repopack
</additional_info>

</file_summary>

<repository_structure>
.gitignore
.mvn/wrapper/maven-wrapper.properties
.repopackignore
pom.xml
repopack.config.json
src/main/java/com/online/course/management/project/aspect/LoggingAspect.java
src/main/java/com/online/course/management/project/aspect/RoleAuthorizationAspect.java
src/main/java/com/online/course/management/project/config/AdminInitializer.java
src/main/java/com/online/course/management/project/config/CacheConfig.java
src/main/java/com/online/course/management/project/config/DatabaseInitializer.java
src/main/java/com/online/course/management/project/config/JacksonConfig.java
src/main/java/com/online/course/management/project/config/SecurityConfig.java
src/main/java/com/online/course/management/project/config/WebConfig.java
src/main/java/com/online/course/management/project/constants/CategoryConstants.java
src/main/java/com/online/course/management/project/constants/ChapterConstants.java
src/main/java/com/online/course/management/project/constants/CourseConstants.java
src/main/java/com/online/course/management/project/constants/LessonConstants.java
src/main/java/com/online/course/management/project/constants/UserConstants.java
src/main/java/com/online/course/management/project/controller/CategoryController.java
src/main/java/com/online/course/management/project/controller/ChapterController.java
src/main/java/com/online/course/management/project/controller/CourseController.java
src/main/java/com/online/course/management/project/controller/CustomErrorController.java
src/main/java/com/online/course/management/project/controller/LessonController.java
src/main/java/com/online/course/management/project/controller/UserController.java
src/main/java/com/online/course/management/project/converter/StringToLocalDateTimeConverter.java
src/main/java/com/online/course/management/project/dto/CategoryDTOs.java
src/main/java/com/online/course/management/project/dto/ChapterDTOs.java
src/main/java/com/online/course/management/project/dto/CommonResponseDTOs.java
src/main/java/com/online/course/management/project/dto/CourseDTOS.java
src/main/java/com/online/course/management/project/dto/ErrorResponseDTO.java
src/main/java/com/online/course/management/project/dto/LessonDTOs.java
src/main/java/com/online/course/management/project/dto/PaginationDto.java
src/main/java/com/online/course/management/project/dto/UserDTOs.java
src/main/java/com/online/course/management/project/entity/Category.java
src/main/java/com/online/course/management/project/entity/Chapter.java
src/main/java/com/online/course/management/project/entity/Course.java
src/main/java/com/online/course/management/project/entity/CourseRating.java
src/main/java/com/online/course/management/project/entity/Lesson.java
src/main/java/com/online/course/management/project/entity/Role.java
src/main/java/com/online/course/management/project/entity/User.java
src/main/java/com/online/course/management/project/entity/UserCourse.java
src/main/java/com/online/course/management/project/entity/UserLessonProgress.java
src/main/java/com/online/course/management/project/entity/UserRole.java
src/main/java/com/online/course/management/project/entity/UserRoleId.java
src/main/java/com/online/course/management/project/enums/CourseStatus.java
src/main/java/com/online/course/management/project/enums/EnrollmentStatus.java
src/main/java/com/online/course/management/project/enums/LessonType.java
src/main/java/com/online/course/management/project/enums/ProgressStatus.java
src/main/java/com/online/course/management/project/enums/RoleType.java
src/main/java/com/online/course/management/project/enums/UserStatus.java
src/main/java/com/online/course/management/project/exception/BaseException.java
src/main/java/com/online/course/management/project/exception/business/account/AccountException.java
src/main/java/com/online/course/management/project/exception/business/account/EmailAlreadyExistsException.java
src/main/java/com/online/course/management/project/exception/business/account/WrongEmailPasswordException.java
src/main/java/com/online/course/management/project/exception/business/BusinessException.java
src/main/java/com/online/course/management/project/exception/business/ForbiddenException.java
src/main/java/com/online/course/management/project/exception/business/InvalidRequestException.java
src/main/java/com/online/course/management/project/exception/business/InvalidRoleInfoException.java
src/main/java/com/online/course/management/project/exception/business/ResourceNotFoundException.java
src/main/java/com/online/course/management/project/exception/business/UnauthorizedException.java
src/main/java/com/online/course/management/project/exception/GlobalExceptionHandler.java
src/main/java/com/online/course/management/project/exception/technical/DatabaseException.java
src/main/java/com/online/course/management/project/exception/technical/ExternalServiceException.java
src/main/java/com/online/course/management/project/exception/technical/TechnicalException.java
src/main/java/com/online/course/management/project/filter/DebugFilter.java
src/main/java/com/online/course/management/project/filter/JwtAuthenticationFilter.java
src/main/java/com/online/course/management/project/mapper/CategoryMapper.java
src/main/java/com/online/course/management/project/mapper/ChapterMapper.java
src/main/java/com/online/course/management/project/mapper/CourseMapper.java
src/main/java/com/online/course/management/project/mapper/LessonMapper.java
src/main/java/com/online/course/management/project/mapper/UserMapper.java
src/main/java/com/online/course/management/project/ProjectApplication.java
src/main/java/com/online/course/management/project/repository/ICategoryRepository.java
src/main/java/com/online/course/management/project/repository/IChapterRepository.java
src/main/java/com/online/course/management/project/repository/ICourseRepository.java
src/main/java/com/online/course/management/project/repository/ILessonRepository.java
src/main/java/com/online/course/management/project/repository/IRoleRepository.java
src/main/java/com/online/course/management/project/repository/IUserRepository.java
src/main/java/com/online/course/management/project/repository/IUserRoleRepository.java
src/main/java/com/online/course/management/project/security/CustomAccessDeniedHandler.java
src/main/java/com/online/course/management/project/security/CustomUserDetails.java
src/main/java/com/online/course/management/project/security/CustomUserDetailsService.java
src/main/java/com/online/course/management/project/security/JwtAuthenticationEntryPoint.java
src/main/java/com/online/course/management/project/security/JwtUtil.java
src/main/java/com/online/course/management/project/security/RequiredRole.java
src/main/java/com/online/course/management/project/security/UserSecurity.java
src/main/java/com/online/course/management/project/service/impl/CategoryServiceImpl.java
src/main/java/com/online/course/management/project/service/impl/ChapterServiceImpl.java
src/main/java/com/online/course/management/project/service/impl/CourseServiceImpl.java
src/main/java/com/online/course/management/project/service/impl/LessonServiceImpl.java
src/main/java/com/online/course/management/project/service/impl/UserServiceImpl.java
src/main/java/com/online/course/management/project/service/interfaces/ICategoryService.java
src/main/java/com/online/course/management/project/service/interfaces/IChapterService.java
src/main/java/com/online/course/management/project/service/interfaces/ICourseService.java
src/main/java/com/online/course/management/project/service/interfaces/ILessonService.java
src/main/java/com/online/course/management/project/service/interfaces/IUserService.java
src/main/java/com/online/course/management/project/utils/category/CategoryServiceUtils.java
src/main/java/com/online/course/management/project/utils/chapter/ChapterServiceUtils.java
src/main/java/com/online/course/management/project/utils/course/CourseServiceUtils.java
src/main/java/com/online/course/management/project/utils/exception/GlobalExceptionUtils.java
src/main/java/com/online/course/management/project/utils/generator/JwtSecretGenerator.java
src/main/java/com/online/course/management/project/utils/generator/PasswordHashGenerator.java
src/main/java/com/online/course/management/project/utils/lesson/LessonServiceUtils.java
src/main/java/com/online/course/management/project/utils/user/UserControllerUtils.java
src/main/java/com/online/course/management/project/utils/user/UserServiceUtils.java
src/main/resources/application.properties
src/main/resources/db/migration/V10__Update_non_admin_passwords.sql
src/main/resources/db/migration/V11__Update_non_admin_passwords.sql
src/main/resources/db/migration/V12__Add_chapter_and_lesson_tables.sql
src/main/resources/db/migration/V13__Trigger_validate_soft_delete_Course_Chapter_Lesson.sql
src/main/resources/db/migration/V14__Add_trigger_archive_lessons.sql
src/main/resources/db/migration/V15__Add_user_enrollment_progress_rating_tables.sql
src/main/resources/db/migration/V16__Add_flexible_progress_tracking_triggers.sql
src/main/resources/db/migration/V2__Update_User_table.sql
src/main/resources/db/migration/V3__Add_status_to_users.sql
src/main/resources/db/migration/V4__Add_course_and_category_tables.sql
src/main/resources/db/migration/V5__Add_indexes_to_course_and_category.sql
src/main/resources/db/migration/V6__Add_course_status_validation.sql
src/main/resources/db/migration/V7__Add_course_and_category_triggers.sql
src/main/resources/db/migration/V8__Make_instructor_id_nullable.sql
src/main/resources/db/migration/V9__Add_course_archive_category_trigger.sql
src/main/resources/Python_Scripts/generate_chapters_lessons.py
src/main/resources/Python_Scripts/generate_courses_categories.py
src/main/resources/Python_Scripts/generate_users.py
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path=".gitignore">
HELP.md
target/
!.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/
</file>

<file path=".mvn/wrapper/maven-wrapper.properties">
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.9/apache-maven-3.9.9-bin.zip
</file>

<file path=".repopackignore">
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/

target
mvnw
mvnw.cmd

test
</file>

<file path="pom.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.1.5</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.online.course.management</groupId>
    <artifactId>project</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>Project</name>
    <description>Project</description>
    <url/>
    <licenses>
        <license/>
    </licenses>
    <developers>
        <developer/>
    </developers>
    <scm>
        <connection/>
        <developerConnection/>
        <tag/>
        <url/>
    </scm>
    <properties>
        <java.version>17</java.version>
        <mysql.version>8.0.33</mysql.version>
        <junit-jupiter.version>5.9.3</junit-jupiter.version>
        <mockito.version>5.3.1</mockito.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-core</artifactId>
        </dependency>
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-mysql</artifactId>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.11.5</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-cache</artifactId>
        </dependency>
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>1.5.5.Final</version>
        </dependency>
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct-processor</artifactId>
            <version>1.5.5.Final</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>com.github.ben-manes.caffeine</groupId>
            <artifactId>caffeine</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-aop</artifactId>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.datatype</groupId>
            <artifactId>jackson-datatype-jsr310</artifactId>
        </dependency>

        <!-- Test dependencies -->
        <!-- Spring Boot Starter Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.flywaydb</groupId>
                <artifactId>flyway-maven-plugin</artifactId>
                <version>9.22.3</version>
                <configuration>
                    <url>jdbc:mysql://localhost:3306/onlinecoursemanagement</url>
                    <user>Huyvictory</user>
                    <password>12345</password>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>3.1.2</version>
                <configuration>
                    <argLine>
                        -XX:+EnableDynamicAgentLoading
                        --add-opens java.base/java.lang=ALL-UNNAMED
                        --add-opens java.base/java.util=ALL-UNNAMED
                        --add-opens java.base/java.time=ALL-UNNAMED
                        -Xshare:off
                    </argLine>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>
</file>

<file path="repopack.config.json">
{
  "output": {
    "filePath": "repopack-output.txt",
    "style": "xml",
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  }
}
</file>

<file path="src/main/java/com/online/course/management/project/aspect/LoggingAspect.java">
package com.online.course.management.project.aspect;

import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

@Aspect
@Component
public class LoggingAspect {
    private static final Logger logger = LoggerFactory.getLogger(LoggingAspect.class);

    @Pointcut("execution(* com.online.course.management.project.controller.*.*(..))")
    public void controllerMethods() {
    }

    @Pointcut("execution(* com.online.course.management.project.service.*.*(..))")
    public void serviceMethods() {
    }

    @Around("controllerMethods() || serviceMethods()")
    public Object logMethodExecution(ProceedingJoinPoint joinPoint) throws Throwable {
        String className = joinPoint.getSignature().getDeclaringTypeName();
        String methodName = joinPoint.getSignature().getName();

        MDC.put("class", className);
        MDC.put("method", methodName);

        logger.info("Entering: classname={}, method={}", className, methodName);

        long startTime = System.currentTimeMillis();
        Object result = null;
        try {
            result = joinPoint.proceed();
            return result;
        } catch (Exception e) {
            logger.error("Exception in {}.{}: {}", className, methodName, e.getMessage());
            throw e;
        } finally {
            long endTime = System.currentTimeMillis();
            logger.info("Exiting: {}.{}. Execution time: {} ms", className, methodName, (endTime - startTime));
            MDC.clear();
        }
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/aspect/RoleAuthorizationAspect.java">
package com.online.course.management.project.aspect;

import com.online.course.management.project.exception.business.ForbiddenException;
import com.online.course.management.project.exception.business.UnauthorizedException;
import com.online.course.management.project.security.RequiredRole;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;

import java.util.Arrays;
import java.util.Set;
import java.util.stream.Collectors;

@Aspect
@Component
public class RoleAuthorizationAspect {

    private static final Logger logger = LoggerFactory.getLogger(RoleAuthorizationAspect.class);

    @Around("@annotation(requiredRole)")
    public Object authorizeRole(ProceedingJoinPoint joinPoint, RequiredRole requiredRole) throws Throwable {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();


        if (authentication == null || !authentication.isAuthenticated()) {
            logger.warn("Unauthorized access attempt: User is not authenticated");
            throw new UnauthorizedException("User is not authenticated");
        }

        logger.info("Required roles: {}", Arrays.toString(requiredRole.value()));
        logger.info("User authorities: {}", authentication.getAuthorities());

        // Get authorities and strip "ROLE_" prefix if present
        Set<String> userRoles = authentication.getAuthorities().stream()
                .map(a -> a.getAuthority().replace("ROLE_", ""))
                .collect(Collectors.toSet());

        boolean hasRequiredRole = Arrays.stream(requiredRole.value())
                .anyMatch(userRoles::contains);

        if (!hasRequiredRole) {
            logger.warn("Forbidden access attempt: User {} does not have any of the required roles: {}",
                    authentication.getName(), Arrays.toString(requiredRole.value()));
            throw new ForbiddenException("User does not have the required role");
        }

        return joinPoint.proceed();
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/config/AdminInitializer.java">
package com.online.course.management.project.config;

import com.online.course.management.project.entity.Role;
import com.online.course.management.project.entity.User;
import com.online.course.management.project.enums.RoleType;
import com.online.course.management.project.repository.IRoleRepository;
import com.online.course.management.project.repository.IUserRepository;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.core.annotation.Order;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

@Component
@Order(2)
@Slf4j
public class AdminInitializer implements CommandLineRunner {
    private final IUserRepository userRepository;
    private final IRoleRepository roleRepository;
    private final PasswordEncoder passwordEncoder;

    @Autowired
    public AdminInitializer(IUserRepository userRepository, IRoleRepository roleRepository, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.roleRepository = roleRepository;
        this.passwordEncoder = passwordEncoder;
    }

    @Override
    @Transactional
    public void run(String... args) throws Exception {
        if (!userRepository.existsByEmail("admin@gmail.com")) {
            User adminUser = new User();
            adminUser.setUsername("admin");
            adminUser.setEmail("admin@gmail.com");
            adminUser.setPasswordHash(passwordEncoder.encode("admin"));
            adminUser.setRealName("Admin User");

            Role adminRole = roleRepository.findByName(RoleType.ADMIN)
                    .orElseThrow(() -> new RuntimeException("Admin role not found"));
            adminUser.addRole(adminRole);

            userRepository.save(adminUser);

            log.info("Admin user created successfully.");
        } else {
            log.info("Admin user already exists.");
        }
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/config/CacheConfig.java">
package com.online.course.management.project.config;

import com.github.benmanes.caffeine.cache.Caffeine;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.cache.caffeine.CaffeineCacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.concurrent.TimeUnit;

@Configuration
@EnableCaching
public class CacheConfig {

    @Bean
    public Caffeine caffeineConfig() {
        return Caffeine.newBuilder()
                .expireAfterWrite(60, TimeUnit.MINUTES)
                .initialCapacity(100)
                .maximumSize(500);
    }

    @Bean
    public CacheManager cacheManager(Caffeine caffeine) {
        CaffeineCacheManager caffeineCacheManager = new CaffeineCacheManager();
        caffeineCacheManager.setCaffeine(caffeine);
        return caffeineCacheManager;
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/config/DatabaseInitializer.java">
package com.online.course.management.project.config;

import com.online.course.management.project.entity.Role;
import com.online.course.management.project.enums.RoleType;
import com.online.course.management.project.repository.IRoleRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

@Component
@Order(1)
public class DatabaseInitializer implements CommandLineRunner {
    private final IRoleRepository roleRepository;

    @Autowired
    public DatabaseInitializer(IRoleRepository roleRepository) {
        this.roleRepository = roleRepository;
    }

    @Override
    public void run(String... args) {
        initializeRoles();
    }

    private void initializeRoles() {
        for (RoleType roleType : RoleType.values()) {
            if (!roleRepository.existsByName(roleType)) {
                Role role = new Role();
                role.setName(roleType);
                roleRepository.save(role);
            }
        }
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/config/JacksonConfig.java">
package com.online.course.management.project.config;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;

import java.time.ZoneId;
import java.util.TimeZone;

@Configuration
public class JacksonConfig {

    @Bean
    @Primary
    public ObjectMapper objectMapper() {
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

        // Configure to ignore unknown properties
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, true);

        // Add additional configuration for better handling of Java 8 features
        objectMapper.configure(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS, false);
        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        objectMapper.setTimeZone(TimeZone.getTimeZone(ZoneId.systemDefault()));

        return objectMapper;

    }

    @Bean
    public MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter(ObjectMapper objectMapper) {
        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
        converter.setObjectMapper(objectMapper);
        return converter;
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/config/SecurityConfig.java">
package com.online.course.management.project.config;

import com.online.course.management.project.filter.JwtAuthenticationFilter;
import com.online.course.management.project.security.CustomAccessDeniedHandler;
import com.online.course.management.project.security.CustomUserDetailsService;
import com.online.course.management.project.security.JwtAuthenticationEntryPoint;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.ProviderManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@Slf4j
public class SecurityConfig {

    private static final Logger logger = LoggerFactory.getLogger(SecurityConfig.class);

    private final CustomUserDetailsService userDetailsService;
    private final JwtAuthenticationFilter jwtAuthenticationFilter;
    private final JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;

    @Autowired
    public SecurityConfig(CustomUserDetailsService userDetailsService, JwtAuthenticationFilter jwtAuthenticationFilter, JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint) {
        this.userDetailsService = userDetailsService;
        this.jwtAuthenticationFilter = jwtAuthenticationFilter;
        this.jwtAuthenticationEntryPoint = jwtAuthenticationEntryPoint;
    }

    @Bean
    public AuthenticationManager authenticationManager(HttpSecurity http) throws Exception {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return new ProviderManager(authProvider);
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        logger.info("Configuring security filter chain");
        http
                .csrf(csrf -> {
                    csrf.disable();
                    logger.info("CSRF is disabled");
                })
                .cors(cors -> cors.disable())
                .sessionManagement(session -> {
                    session.sessionCreationPolicy(SessionCreationPolicy.STATELESS);
                    logger.info("Session management set to STATELESS");
                })
                .authorizeHttpRequests(authz -> authz
                        .requestMatchers("/api/v1/users/register", "/api/v1/users/login", "/error", "/api/v1/courses/*").permitAll()
                        .anyRequest().authenticated()
                )
                .userDetailsService(userDetailsService)
                .exceptionHandling(ex -> ex
                        .authenticationEntryPoint(jwtAuthenticationEntryPoint)
                        .accessDeniedHandler(new CustomAccessDeniedHandler())
                )
                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        logger.info("Security configuration completed");
        return http.build();
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/config/WebConfig.java">
package com.online.course.management.project.config;

import com.online.course.management.project.converter.StringToLocalDateTimeConverter;
import org.springframework.context.annotation.Configuration;
import org.springframework.format.FormatterRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addFormatters(FormatterRegistry registry) {
        registry.addConverter(new StringToLocalDateTimeConverter());
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/constants/CategoryConstants.java">
package com.online.course.management.project.constants;

public class CategoryConstants {
    public static final String BASE_PATH = "/api/v1/categories";
    public static final String RESTORE_PATH = "/{id}/restore";
    public static final String SEARCH_PATH = "/search";
    public static final String PATH_VARIABLE_PATH = "/{id}";
}
</file>

<file path="src/main/java/com/online/course/management/project/constants/ChapterConstants.java">
package com.online.course.management.project.constants;

public class ChapterConstants {
    public static final String BASE_PATH = "/api/v1/chapters";
    public static final String CREATE_PATH = "/create";
    public static final String BULK_CREATE_PATH = "/bulk-create";
    public static final String UPDATE_DETAILS_PATH = "/{id}/update";
    public static final String BULK_UPDATE_PATH = "/bulk-update";
    public static final String DELETE_PATH = "{id}/delete";
    public static final String BULK_DELETE_PATH = "/bulk-delete";
    public static final String RESTORE_PATH = "{id}/restore";
    public static final String BULK_RESTORE_PATH = "/bulk-restore";
    public static final String GET_DETAILS_PATH = "/{id}/details";
    public static final String GET_DETAILS_WITH_LESSONS_PATH = "/{id}/details-with-lessons";
    public static final String GET_CHAPTERS_BY_COURSE_PATH = "{courseId}/list";
    public static final String SEARCH_CHAPTERS_PATH = "/search";
    public static final String CHAPTER_REORDERED_PATH = "/{id}/reorder";
}
</file>

<file path="src/main/java/com/online/course/management/project/constants/CourseConstants.java">
package com.online.course.management.project.constants;

public class CourseConstants {
    public static final String BASE_PATH = "/api/v1/courses";
    public static final String CREATE_PATH = "/create";
    public static final String UPDATE_PATH = "{id}/update";
    public static final String ARCHIVE_PATH = "{id}/archive";
    public static final String UNARCHIVE_PATH = "{id}/unarchive";
    public static final String SEARCH_PATH = "/search";
    public static final String SEARCH_COURSE_INSTRUCTOR_PATH = "/search-instructor";
    public static final String SEARCH_COURSE_STATUS_PATH = "/search-status";
    public static final String SEARCH_LATEST_COURSES_PATH = "/search-latest";
    public static final String PATH_VARIABLE_PATH = "/{id}";
}
</file>

<file path="src/main/java/com/online/course/management/project/constants/LessonConstants.java">
package com.online.course.management.project.constants;

public class LessonConstants {
    public static final String BASE_PATH = "/api/v1/lessons";
    public static final String CREATE_PATH = "/create";
    public static final String BULK_CREATE_PATH = "/bulk-create";
    public static final String UPDATE_PATH = "{id}/update";
    public static final String BULK_UPDATE_PATH = "/bulk-update";
    public static final String DELETE_PATH = "{id}/delete";
    public static final String BULK_DELETE_PATH = "/bulk-delete";
    public static final String RESTORE_PATH = "{id}/restore";
    public static final String BULK_RESTORE_PATH = "/bulk-restore";
    public static final String SEARCH_PATH = "/search";
    public static final String REORDER_PATH = "{id}/reorder";
}
</file>

<file path="src/main/java/com/online/course/management/project/constants/UserConstants.java">
package com.online.course.management.project.constants;

public class UserConstants {
    public static final String BASE_PATH = "/api/v1/users";
    public static final String REGISTER_PATH = "/register";
    public static final String LOGIN_PATH = "/login";
    public static final String PROFILE_PATH = "/profile";
    public static final String UPDATE_ROLES_PATH = "/{id}/roles";
    public static final String SEARCH_PATH = "/search";
    public static final String ALL_PATH = "/all";
    public static final String PATH_VARIABLE_PATH = "/{id}";

}
</file>

<file path="src/main/java/com/online/course/management/project/controller/CategoryController.java">
package com.online.course.management.project.controller;

import com.online.course.management.project.constants.CategoryConstants;
import com.online.course.management.project.dto.CategoryDTOs;
import com.online.course.management.project.dto.CommonResponseDTOs;
import com.online.course.management.project.dto.PaginationDto;
import com.online.course.management.project.security.RequiredRole;
import com.online.course.management.project.service.interfaces.ICategoryService;
import jakarta.validation.Valid;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping(CategoryConstants.BASE_PATH)
@Slf4j
public class CategoryController {

    private final ICategoryService categoryService;

    @Autowired
    public CategoryController(ICategoryService categoryService) {
        this.categoryService = categoryService;
    }

    @PostMapping
    @RequiredRole({"ADMIN"})
    public ResponseEntity<CategoryDTOs.CategoryResponseDto> createCategory(@Valid @RequestBody CategoryDTOs.CreateCategoryDTO request) {
        log.info("Creating new category with name: {}", request.getName());

        CategoryDTOs.CategoryResponseDto response = categoryService.createCategory(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @PutMapping(CategoryConstants.PATH_VARIABLE_PATH)
    @RequiredRole({"ADMIN"})
    public ResponseEntity<CategoryDTOs.CategoryResponseDto> updateCategory(
            @PathVariable Long id,
            @Valid @RequestBody CategoryDTOs.UpdateCategoryDTO request) {
        log.info("Updating category with id: {}", id);
        CategoryDTOs.CategoryResponseDto response = categoryService.updateCategory(id, request);
        return ResponseEntity.ok(response);
    }

    @DeleteMapping(CategoryConstants.PATH_VARIABLE_PATH)
    @RequiredRole({"ADMIN"})
    public ResponseEntity<CommonResponseDTOs.DeleteSuccessfullyDTO> deleteCategory(@PathVariable Long id) {
        log.info("Deleting category with id: {}", id);
        categoryService.deleteCategory(id);

        CommonResponseDTOs.DeleteSuccessfullyDTO response = new CommonResponseDTOs.DeleteSuccessfullyDTO("Deleted category with id: " + id);
        return ResponseEntity.status(HttpStatus.OK).body(response);

    }

    @PostMapping(CategoryConstants.RESTORE_PATH)
    @RequiredRole({"ADMIN"})
    public ResponseEntity<CategoryDTOs.RestoreCategoryResponseDTO> restoreCategory(@PathVariable Long id) {
        log.info("Restoring category with id: {}", id);
        categoryService.restoreCategory(id);

        CategoryDTOs.RestoreCategoryResponseDTO response = new CategoryDTOs.RestoreCategoryResponseDTO("Restored category successfully");

        return ResponseEntity.ok().body(response);
    }

    @GetMapping(CategoryConstants.PATH_VARIABLE_PATH)
    public ResponseEntity<CategoryDTOs.CategoryResponseDto> getCategoryById(@PathVariable Long id) {
        log.info("Fetching category with id: {}", id);
        CategoryDTOs.CategoryResponseDto response = categoryService.getCategoryById(id);
        return ResponseEntity.ok(response);
    }

    @PostMapping(CategoryConstants.SEARCH_PATH)
    public ResponseEntity<PaginationDto.PaginationResponseDto<CategoryDTOs.CategoryResponseDto>> searchCategories(
            @Valid @RequestBody CategoryDTOs.CategorySearchDTO searchRequest) {
        log.info("Searching categories with criteria: {}", searchRequest);

        var categoriesPage = categoryService.searchCategories(CategoryDTOs.CategorySearchDTO.builder()
                .name(searchRequest.getName())
                .archived(searchRequest.getArchived())
                .fromDate(searchRequest.getFromDate())
                .toDate(searchRequest.getToDate())
                .build(), searchRequest.toPageable());

        var response = new PaginationDto.PaginationResponseDto<>(
                categoriesPage.getContent(),
                categoriesPage.getNumber() + 1,
                categoriesPage.getSize(),
                categoriesPage.getTotalElements()
        );

        return ResponseEntity.ok(response);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/controller/ChapterController.java">
package com.online.course.management.project.controller;

import com.online.course.management.project.constants.ChapterConstants;
import com.online.course.management.project.dto.ChapterDTOs;
import com.online.course.management.project.dto.PaginationDto;
import com.online.course.management.project.security.RequiredRole;
import com.online.course.management.project.service.interfaces.IChapterService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Controller
@RequestMapping(ChapterConstants.BASE_PATH)
public class ChapterController {

    private final IChapterService chapterService;

    @Autowired
    public ChapterController(IChapterService chapterService) {
        this.chapterService = chapterService;
    }

    @PostMapping(ChapterConstants.CREATE_PATH)
    @RequiredRole({"ADMIN", "INSTRUCTOR"})
    public ResponseEntity<ChapterDTOs.ChapterDetailResponseDto> createChapter(@RequestBody @Valid ChapterDTOs.CreateChapterDTO request) {

        ChapterDTOs.ChapterDetailResponseDto createdChapter = chapterService.createChapter(request);

        return ResponseEntity.status(HttpStatus.CREATED).body(createdChapter);

    }

    @PostMapping(ChapterConstants.BULK_CREATE_PATH)
    @RequiredRole({"ADMIN", "INSTRUCTOR"})
    public ResponseEntity<List<ChapterDTOs.ChapterDetailResponseDto>> bulkCreateChapters(@RequestBody @Valid ChapterDTOs.BulkCreateChapterDTO request) {

        List<ChapterDTOs.ChapterDetailResponseDto> createdChapter = chapterService.bulkCreateChapters(request);

        return ResponseEntity.status(HttpStatus.CREATED).body(createdChapter);
    }

    @PutMapping(ChapterConstants.UPDATE_DETAILS_PATH)
    @RequiredRole({"ADMIN", "INSTRUCTOR"})
    public ResponseEntity<ChapterDTOs.ChapterDetailResponseDto> updateChapter(@PathVariable @Valid long id, @RequestBody @Valid ChapterDTOs.UpdateChapterDTO request) {
        ChapterDTOs.ChapterDetailResponseDto updatedChapter = chapterService.updateChapter(id, request);
        return ResponseEntity.ok(updatedChapter);
    }

    @PutMapping(ChapterConstants.BULK_UPDATE_PATH)
    @RequiredRole({"ADMIN", "INSTRUCTOR"})
    public ResponseEntity<List<ChapterDTOs.ChapterResponseDto>> bulkUpdateChapters(@RequestBody @Valid ChapterDTOs.BulkUpdateChapterDTO request) {
        List<ChapterDTOs.ChapterResponseDto> updatedChapters = chapterService.bulkUpdateChapters(request.getChapterIds(), request.getChapters());
        return ResponseEntity.ok(updatedChapters);
    }

    @DeleteMapping(ChapterConstants.DELETE_PATH)
    @RequiredRole({"ADMIN", "INSTRUCTOR"})
    public ResponseEntity<String> deleteChapter(@PathVariable @Valid long id) {
        chapterService.deleteChapter(id);
        return ResponseEntity.ok("Chapter deleted successfully");
    }

    @DeleteMapping(ChapterConstants.BULK_DELETE_PATH)
    @RequiredRole({"ADMIN", "INSTRUCTOR"})
    public ResponseEntity<String> bulkDeleteChapters(@RequestBody @Valid ChapterDTOs.BulkOperationChapterDTO request) {
        chapterService.bulkDeleteChapters(request.getChapterIds());
        return ResponseEntity.ok("Chapters deleted successfully");
    }

    @PostMapping(ChapterConstants.RESTORE_PATH)
    @RequiredRole({"ADMIN", "INSTRUCTOR"})
    public ResponseEntity<String> restoreChapter(@PathVariable @Valid long id) {
        chapterService.restoreChapter(id);
        return ResponseEntity.ok("Chapter restored successfully");
    }

    @PostMapping(ChapterConstants.BULK_RESTORE_PATH)
    @RequiredRole({"ADMIN", "INSTRUCTOR"})
    public ResponseEntity<String> bulkRestoreChapters(@RequestBody @Valid ChapterDTOs.BulkOperationChapterDTO request) {
        chapterService.bulkRestoreChapters(request.getChapterIds());
        return ResponseEntity.ok("Chapters restored successfully");
    }

    @PostMapping(ChapterConstants.GET_DETAILS_PATH)
    public ResponseEntity<ChapterDTOs.ChapterResponseDto> getChapterDetailsById(@PathVariable @Valid long id) {

        ChapterDTOs.ChapterResponseDto response = chapterService.getChapterById(id);
        return ResponseEntity.ok(response);
    }

    @PostMapping(ChapterConstants.GET_DETAILS_WITH_LESSONS_PATH)
    public ResponseEntity<ChapterDTOs.ChapterDetailResponseDto> getChapterDetailsWithLessonsById(@PathVariable @Valid long id) {
        ChapterDTOs.ChapterDetailResponseDto response = chapterService.getChapterWithLessons(id);
        return ResponseEntity.ok(response);
    }

    @PostMapping(ChapterConstants.GET_CHAPTERS_BY_COURSE_PATH)
    public ResponseEntity<List<ChapterDTOs.ChapterResponseDto>> getChaptersByCourseId(@PathVariable @Valid long courseId) {
        List<ChapterDTOs.ChapterResponseDto> response = chapterService.getAllChaptersByCourseId(courseId);
        return ResponseEntity.ok(response);
    }

    @PostMapping(ChapterConstants.SEARCH_CHAPTERS_PATH)
    public ResponseEntity<PaginationDto.PaginationResponseDto<ChapterDTOs.ChapterResponseDto>> searchChapters(
            @Valid @RequestBody ChapterDTOs.ChapterSearchDTO searchRequest) {

        var chaptersPage = chapterService.searchChapters(searchRequest, searchRequest.toPageable());

        var response = new PaginationDto.PaginationResponseDto<>(
                chaptersPage.getContent(),
                chaptersPage.getNumber() + 1,
                chaptersPage.getSize(),
                chaptersPage.getTotalElements());

        return ResponseEntity.ok(response);
    }

    @PostMapping(ChapterConstants.CHAPTER_REORDERED_PATH)
    @RequiredRole({"ADMIN", "INSTRUCTOR"})
    public ResponseEntity<String> reorderChapters(@PathVariable @Valid long id) {
        chapterService.reorderChapters(id);
        return ResponseEntity.ok("Chapter reordered successfully");
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/controller/CourseController.java">
package com.online.course.management.project.controller;

import com.online.course.management.project.constants.CourseConstants;
import com.online.course.management.project.dto.CourseDTOS;
import com.online.course.management.project.dto.PaginationDto;
import com.online.course.management.project.enums.CourseStatus;
import com.online.course.management.project.security.RequiredRole;
import com.online.course.management.project.service.interfaces.ICourseService;
import jakarta.validation.Valid;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping(CourseConstants.BASE_PATH)
@Slf4j
public class CourseController {

    private final ICourseService courseService;

    @Autowired
    public CourseController(ICourseService courseService) {
        this.courseService = courseService;
    }

    @PostMapping(CourseConstants.CREATE_PATH)
    @RequiredRole({"ADMIN"})
    public ResponseEntity<CourseDTOS.CourseDetailsResponseDto> createCourse(@RequestBody @Valid CourseDTOS.CreateCourseRequestDTO request) {

        CourseDTOS.CourseDetailsResponseDto createdCourse = courseService.createCourse(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(createdCourse);
    }

    @PutMapping(CourseConstants.UPDATE_PATH)
    @RequiredRole({"ADMIN", "INSTRUCTOR"})
    public ResponseEntity<CourseDTOS.CourseDetailsResponseDto> updateCourse(@PathVariable @Valid long id, @RequestBody @Valid CourseDTOS.UpdateCourseRequestDTO request) {
        CourseDTOS.CourseDetailsResponseDto updatedCourse = courseService.updateCourse(id, request);
        return ResponseEntity.ok(updatedCourse);
    }

    @PatchMapping(CourseConstants.ARCHIVE_PATH)
    @RequiredRole({"ADMIN"})
    public ResponseEntity<String> archiveCourse(@PathVariable @Valid long id) {
        courseService.archiveCourse(id);
        return ResponseEntity.ok().body("Course archived successfully");
    }

    @PatchMapping(CourseConstants.UNARCHIVE_PATH)
    @RequiredRole({"ADMIN"})
    public ResponseEntity<String> unarchiveCourse(@PathVariable @Valid long id) {
        courseService.unarchiveCourse(id);
        return ResponseEntity.ok().body("Course unarchived successfully");
    }

    @PostMapping(CourseConstants.PATH_VARIABLE_PATH)
    public ResponseEntity<CourseDTOS.CourseDetailsResponseDto> getCourseById(@PathVariable @Valid long id) {
        log.info("Fetching course with id: {}", id);
        CourseDTOS.CourseDetailsResponseDto response = courseService.getCourseById(id);
        return ResponseEntity.ok(response);
    }

    @PostMapping(CourseConstants.SEARCH_COURSE_INSTRUCTOR_PATH)
    public ResponseEntity<PaginationDto.PaginationResponseDto<CourseDTOS.CourseDetailsResponseDto>> searchCoursesByInstructor(
            @Valid @RequestBody CourseDTOS.SearchInstructorCourseRequestDTO searchRequest) {
        log.info("Searching courses with criteria: {}, page: {}, size: {}",
                searchRequest, searchRequest.getPage(), searchRequest.getLimit());

        var coursesPage = courseService.getCoursesByInstructor(searchRequest.getInstructorId(), searchRequest.isIncludeArchived(), searchRequest.toPageable());

        var response = new PaginationDto.PaginationResponseDto<>(
                coursesPage.getContent(),
                coursesPage.getNumber() + 1,
                coursesPage.getSize(),
                coursesPage.getTotalElements()
        );

        return ResponseEntity.ok(response);
    }

    @PostMapping(CourseConstants.SEARCH_COURSE_STATUS_PATH)
    public ResponseEntity<PaginationDto.PaginationResponseDto<CourseDTOS.CourseDetailsResponseDto>> searchCoursesByStatus(
            @Valid @RequestBody CourseDTOS.SearchStatusRequestDTO searchRequest) {
        log.info("Searching courses with status: {}, page: {}, size: {}",
                searchRequest, searchRequest.getPage(), searchRequest.getLimit());

        var coursesPage = courseService.getCoursesByStatus(CourseStatus.valueOf(searchRequest.getStatus()), searchRequest.toPageable());

        var response = new PaginationDto.PaginationResponseDto<>(
                coursesPage.getContent(),
                coursesPage.getNumber() + 1,
                coursesPage.getSize(),
                coursesPage.getTotalElements()
        );

        return ResponseEntity.ok(response);
    }

    @PostMapping(CourseConstants.SEARCH_LATEST_COURSES_PATH)
    public ResponseEntity<List<CourseDTOS.CourseDetailsResponseDto>> searchLatestCourses(
            @Valid @RequestBody CourseDTOS.SearchLatestCoursesRequestDTO searchRequest) {
        log.info("Searching latest courses with limit: {}", searchRequest.getLimit());

        var listLatestCourses = courseService.getLatestCourses(searchRequest.getLimit());

        return ResponseEntity.ok(listLatestCourses);
    }

    @PostMapping(CourseConstants.SEARCH_PATH)
    public ResponseEntity<PaginationDto.PaginationResponseDto<CourseDTOS.CourseDetailsResponseDto>> searchCourses(
            @Valid @RequestBody CourseDTOS.SearchCourseRequestDTO searchRequest) {

        var coursesPage = courseService.searchCourses(searchRequest, searchRequest.toPageable());

        var response = new PaginationDto.PaginationResponseDto<>(
                coursesPage.getContent(),
                coursesPage.getNumber() + 1,
                coursesPage.getSize(),
                coursesPage.getTotalElements()
        );

        return ResponseEntity.ok(response);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/controller/CustomErrorController.java">
package com.online.course.management.project.controller;

import com.online.course.management.project.dto.ErrorResponseDTO;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.web.servlet.error.ErrorController;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.HttpRequestMethodNotSupportedException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.NoHandlerFoundException;

@ControllerAdvice
@Slf4j
public class CustomErrorController implements ErrorController {

    @ExceptionHandler(NoHandlerFoundException.class)
    public ResponseEntity<ErrorResponseDTO> handleNoHandlerFound(NoHandlerFoundException ex) {
        log.warn("No handler found for {} {}", ex.getHttpMethod(), ex.getRequestURL());

        ErrorResponseDTO errorResponse = new ErrorResponseDTO(
                String.format("The requested resource '%s' was not found", ex.getRequestURL()),
                HttpStatus.NOT_FOUND.value()
        );

        return new ResponseEntity<>(errorResponse, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)
    public ResponseEntity<ErrorResponseDTO> handleMethodNotSupported(HttpRequestMethodNotSupportedException ex) {
        log.warn("Method not supported: {}", ex.getMessage());

        ErrorResponseDTO errorResponse = new ErrorResponseDTO(
                String.format("The %s method is not supported for this resource. Supported methods are: %s",
                        ex.getMethod(), String.join(", ", ex.getSupportedMethods())),
                HttpStatus.METHOD_NOT_ALLOWED.value()
        );

        return new ResponseEntity<>(errorResponse, HttpStatus.METHOD_NOT_ALLOWED);
    }

    // Add a method to handle basic error paths
    @RequestMapping("/error")
    public ResponseEntity<ErrorResponseDTO> handleError() {
        ErrorResponseDTO errorResponse = new ErrorResponseDTO(
                "An error occurred processing the request",
                HttpStatus.INTERNAL_SERVER_ERROR.value()
        );
        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/controller/LessonController.java">
package com.online.course.management.project.controller;

import com.online.course.management.project.constants.LessonConstants;
import com.online.course.management.project.dto.LessonDTOs;
import com.online.course.management.project.dto.PaginationDto;
import com.online.course.management.project.security.RequiredRole;
import com.online.course.management.project.service.interfaces.ILessonService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Controller
@RequestMapping(LessonConstants.BASE_PATH)
public class LessonController {

    private final ILessonService lessonService;

    @Autowired
    public LessonController(ILessonService lessonService) {
        this.lessonService = lessonService;
    }

    @PostMapping(LessonConstants.CREATE_PATH)
    @RequiredRole({"ADMIN", "INSTRUCTOR"})
    public ResponseEntity<LessonDTOs.LessonResponseDto> createLesson(@RequestBody @Valid LessonDTOs.CreateLessonDTOWithChapterId request) {

        LessonDTOs.LessonResponseDto createdLesson = lessonService.createLesson(request);
        return ResponseEntity.status(201).body(createdLesson);
    }

    @PostMapping(LessonConstants.BULK_CREATE_PATH)
    @RequiredRole({"ADMIN", "INSTRUCTOR"})
    public ResponseEntity<List<LessonDTOs.LessonResponseDto>> bulkCreateLessons(@RequestBody @Valid LessonDTOs.BulkCreateLessonDTO request) {

        List<LessonDTOs.LessonResponseDto> createdLessons = lessonService.bulkCreateLessons(request);
        return ResponseEntity.status(201).body(createdLessons);
    }

    @PutMapping(LessonConstants.UPDATE_PATH)
    @RequiredRole({"ADMIN", "INSTRUCTOR"})
    public ResponseEntity<LessonDTOs.LessonResponseDto> updateLesson(@PathVariable @Valid long id, @RequestBody @Valid LessonDTOs.UpdateLessonDTO request) {
        LessonDTOs.LessonResponseDto updatedLesson = lessonService.updateLesson(id, request);
        return ResponseEntity.ok(updatedLesson);
    }

    @PutMapping(LessonConstants.BULK_UPDATE_PATH)
    @RequiredRole({"ADMIN", "INSTRUCTOR"})
    public ResponseEntity<List<LessonDTOs.LessonResponseDto>> bulkUpdateLessons(@RequestBody @Valid LessonDTOs.BulkUpdateLessonDTO request) {
        List<LessonDTOs.LessonResponseDto> updatedLessons = lessonService.bulkUpdateLessons(request);
        return ResponseEntity.ok(updatedLessons);
    }

    @DeleteMapping(LessonConstants.DELETE_PATH)
    @RequiredRole({"ADMIN", "INSTRUCTOR"})
    public ResponseEntity<String> deleteLesson(@PathVariable @Valid long id) {
        lessonService.deleteSingleLesson(id);
        return ResponseEntity.ok("Lesson deleted successfully");
    }

    @DeleteMapping(LessonConstants.BULK_DELETE_PATH)
    @RequiredRole({"ADMIN", "INSTRUCTOR"})
    public ResponseEntity<String> bulkDeleteLessons(@RequestBody @Valid LessonDTOs.BulkOperationLessonDTO request) {
        lessonService.bulkDeleteLessons(request.getLessonIds());
        return ResponseEntity.ok("Lessons deleted successfully");
    }

    @PostMapping(LessonConstants.RESTORE_PATH)
    @RequiredRole({"ADMIN", "INSTRUCTOR"})
    public ResponseEntity<String> restoreLesson(@PathVariable @Valid long id) {
        lessonService.restoreLesson(id);
        return ResponseEntity.ok("Lesson restored successfully");
    }

    @PostMapping(LessonConstants.BULK_RESTORE_PATH)
    @RequiredRole({"ADMIN", "INSTRUCTOR"})
    public ResponseEntity<String> bulkRestoreLessons(@RequestBody @Valid LessonDTOs.BulkOperationLessonDTO request) {
        lessonService.bulkRestoreLessons(request.getLessonIds());
        return ResponseEntity.ok("Lessons restored successfully");
    }

    @PostMapping(LessonConstants.SEARCH_PATH)
    public ResponseEntity<PaginationDto.PaginationResponseDto<LessonDTOs.LessonDetailResponseDto>> searchLessons(
            @Valid @RequestBody LessonDTOs.LessonSearchDTO searchRequest) {

        var lessonsPage = lessonService.searchLessons(searchRequest);

        var response = new PaginationDto.PaginationResponseDto<>(
                lessonsPage.getContent(),
                lessonsPage.getNumber() + 1,
                lessonsPage.getSize(),
                lessonsPage.getTotalElements()
        );

        return ResponseEntity.ok(response);
    }

    @PostMapping(LessonConstants.REORDER_PATH)
    @RequiredRole({"ADMIN", "INSTRUCTOR"})
    public ResponseEntity<String> reorderLessons(@PathVariable @Valid long id) {
        lessonService.reorderLessons(id);
        return ResponseEntity.ok("Lessons reordered successfully");
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/controller/UserController.java">
package com.online.course.management.project.controller;

import com.online.course.management.project.constants.UserConstants;
import com.online.course.management.project.dto.PaginationDto;
import com.online.course.management.project.dto.UserDTOs;
import com.online.course.management.project.enums.RoleType;
import com.online.course.management.project.mapper.UserMapper;
import com.online.course.management.project.security.CustomUserDetails;
import com.online.course.management.project.security.JwtUtil;
import com.online.course.management.project.security.RequiredRole;
import com.online.course.management.project.service.interfaces.IUserService;
import com.online.course.management.project.utils.user.UserControllerUtils;
import com.online.course.management.project.utils.user.UserServiceUtils;
import jakarta.validation.Valid;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

import java.util.Optional;
import java.util.Set;

@RestController
@RequestMapping(UserConstants.BASE_PATH)
@Slf4j
public class UserController {

    private final IUserService userService;
    private final UserMapper userMapper;
    private final JwtUtil jwtUtil;
    private final UserControllerUtils userControllerUtils;

    @Autowired
    public UserController(IUserService userService, UserMapper userMapper, JwtUtil jwtUtil, UserControllerUtils userControllerUtils) {
        this.userService = userService;
        this.userMapper = userMapper;
        this.jwtUtil = jwtUtil;
        this.userControllerUtils = userControllerUtils;
    }

    @PostMapping(UserConstants.REGISTER_PATH)
    public ResponseEntity<UserDTOs.UserResponseDto> registerUser(@Valid @RequestBody UserDTOs.UserRegistrationDto registrationDto) {
        log.info("Received registration request for email: {}", registrationDto.getEmail());
        UserDTOs.UserResponseDto responseDto = userService.registerUser(registrationDto);
        return ResponseEntity.status(HttpStatus.CREATED).body(responseDto);
    }

    @PostMapping(UserConstants.LOGIN_PATH)
    public ResponseEntity<UserDTOs.JwtResponseDto> loginUser(@Valid @RequestBody UserDTOs.UserLoginDto loginDto) {
        log.info("Received login request for username/email: {}", loginDto.getUsernameOrEmail());
        Authentication authentication = userControllerUtils.authenticate(loginDto.getUsernameOrEmail(), loginDto.getPassword());
        String jwt = jwtUtil.generateToken((CustomUserDetails) authentication.getPrincipal());
        return ResponseEntity.ok(new UserDTOs.JwtResponseDto(jwt));
    }

    @GetMapping(UserConstants.PATH_VARIABLE_PATH)
    @RequiredRole({"USER", "ADMIN"})
    public ResponseEntity<UserDTOs.UserResponseDto> getUserById(@PathVariable Long id) {
        log.info("Fetching user with id: {}", id);
        return userService.getUserById(id)
                .map(user -> ResponseEntity.ok(userMapper.toDto(user)))
                .orElse(ResponseEntity.notFound().build());
    }

    @PutMapping(UserConstants.PROFILE_PATH)
    public ResponseEntity<UserDTOs.UserResponseDto> updateUserProfile(@Valid @RequestBody UserDTOs.UpdateProfileDto updateProfileDto) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        CustomUserDetails userDetails = (CustomUserDetails) authentication.getPrincipal();
        Long userId = userDetails.getId();

        log.info("Updating profile for user id: {}", userId);
        UserDTOs.UserResponseDto updatedUser = userService.updateUserProfile(userId, updateProfileDto);
        return ResponseEntity.ok(updatedUser);
    }

    @PutMapping(UserConstants.UPDATE_ROLES_PATH)
    @RequiredRole({"ADMIN"})
    public ResponseEntity<UserDTOs.RoleUpdateResponseDto> updateUserRoles(@PathVariable Long id, @Valid @RequestBody UserDTOs.UpdateUserRolesDto updateUserRolesDto) {
        log.info("Updating roles for user id: {}", id);

        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        CustomUserDetails currentUser = (CustomUserDetails) authentication.getPrincipal();

        Set<RoleType> validRoles = userControllerUtils.validateRoles(updateUserRolesDto.getRoles());

        var updatedRoles = userService.updateUserRoles(id, validRoles, currentUser.getId());

        UserDTOs.RoleUpdateResponseDto responseDto = new UserDTOs.RoleUpdateResponseDto(
                "Roles updated successfully",
                updatedRoles
        );
        return ResponseEntity.ok().body(responseDto);
    }

    @GetMapping(UserConstants.ALL_PATH)
    @RequiredRole({"ADMIN"})
    public ResponseEntity<PaginationDto.PaginationResponseDto> getAllUsers(@Valid PaginationDto.PaginationRequestDto paginationRequestDto) {
        int page = paginationRequestDto.getPage();
        int limit = paginationRequestDto.getLimit();

        log.info("Fetching all users with roles, page: {}, limit: {}", page, limit);


        Pageable pageable = PageRequest.of(page - 1, limit);
        Page<UserDTOs.UserWithRolesResponseDto> users = userService.getAllUsers(paginationRequestDto.toPageable());
        long totalUsers = userService.countUsers(Optional.empty());

        PaginationDto.PaginationResponseDto<UserDTOs.UserWithRolesResponseDto> response = new PaginationDto.PaginationResponseDto<>(
                users.getContent(),
                users.getNumber() + 1,
                users.getSize(),
                totalUsers
        );

        return ResponseEntity.ok().body(response);
    }

    @GetMapping(UserConstants.SEARCH_PATH)
    @RequiredRole({"ADMIN"})
    public ResponseEntity<PaginationDto.PaginationResponseDto<UserDTOs.UserWithRolesResponseDto>> searchUsers(
            @Valid UserDTOs.UserSearchRequestDto searchRequest,
            @Valid PaginationDto.PaginationRequestDto paginationRequest) {

        log.info("Searching users with criteria: {}, page: {}, size: {}",
                searchRequest, paginationRequest.getPage(), paginationRequest.getLimit());

        Page<UserDTOs.UserWithRolesResponseDto> usersPage = userService.searchUsers(
                searchRequest, paginationRequest.toPageable());
        long totalSearchedUsers = userService.countUsers(Optional.of(searchRequest));

        PaginationDto.PaginationResponseDto<UserDTOs.UserWithRolesResponseDto> response = new PaginationDto.PaginationResponseDto<>(
                usersPage.getContent(),
                usersPage.getNumber() + 1,
                usersPage.getSize(),
                totalSearchedUsers
        );

        return ResponseEntity.ok(response);
    }

    @DeleteMapping(UserConstants.PATH_VARIABLE_PATH)
    @RequiredRole({"ADMIN"})
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        log.info("Deleting user with id: {}", id);
        userService.softDeleteUser(id);
        return ResponseEntity.noContent().build();
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/converter/StringToLocalDateTimeConverter.java">
package com.online.course.management.project.converter;

import com.online.course.management.project.exception.business.InvalidRequestException;
import org.springframework.core.convert.converter.Converter;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeFormatterBuilder;
import java.time.format.DateTimeParseException;

@Component
public class StringToLocalDateTimeConverter implements Converter<String, LocalDateTime> {
    // Format for full date-time
    private static final DateTimeFormatter DATE_TIME_FORMATTER =
            DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss");

    // More lenient format for simple date that allows single digits
    private static final DateTimeFormatter LENIENT_DATE_FORMATTER =
            new DateTimeFormatterBuilder()
                    .appendPattern("yyyy-")
                    .appendPattern("M-")    // Single M allows single-digit months
                    .appendPattern("d")     // Single d allows single-digit days
                    .toFormatter();

    @Override
    public LocalDateTime convert(String source) {
        if (!StringUtils.hasText(source)) {
            return null;
        }

        try {
            // Check if it's a simple date format (no time component)
            if (!source.contains("T")) {
                LocalDate date = LocalDate.parse(source, LENIENT_DATE_FORMATTER);
                return date.atStartOfDay();
            }

            // Try parsing as full date time
            return LocalDateTime.parse(source, DATE_TIME_FORMATTER);

        } catch (DateTimeParseException e) {
            throw new InvalidRequestException(
                    "Invalid date format. Supported formats: " +
                            "yyyy-MM-dd'T'HH:mm:ss.SSS (e.g., 2024-08-27T17:29:01.187) or " +
                            "yyyy-M-d (e.g., 2024-8-27 or 2024-08-27)"
            );
        }
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/dto/CategoryDTOs.java">
package com.online.course.management.project.dto;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import jakarta.validation.constraints.AssertTrue;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.*;
import org.springframework.format.annotation.DateTimeFormat;

import java.time.LocalDateTime;

public class CategoryDTOs {

    @Data
    public static class CategoryResponseDto {
        private Long id;
        private String name;
        private Long courseCount;
        private LocalDateTime createdAt;
        private LocalDateTime updatedAt;
        private LocalDateTime deletedAt;
    }

    @Data
    public static class CreateCategoryDTO {
        @NotBlank(message = "Category name is required")
        @Size(max = 100, message = "Category name must not exceed 100 characters")
        private String name;
    }

    @Data
    public static class UpdateCategoryDTO {
        @NotBlank(message = "Category name is required")
        @Size(max = 100, message = "Category name must not exceed 100 characters")
        private String name;
    }


    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    @JsonIgnoreProperties(ignoreUnknown = false)
    @EqualsAndHashCode(callSuper = true)
    public static class CategorySearchDTO extends PaginationDto.PaginationRequestDto {
        private String name;
        private Boolean archived;

        @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)
        private LocalDateTime fromDate;

        @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)
        private LocalDateTime toDate;

        // Add validation to ensure toDate is after fromDate
        @AssertTrue(message = "toDate must be after fromDate")
        private boolean isDateRangeValid() {
            if (fromDate == null || toDate == null) {
                return true;
            }
            return toDate.isAfter(fromDate);
        }
    }

    @Data
    @AllArgsConstructor
    public static class RestoreCategoryResponseDTO {
        private String message;
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/dto/ChapterDTOs.java">
package com.online.course.management.project.dto;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.online.course.management.project.enums.CourseStatus;
import jakarta.validation.Valid;
import jakarta.validation.constraints.*;
import lombok.*;
import org.springframework.format.annotation.DateTimeFormat;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

public class ChapterDTOs {

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ChapterResponseDto {
        private Long id;
        private Long courseId;
        private String courseTitle;
        private String title;
        private String description;
        private Integer order;
        private CourseStatus status;
        private int totalLessons;
        private int completedLessons;
        private int inProgressLessons;
        private LocalDateTime createdAt;
        private LocalDateTime updatedAt;
        private LocalDateTime deletedAt;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class CreateChapterDTO {
        @NotNull(message = "Course ID is required")
        private Long courseId;

        @NotBlank(message = "Chapter title is required")
        @Size(max = 255, message = "Title must not exceed 255 characters")
        private String title;

        @Size(max = 1000, message = "Description must not exceed 1000 characters")
        private String description;

        @Min(value = 1, message = "Order must be greater than 0")
        private Integer order;

        @Valid
        private List<LessonDTOs.CreateLessonDTO> lessons;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class UpdateChapterDTO {
        @Size(max = 255, message = "Title must not exceed 255 characters")
        private String title;

        @Size(max = 1000, message = "Description must not exceed 1000 characters")
        private String description;

        @Min(value = 1, message = "Order must be greater than 0")
        private Integer order;

        private CourseStatus status;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @EqualsAndHashCode(callSuper = true)
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class ChapterSearchDTO extends PaginationDto.PaginationRequestDto {
        private String title;
        private CourseStatus status;
        private Long courseId;

        @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)
        private LocalDateTime fromDate;

        @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)
        private LocalDateTime toDate;

        private Map<String, String> sort;

        @AssertTrue(message = "toDate must be after fromDate")
        private boolean isDateRangeValid() {
            if (fromDate == null || toDate == null) {
                return true;
            }
            return toDate.isAfter(fromDate);
        }
    }

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ChapterDetailResponseDto {
        private Long id;
        private Long courseId;
        private String courseTitle;
        private CourseStatus courseStatus;
        private String title;
        private String description;
        private Integer order;
        private CourseStatus status;
        private List<LessonDTOs.LessonResponseDto> lessons;
        private int completedLessons;
        private int inProgressLessons;
        private LocalDateTime createdAt;
        private LocalDateTime updatedAt;
        private LocalDateTime deletedAt;
    }

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class BulkCreateChapterDTO {
        @NotEmpty(message = "At least one chapter is required")
        private List<CreateChapterDTO> chapters;
    }

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class BulkUpdateChapterDTO {

        @NotNull(message = "Chapter ids are required")
        private List<Long> chapterIds;

        @NotEmpty(message = "At least one chapter is required")
        private List<UpdateChapterDTO> chapters;
    }

    @Data
    @AllArgsConstructor
    public static class ChapterOrderDTO {
        @NotNull(message = "Chapter ID is required")
        private Long id;

        @NotNull(message = "Order is required")
        @Min(value = 1, message = "Order must be greater than 0")
        private Integer order;
    }

    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    public static class BulkOperationChapterDTO {
        @NotNull(message = "Chapter IDs are required")
        private List<Long> chapterIds;
    }

    @Data
    @AllArgsConstructor
    public static class RestoreChapterResponseDTO {
        private String message;
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/dto/CommonResponseDTOs.java">
package com.online.course.management.project.dto;

import lombok.Data;
import org.springframework.http.HttpStatus;

public class CommonResponseDTOs {

    @Data
    public static class DeleteSuccessfullyDTO {
        private String message;
        private HttpStatus status = HttpStatus.NO_CONTENT;

        public DeleteSuccessfullyDTO(
                String message) {
            this.message = message;
        }
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/dto/CourseDTOS.java">
package com.online.course.management.project.dto;

import com.online.course.management.project.enums.CourseStatus;
import jakarta.validation.constraints.*;
import lombok.*;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.format.annotation.DateTimeFormat;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class CourseDTOS {

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class CourseDetailsResponseDto {
        private Long id;
        private String title;
        private String description;
        private CourseStatus status;
        private InstructorDetailsDto instructor;
        private Set<String> categoryNames;
        private LocalDateTime createdAt;
        private LocalDateTime updatedAt;
    }

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class InstructorDetailsDto {
        private Long id;
        private String username;
        private String email;
        private String realName;
        private Set<String> roles;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class CreateCourseRequestDTO {
        @NotBlank(message = "Course title is required")
        @Size(max = 255, message = "Title must not exceed 255 characters")
        private String title;

        @Size(max = 1000, message = "Description must not exceed 1000 characters")
        @NotBlank(message = "Description is required")
        private String description;

        private Set<Long> categoryIds;

        private Long instructorId;

        private CourseStatus status = CourseStatus.DRAFT;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class UpdateCourseRequestDTO {
        @Size(max = 255, message = "Title must not exceed 255 characters")
        @NotBlank(message = "Title is required")
        private String title;

        @Size(max = 1000, message = "Description must not exceed 1000 characters")
        @NotBlank(message = "Description is required")
        private String description;

        private CourseStatus status;

        private Set<Long> categoryIds;

        private Long instructorId; // Optional, only for admin use
    }


    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @EqualsAndHashCode(callSuper = true)
    public static class SearchCourseRequestDTO extends PaginationDto.PaginationRequestDto {
        private String title;
        private CourseStatus status;
        private String instructorName;
        private Set<Long> categoryIds;
        private Boolean includeArchived;

        @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)
        private LocalDateTime fromDate;

        @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)
        private LocalDateTime toDate;

        private Map<String, String> sort;

        @AssertTrue(message = "toDate must be after fromDate")
        private boolean isDateRangeValid() {
            if (fromDate == null || toDate == null) {
                return true;
            }
            return toDate.isAfter(fromDate);
        }

        @Override
        public org.springframework.data.domain.Pageable toPageable() {
            return PageRequest.of(getPage() - 1, getLimit());
        }
    }


    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    @EqualsAndHashCode(callSuper = true)
    public static class SearchInstructorCourseRequestDTO extends PaginationDto.PaginationRequestDto {
        @NotNull(message = "Instructor ID must not be null")
        private Long instructorId;

        private boolean includeArchived;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    @EqualsAndHashCode(callSuper = true)
    public static class SearchStatusRequestDTO extends PaginationDto.PaginationRequestDto {
        @NotNull(message = "Status must not be null")
        private String status;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class SearchLatestCoursesRequestDTO {
        private int limit = 10;
    }

}
</file>

<file path="src/main/java/com/online/course/management/project/dto/ErrorResponseDTO.java">
package com.online.course.management.project.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;
import java.util.List;

@Getter
@Setter
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ErrorResponseDTO {
    private LocalDateTime timestamp;
    private int status;
    private String message;
    private List<String> errors;

    public ErrorResponseDTO(String message, int status) {
        this(message, status, null);
    }

    public ErrorResponseDTO(String message, int status, List<String> errors) {
        this.timestamp = LocalDateTime.now();
        this.status = status;
        this.message = message;
        this.errors = errors;
    }

}
</file>

<file path="src/main/java/com/online/course/management/project/dto/LessonDTOs.java">
package com.online.course.management.project.dto;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.online.course.management.project.enums.CourseStatus;
import com.online.course.management.project.enums.LessonType;
import jakarta.validation.constraints.*;
import lombok.*;
import org.springframework.format.annotation.DateTimeFormat;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

public class LessonDTOs {

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class LessonResponseDto {
        private Long id;
        private Long chapterId;
        private String chapterTitle;
        private String title;
        private String content;
        private Integer order;
        private LessonType type;
        private CourseStatus status;
        private LocalDateTime createdAt;
        private LocalDateTime updatedAt;
        private LocalDateTime deletedAt;
    }

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class LessonDetailResponseDto {
        private Long id;
        private Long chapterId;
        private String chapterTitle;
        private Long courseId;
        private String courseTitle;
        private String title;
        private String content;
        private Integer order;
        private LessonType type;
        private CourseStatus status;
        private Integer completedByUsers;
        private Integer inProgressByUsers;
        private LocalDateTime createdAt;
        private LocalDateTime updatedAt;
        private LocalDateTime deletedAt;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class CreateLessonDTO {
        @NotBlank(message = "Lesson title is required")
        @Size(max = 255, message = "Title must not exceed 255 characters")
        private String title;

        @NotBlank(message = "Content is required")
        private String content;

        @NotNull(message = "Lesson order is required")
        @Min(value = 1, message = "Order must be greater than 0")
        private Integer order;

        @NotNull(message = "Lesson type is required")
        private LessonType type;

        private CourseStatus status = CourseStatus.DRAFT;
    }

    @EqualsAndHashCode(callSuper = true)
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class CreateLessonDTOWithChapterId extends CreateLessonDTO {
        @NotNull(message = "Chapter ID is required")
        private Long chapterId;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class UpdateLessonDTO {
        @Size(max = 255, message = "Title must not exceed 255 characters")
        private String title;

        private String content;

        @Min(value = 1, message = "Order must be greater than 0")
        private Integer order;

        private LessonType type;

        private CourseStatus status;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @EqualsAndHashCode(callSuper = true)
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class LessonSearchDTO extends PaginationDto.PaginationRequestDto {
        private String title;
        private CourseStatus status;
        private List<Long> courseIds;
        private List<Long> chapterIds;
        private LessonType type;

        private Map<String, String> sort;

        @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)
        private LocalDateTime fromDate;

        @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)
        private LocalDateTime toDate;

        @AssertTrue(message = "toDate must be after fromDate")
        private boolean isDateRangeValid() {
            if (fromDate == null || toDate == null) {
                return true;
            }
            return toDate.isAfter(fromDate);
        }
    }

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class BulkCreateLessonDTO {
        @NotNull(message = "Chapter ID is required")
        private Long chapterId;

        @NotEmpty(message = "At least one lesson is required")
        private List<CreateLessonDTO> lessons;
    }

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class BulkUpdateLessonDTO {

        @NotNull(message = "At least one lesson Ids is required")
        private List<Long> lessonIds;

        @NotEmpty(message = "At least one lesson is required")
        private List<UpdateLessonDTO> lessons;
    }

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class BulkOperationLessonDTO {
        @NotNull(message = "Lesson IDs are required")
        @NotEmpty(message = "At least one lesson ID is required")
        private List<Long> lessonIds;
    }

    @Data
    @AllArgsConstructor
    public static class RestoreLessonResponseDTO {
        private String message;
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/dto/PaginationDto.java">
package com.online.course.management.project.dto;

import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import lombok.AllArgsConstructor;
import lombok.Data;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;

import java.util.List;


public class PaginationDto {

    @Data
    public static class PaginationRequestDto {

        @Min(value = 1, message = "Page index must not be less than one")
        private int page = 1;

        @Min(value = 1, message = "Limit must be greater than or equal to 1")
        @Max(value = 50, message = "Limit must be less than or equal to 50")
        private int limit = 10;

        public Pageable toPageable() {
            return PageRequest.of(page - 1, limit);
        }
    }


    @Data
    @AllArgsConstructor
    public static class PaginationResponseDto<T> {
        private List<T> data;
        private int currentPage;
        private int limit;
        private long total;

    }
}
</file>

<file path="src/main/java/com/online/course/management/project/dto/UserDTOs.java">
package com.online.course.management.project.dto;

import jakarta.validation.constraints.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import org.springframework.format.annotation.DateTimeFormat;

import java.time.LocalDateTime;
import java.util.Set;

public class UserDTOs {
    @Data
    public static class UserRegistrationDto {
        @NotBlank
        @Size(max = 50)
        @Email
        private String email;

        @NotBlank
        @Size(min = 6, max = 40, message = "Password must be between 6 and 40 characters")
        private String password;


    }

    @Data
    public static class UserLoginDto {
        @NotBlank
        @Size(max = 50)
        private String usernameOrEmail;

        @NotBlank
        @Size(min = 6, max = 40)
        private String password;
    }

    @Data
    public static class UserResponseDto {
        private Long id;
        private String username;
        private String email;
        private String realName;
        private String status;
    }

    @Data
    public static class UpdateProfileDto {
        @Size(max = 50)
        private String username;

        @Size(max = 50)
        @Email
        private String email;

        @Size(max = 100)
        private String realName;

        @Size(min = 6, max = 40)
        private String password;

        private String status;
    }

    @Data
    public static class UpdateUserRolesDto {
        @NotEmpty
        private Set<String> roles;
    }

    @Data
    @AllArgsConstructor
    public static class JwtResponseDto {
        @NotNull
        private String token;
    }

    @Data
    @AllArgsConstructor
    public static class RoleUpdateResponseDto {
        private String message;
        private Set<String> updatedRoles;
    }

    @Data
    public static class UserWithRolesResponseDto {
        private Long id;
        private String username;
        private String email;
        private String realName;
        private String status;
        private Set<String> roles;
    }

    @Data
    public static class UserSearchRequestDto {
        @Size(max = 50)
        private String username;

        @Size(max = 50)
        @Email
        private String email;

        @Size(max = 100)
        private String realName;

        private String status;

        @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)
        private LocalDateTime fromDate;

        @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)
        private LocalDateTime toDate;
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/entity/Category.java">
package com.online.course.management.project.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = "categories")
@Getter
@Setter
public class Category {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank
    @Size(max = 100)
    @Column(nullable = false, unique = true)
    private String name;

    @ManyToMany(mappedBy = "categories", fetch = FetchType.LAZY)
    private Set<Course> courses = new HashSet<>();

    @CreationTimestamp
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(nullable = false)
    private LocalDateTime updatedAt;

    @Column
    private LocalDateTime deletedAt;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Category)) return false;
        Category category = (Category) o;
        return id != null && Objects.equals(id, category.id);
    }

    @Override
    public int hashCode() {
        return getClass().hashCode();
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/entity/Chapter.java">
package com.online.course.management.project.entity;

import com.online.course.management.project.enums.CourseStatus;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

@Entity
@Table(name = "chapters")
@Getter
@Setter
public class Chapter {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotNull
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "course_id", nullable = false)
    private Course course;

    @NotBlank(message = "Chapter title is required")
    @Size(max = 255, message = "Chapter title must not exceed 255 characters")
    @Column(nullable = false)
    private String title;

    @Size(max = 1000, message = "Description must not exceed 1000 characters")
    @Column(columnDefinition = "TEXT")
    private String description;

    @NotNull(message = "Chapter order is required")
    @Column(name = "order_number", nullable = false)
    private Integer order;

    @NotNull(message = "Status is required")
    @Enumerated(EnumType.STRING)
    @Column(length = 20, nullable = false)
    private CourseStatus status = CourseStatus.DRAFT;

    @CreationTimestamp
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(nullable = false)
    private LocalDateTime updatedAt;

    @Column
    private LocalDateTime deletedAt;

    @OneToMany(
            mappedBy = "chapter",
            cascade = CascadeType.ALL,
            fetch = FetchType.LAZY
    )
    @OrderBy("order ASC")
    private List<Lesson> lessons = new ArrayList<>();

    // Helper methods
    public void addLesson(Lesson lesson) {
        if (lessons == null) {
            lessons = new ArrayList<>();
        }

        // Only add if not already present to prevent duplicates
        if (!lessons.contains(lesson)) {
            lessons.add(lesson);
            lesson.setChapter(this);
            lesson.setOrder(lessons.size()); // Set proper order
        }
    }

    public void removeLesson(Lesson lesson) {
        if (lessons.remove(lesson)) {
            lesson.setChapter(null);
            // Reorder remaining lessons
            for (int i = 0; i < lessons.size(); i++) {
                lessons.get(i).setOrder(i + 1);
            }
        }
    }

    public void setLessons(List<Lesson> newLessons) {
        this.lessons.clear();
        if (newLessons != null) {
            // Instead, just maintain the provided order
            newLessons.forEach(lesson -> {
                lesson.setChapter(this);
                this.lessons.add(lesson);
            });
        }
    }

    // Add this method to manage status changes
    public void setStatus(CourseStatus newStatus) {
        this.status = newStatus;
        if (newStatus == CourseStatus.ARCHIVED) {
            this.deletedAt = LocalDateTime.now();
        }
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Chapter chapter)) return false;
        return id != null && Objects.equals(id, chapter.id);
    }

    @Override
    public int hashCode() {
        return getClass().hashCode();
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/entity/Course.java">
package com.online.course.management.project.entity;

import com.online.course.management.project.enums.CourseStatus;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;
import java.util.*;

@Entity
@Table(name = "courses")
@Getter
@Setter
public class Course {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank
    @Size(max = 255)
    @Column(nullable = false)
    private String title;

    @Size(max = 1000)
    @Column(columnDefinition = "TEXT")
    private String description;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "instructor_id", nullable = true)
    private User instructor;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private CourseStatus status = CourseStatus.DRAFT;

    @CreationTimestamp
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(nullable = false)
    private LocalDateTime updatedAt;

    @Column
    private LocalDateTime deletedAt;

    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE}, fetch = FetchType.LAZY)
    @JoinTable(
            name = "course_categories",
            joinColumns = @JoinColumn(name = "course_id"),
            inverseJoinColumns = @JoinColumn(name = "category_id"))
    private Set<Category> categories = new HashSet<>();

    // New relationship added for Phase 3
    @OneToMany(mappedBy = "course", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private List<Chapter> chapters = new ArrayList<>();

    public void addCategory(Category category) {
        categories.add(category);
        category.getCourses().add(this);
    }

    public void removeCategory(Category category) {
        categories.remove(category);
        category.getCourses().remove(this);
    }

    // Helper methods for chapter management
    public void addChapter(Chapter chapter) {
        chapters.add(chapter);
        chapter.setCourse(this);
        chapter.setOrder(chapters.size()); // Auto-set the order for new chapters
    }

    public void removeChapter(Chapter chapter) {
        if (chapters.remove(chapter)) {
            chapter.setCourse(null);
            // Reorder remaining chapters
            for (int i = 0; i < chapters.size(); i++) {
                chapters.get(i).setOrder(i + 1);
            }
        }
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Course)) return false;
        Course course = (Course) o;
        return id != null && Objects.equals(id, course.id);
    }

    @Override
    public int hashCode() {
        return getClass().hashCode();
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/entity/CourseRating.java">
package com.online.course.management.project.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;
import java.util.Objects;

@Entity
@Table(name = "course_ratings",
        uniqueConstraints = {
                @UniqueConstraint(
                        columnNames = {"user_id", "course_id"},
                        name = "uk_course_ratings_user_course"
                )
        }
)
@Getter
@Setter
public class CourseRating {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "course_id", nullable = false)
    private Course course;

    @NotNull(message = "Rating is required")
    @Min(value = 1, message = "Rating must be between 1 and 5")
    @Max(value = 5, message = "Rating must be between 1 and 5")
    @Column(nullable = false)
    private Integer rating;

    @Column(name = "review_text", columnDefinition = "TEXT")
    private String reviewText;

    @CreationTimestamp
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(nullable = false)
    private LocalDateTime updatedAt;

    @Column
    private LocalDateTime deletedAt;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof CourseRating)) return false;
        CourseRating that = (CourseRating) o;
        return id != null && Objects.equals(id, that.id);
    }

    @Override
    public int hashCode() {
        return getClass().hashCode();
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/entity/Lesson.java">
package com.online.course.management.project.entity;

import com.online.course.management.project.enums.CourseStatus;
import com.online.course.management.project.enums.LessonType;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;
import java.util.Objects;

@Entity
@Table(name = "lessons")
@Getter
@Setter
public class Lesson {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotNull(message = "Chapter must not be null")
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "chapter_id", nullable = false)
    private Chapter chapter;

    @NotBlank(message = "Lesson title is required")
    @Size(max = 255, message = "Lesson title must not exceed 255 characters")
    @Column(nullable = false)
    private String title;

    @Column(columnDefinition = "TEXT")
    private String content;

    @NotNull(message = "Lesson order is required")
    @Column(name = "order_number", nullable = false)
    private Integer order;

    @NotNull(message = "Lesson type is required")
    @Enumerated(EnumType.STRING)
    @Column(length = 20, nullable = false)
    private LessonType type;

    @NotNull(message = "Status is required")
    @Enumerated(EnumType.STRING)
    @Column(length = 20, nullable = false)
    private CourseStatus status = CourseStatus.DRAFT;

    @CreationTimestamp
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(nullable = false)
    private LocalDateTime updatedAt;

    @Column
    private LocalDateTime deletedAt;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Lesson lesson)) return false;
        return id != null && Objects.equals(id, lesson.id);
    }

    @Override
    public int hashCode() {
        return getClass().hashCode();
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/entity/Role.java">
package com.online.course.management.project.entity;

import com.online.course.management.project.enums.RoleType;
import jakarta.persistence.*;
import lombok.Data;

import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "roles")
@Data
public class Role {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Enumerated(EnumType.STRING)
    @Column(length = 20, unique = true, nullable = false)
    private RoleType name;

    @OneToMany(mappedBy = "role", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<UserRole> userRoles = new HashSet<>();
}
</file>

<file path="src/main/java/com/online/course/management/project/entity/User.java">
package com.online.course.management.project.entity;

import com.online.course.management.project.enums.UserStatus;
import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = "users")
@Getter
@Setter
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank
    @Size(min = 3, max = 50)
    @Column(unique = true, nullable = false)
    private String username;

    @NotBlank
    @Size(max = 50)
    @Email
    @Column(unique = true, nullable = false, length = 320)
    private String email;

    @Size(max = 100)
    @Column(name = "real_name", nullable = true)
    private String realName;

    @NotBlank
    @Size(min = 60, max = 60)
    @Column(nullable = false)
    private String passwordHash;

    @CreationTimestamp
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(nullable = false)
    private LocalDateTime updatedAt;

    @Column
    private LocalDateTime deletedAt;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private UserStatus status = UserStatus.ACTIVE;

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<UserRole> userRoles = new HashSet<>();

    // Helper methods
    public void addRole(Role role) {
        UserRole userRole = new UserRole(this, role);
        userRoles.add(userRole);
    }

    public void removeRole(Role role) {
        userRoles.removeIf(userRole -> userRole.getRole().equals(role));
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof User)) return false;
        User user = (User) o;
        return id != null && Objects.equals(id, user.id);
    }

    @Override
    public int hashCode() {
        return getClass().hashCode();
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/entity/UserCourse.java">
package com.online.course.management.project.entity;

import com.online.course.management.project.enums.EnrollmentStatus;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;

import java.time.LocalDateTime;
import java.util.Objects;

@Entity
@Table(name = "user_courses",
        uniqueConstraints = {
                @UniqueConstraint(
                        columnNames = {"user_id", "course_id"},
                        name = "uk_user_courses_user_course"
                )
        }
)
@Getter
@Setter
public class UserCourse {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "course_id", nullable = false)
    private Course course;

    @Column(name = "enrollment_date", nullable = false)
    @CreationTimestamp
    private LocalDateTime enrollmentDate;

    @Column(name = "completion_date")
    private LocalDateTime completionDate;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private EnrollmentStatus status = EnrollmentStatus.ENROLLED;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof UserCourse)) return false;
        UserCourse that = (UserCourse) o;
        return id != null && Objects.equals(id, that.id);
    }

    @Override
    public int hashCode() {
        return getClass().hashCode();
    }


}
</file>

<file path="src/main/java/com/online/course/management/project/entity/UserLessonProgress.java">
package com.online.course.management.project.entity;

import com.online.course.management.project.enums.ProgressStatus;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;
import java.util.Objects;

@Entity
@Table(name = "user_lesson_progress",
        uniqueConstraints = {
                @UniqueConstraint(
                        columnNames = {"user_id", "course_id", "chapter_id", "lesson_id"},
                        name = "uk_user_lesson_progress_unique_progress"
                )
        }
)
@Getter
@Setter
public class UserLessonProgress {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "course_id", nullable = false)
    private Course course;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "chapter_id", nullable = false)
    private Chapter chapter;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "lesson_id", nullable = false)
    private Lesson lesson;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private ProgressStatus status = ProgressStatus.NOT_STARTED;

    @Column(name = "last_accessed_at")
    private LocalDateTime lastAccessedAt;

    @Column(name = "completion_date")
    private LocalDateTime completionDate;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof UserLessonProgress)) return false;
        UserLessonProgress that = (UserLessonProgress) o;
        return id != null && Objects.equals(id, that.id);
    }

    @Override
    public int hashCode() {
        return getClass().hashCode();
    }


}
</file>

<file path="src/main/java/com/online/course/management/project/entity/UserRole.java">
package com.online.course.management.project.entity;

import jakarta.persistence.*;
import lombok.Data;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.LocalDateTime;
import java.util.Objects;

@Entity
@Table(name = "user_roles")
@Getter
@Setter
@NoArgsConstructor
public class UserRole {

    @EmbeddedId
    private UserRoleId id;

    @ManyToOne(fetch = FetchType.EAGER)
    @MapsId("userId")
    private User user;

    @ManyToOne(fetch = FetchType.EAGER)
    @MapsId("roleId")
    private Role role;

    @Column(nullable = false)
    private LocalDateTime assignedAt;

    public UserRole(User user, Role role) {
        this.user = user;
        this.role = role;
        this.id = new UserRoleId(user.getId(), role.getId());
        this.assignedAt = LocalDateTime.now();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof UserRole userRole)) return false;
        return Objects.equals(user.getId(), userRole.user.getId()) &&
                Objects.equals(role.getId(), userRole.role.getId());
    }

    @Override
    public int hashCode() {
        return Objects.hash(user.getId(), role.getId());
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/entity/UserRoleId.java">
package com.online.course.management.project.entity;

import jakarta.persistence.Embeddable;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Embeddable
@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserRoleId implements Serializable {

    private Long userId;
    private Long roleId;
}
</file>

<file path="src/main/java/com/online/course/management/project/enums/CourseStatus.java">
package com.online.course.management.project.enums;

public enum CourseStatus {
    DRAFT,
    PUBLISHED,
    ARCHIVED
}
</file>

<file path="src/main/java/com/online/course/management/project/enums/EnrollmentStatus.java">
package com.online.course.management.project.enums;

public enum EnrollmentStatus {
    ENROLLED,
    IN_PROGRESS,
    COMPLETED,
    DROPPED
}
</file>

<file path="src/main/java/com/online/course/management/project/enums/LessonType.java">
package com.online.course.management.project.enums;

public enum LessonType {
    VIDEO,
    TEXT,
    QUIZ
}
</file>

<file path="src/main/java/com/online/course/management/project/enums/ProgressStatus.java">
package com.online.course.management.project.enums;

public enum ProgressStatus {
    NOT_STARTED,
    IN_PROGRESS,
    COMPLETED,
    DROPPED
}
</file>

<file path="src/main/java/com/online/course/management/project/enums/RoleType.java">
package com.online.course.management.project.enums;

public enum RoleType {
    USER,
    ADMIN,
    INSTRUCTOR
}
</file>

<file path="src/main/java/com/online/course/management/project/enums/UserStatus.java">
package com.online.course.management.project.enums;

public enum UserStatus {
    ACTIVE, INACTIVE, SUSPENDED
}
</file>

<file path="src/main/java/com/online/course/management/project/exception/BaseException.java">
package com.online.course.management.project.exception;

public class BaseException extends RuntimeException {
    public BaseException(String message) {
        super(message);
    }

    public BaseException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/exception/business/account/AccountException.java">
package com.online.course.management.project.exception.business.account;

import com.online.course.management.project.exception.business.BusinessException;

public class AccountException extends BusinessException {
    public AccountException(String message) {
        super(message);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/exception/business/account/EmailAlreadyExistsException.java">
package com.online.course.management.project.exception.business.account;

public class EmailAlreadyExistsException extends AccountException {
    public EmailAlreadyExistsException(String message) {
        super(message);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/exception/business/account/WrongEmailPasswordException.java">
package com.online.course.management.project.exception.business.account;

public class WrongEmailPasswordException extends AccountException {
    public WrongEmailPasswordException(String message) {
        super(message);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/exception/business/BusinessException.java">
package com.online.course.management.project.exception.business;

import com.online.course.management.project.exception.BaseException;

public class BusinessException extends BaseException {
    public BusinessException(String message) {
        super(message);
    }

    public BusinessException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/exception/business/ForbiddenException.java">
package com.online.course.management.project.exception.business;

public class ForbiddenException extends BusinessException {
    public ForbiddenException(String message) {
        super(message);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/exception/business/InvalidRequestException.java">
package com.online.course.management.project.exception.business;

public class InvalidRequestException extends BusinessException {
    public InvalidRequestException(String message) {
        super(message);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/exception/business/InvalidRoleInfoException.java">
package com.online.course.management.project.exception.business;

public class InvalidRoleInfoException extends BusinessException {
    public InvalidRoleInfoException(String message) {
        super(message);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/exception/business/ResourceNotFoundException.java">
package com.online.course.management.project.exception.business;

public class ResourceNotFoundException extends BusinessException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/exception/business/UnauthorizedException.java">
package com.online.course.management.project.exception.business;

public class UnauthorizedException extends BusinessException {
    public UnauthorizedException(String message) {
        super(message);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/exception/GlobalExceptionHandler.java">
package com.online.course.management.project.exception;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.exc.InvalidFormatException;
import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;
import com.online.course.management.project.dto.ErrorResponseDTO;
import com.online.course.management.project.exception.business.*;
import com.online.course.management.project.exception.business.account.AccountException;
import com.online.course.management.project.exception.business.account.EmailAlreadyExistsException;
import com.online.course.management.project.exception.business.account.WrongEmailPasswordException;
import com.online.course.management.project.exception.technical.DatabaseException;
import com.online.course.management.project.exception.technical.ExternalServiceException;
import com.online.course.management.project.exception.technical.TechnicalException;
import com.online.course.management.project.utils.exception.GlobalExceptionUtils;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.security.core.AuthenticationException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

import java.util.*;
import java.util.stream.Collectors;

@ControllerAdvice
@Slf4j
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponseDTO> handleBusinessException(BusinessException ex) {
        log.warn("Business exception occurred: {}", ex.getMessage());
        HttpStatus status = HttpStatus.BAD_REQUEST;
        if (ex instanceof ResourceNotFoundException) {
            status = HttpStatus.NOT_FOUND;
        } else if (ex instanceof UnauthorizedException) {
            status = HttpStatus.UNAUTHORIZED;
        } else if (ex instanceof ForbiddenException) {
            status = HttpStatus.FORBIDDEN;
        } else if (ex instanceof AccountException) {
            if (ex instanceof EmailAlreadyExistsException) {
                status = HttpStatus.CONFLICT;
            } else if (ex instanceof WrongEmailPasswordException) {
                status = HttpStatus.UNAUTHORIZED;
            }

        }
        ErrorResponseDTO errorResponse = new ErrorResponseDTO(ex.getMessage(), status.value());
        return new ResponseEntity<>(errorResponse, status);
    }

    @ExceptionHandler(TechnicalException.class)
    public ResponseEntity<ErrorResponseDTO> handleTechnicalException(TechnicalException ex) {
        log.error("Technical exception occurred: {}", ex.getMessage(), ex);
        HttpStatus status = HttpStatus.INTERNAL_SERVER_ERROR;
        String message = "An internal error occurred";

        if (ex instanceof DatabaseException) {
            message = "A database error occurred";
        } else if (ex instanceof ExternalServiceException) {
            message = "An error occurred with an external service";
            status = HttpStatus.BAD_GATEWAY;
        }

        ErrorResponseDTO errorResponse = new ErrorResponseDTO(message, status.value());
        return new ResponseEntity<>(errorResponse, status);
    }

    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex,
            HttpHeaders headers,
            HttpStatusCode status,
            WebRequest request) {
        log.warn("Validation failed: {}", ex.getMessage());
        List<String> errors = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .map(error -> error.getField() + ": " + error.getDefaultMessage())
                .collect(Collectors.toList());

        ErrorResponseDTO errorResponse = new ErrorResponseDTO("Validation failed", HttpStatus.BAD_REQUEST.value(), errors);
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(AuthenticationException.class)
    public ResponseEntity<ErrorResponseDTO> handleAuthenticationException(AuthenticationException ex) {
        log.warn("Authentication failed: {}", ex.getMessage());
        ErrorResponseDTO errorResponse = new ErrorResponseDTO("Authentication failed", HttpStatus.UNAUTHORIZED.value());
        return new ResponseEntity<>(errorResponse, HttpStatus.UNAUTHORIZED);
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ErrorResponseDTO> handleIllegalArgumentException(IllegalArgumentException ex) {
        log.warn("Illegal argument exception occurred: {}", ex.getMessage());
        ErrorResponseDTO errorResponse = new ErrorResponseDTO(ex.getMessage(), HttpStatus.BAD_REQUEST.value());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponseDTO> handleGenericException(Exception ex) {
        log.error("Unexpected error occurred: {}", ex.getMessage(), ex);
        ErrorResponseDTO errorResponse = new ErrorResponseDTO("An unexpected error occurred", HttpStatus.INTERNAL_SERVER_ERROR.value());
        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }

    @Override
    protected ResponseEntity<Object> handleHttpMessageNotReadable(
            HttpMessageNotReadableException ex,
            HttpHeaders headers,
            HttpStatusCode status,
            WebRequest request) {

        String message;
        if (ex.getCause() instanceof UnrecognizedPropertyException unrecognizedProp) {
            // Handle unknown field error
            message = String.format(
                    "Unknown field: '%s'. Allowed fields are: %s",
                    unrecognizedProp.getPropertyName(),
                    String.join(", ", GlobalExceptionUtils.getKnownProperties(new HashSet<>(unrecognizedProp.getKnownPropertyIds())))
            );
        } else if (ex.getCause() instanceof InvalidFormatException invalidFormat) {
            // Handle enum parsing errors
            if (invalidFormat.getTargetType() != null && invalidFormat.getTargetType().isEnum()) {
                try {
                    ObjectMapper objectMapper = new ObjectMapper();
                    message = String.format("Invalid value for enum field: %s",
                            objectMapper.writeValueAsString(Map.of(
                                    "field", invalidFormat.getPath().get(0).getFieldName(),
                                    "invalidValue", invalidFormat.getValue(),
                                    "allowedValues", Arrays.stream(invalidFormat.getTargetType().getEnumConstants())
                                            .map(Object::toString)
                                            .collect(Collectors.toList())
                            ))
                    );
                } catch (JsonProcessingException e) {
                    message = "Invalid request body. Please check your JSON format and field types.";
                }
            } else {
                // Handle other format errors
                message = String.format("Invalid value for field '%s': %s",
                        invalidFormat.getPath().get(0).getFieldName(),
                        invalidFormat.getValue());
            }
        } else {
            // Handle other JSON parsing errors
            message = "Invalid request body. Please check your JSON format and field types.";
        }

        ErrorResponseDTO errorResponse = new ErrorResponseDTO(
                message,
                HttpStatus.BAD_REQUEST.value()
        );

        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }


}
</file>

<file path="src/main/java/com/online/course/management/project/exception/technical/DatabaseException.java">
package com.online.course.management.project.exception.technical;

public class DatabaseException extends TechnicalException {
    public DatabaseException(String message) {
        super(message);
    }

    public DatabaseException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/exception/technical/ExternalServiceException.java">
package com.online.course.management.project.exception.technical;

public class ExternalServiceException extends TechnicalException {
    public ExternalServiceException(String message) {
        super(message);
    }

    public ExternalServiceException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/exception/technical/TechnicalException.java">
package com.online.course.management.project.exception.technical;

import com.online.course.management.project.exception.BaseException;

public class TechnicalException extends BaseException {
    public TechnicalException(String message) {
        super(message);
    }

    public TechnicalException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/filter/DebugFilter.java">
package com.online.course.management.project.filter;

import jakarta.servlet.*;
import jakarta.servlet.http.HttpServletRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;

public class DebugFilter implements Filter {

    private static final Logger logger = LoggerFactory.getLogger(DebugFilter.class);

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest httpRequest = (HttpServletRequest) servletRequest;
        logger.info("Incoming request: {} {}", httpRequest.getMethod(), httpRequest.getRequestURI());
        filterChain.doFilter(servletRequest, servletResponse);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/filter/JwtAuthenticationFilter.java">
package com.online.course.management.project.filter;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.online.course.management.project.dto.ErrorResponseDTO;
import com.online.course.management.project.security.CustomUserDetailsService;
import com.online.course.management.project.security.JwtUtil;
import io.jsonwebtoken.ExpiredJwtException;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;

@Component
@Slf4j
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    private final JwtUtil jwtUtil;
    private final CustomUserDetailsService userDetailsService;
    private final ObjectMapper objectMapper;

    @Autowired
    public JwtAuthenticationFilter(JwtUtil jwtUtil, CustomUserDetailsService userDetailsService, ObjectMapper objectMapper) {
        this.jwtUtil = jwtUtil;
        this.userDetailsService = userDetailsService;
        this.objectMapper = objectMapper;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {

        try {
            // Skip authentication for permitted paths
            if (shouldSkipAuthentication(request)) {
                filterChain.doFilter(request, response);
                return;
            }

            String jwt = getJwtFromRequest(request);

            // If no token is present, handle accordingly
            if (jwt == null) {
                handleMissingToken(response);
                return;
            }

            try {
                if (jwtUtil.validateToken(jwt)) {
                    String username = jwtUtil.extractUsername(jwt);
                    UserDetails userDetails = userDetailsService.loadUserByUsername(username);

                    UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                    authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                    SecurityContextHolder.getContext().setAuthentication(authentication);
                    filterChain.doFilter(request, response);
                }
            } catch (ExpiredJwtException e) {
                handleTokenError(response, "JWT token has expired", HttpStatus.UNAUTHORIZED);
            } catch (Exception e) {
                handleTokenError(response, "Invalid JWT token", HttpStatus.UNAUTHORIZED);
            }
        } catch (Exception e) {
            handleTokenError(response, "Authentication failed", HttpStatus.UNAUTHORIZED);
        }
    }

    private boolean shouldSkipAuthentication(HttpServletRequest request) {
        String path = request.getServletPath();
        log.info("Checking if request should be skipped: {}", path);

        // Define patterns for public endpoints
        List<String> publicEndpoints = Arrays.asList("/api/v1/users/login", "/api/v1/users/register", "/error");

        // Check exact matches first
        if (publicEndpoints.contains(path) || request.getMethod().equals("OPTIONS")) {
            return true;
        }

        // Check course-related patterns
        if (path.matches("/api/v1/courses/\\d+") ||    // Matches /courses/{id}
                path.equals("/api/v1/courses/search") || path.equals("/api/v1/courses/search-instructor") || path.equals("/api/v1/courses/search-status") || path.equals("/api/v1/courses/search-latest")) {    // Matches /courses/search
            return request.getMethod().equals("POST");   // Only allow POST requests
        }

        return false;
    }

    private String getJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }

    private void handleMissingToken(HttpServletResponse response) throws IOException {
        handleTokenError(response, "Authentication required", HttpStatus.UNAUTHORIZED);
    }

    private void handleTokenError(HttpServletResponse response, String message, HttpStatus status) throws IOException {
        response.setStatus(status.value());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding("UTF-8");

        ErrorResponseDTO errorResponse = new ErrorResponseDTO(message, status.value());

        objectMapper.writeValue(response.getOutputStream(), errorResponse);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/mapper/CategoryMapper.java">
package com.online.course.management.project.mapper;

import com.online.course.management.project.dto.CategoryDTOs;
import com.online.course.management.project.entity.Category;
import com.online.course.management.project.enums.CourseStatus;
import org.mapstruct.*;

@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE)
public interface CategoryMapper {

    @Mapping(target = "courseCount", expression = "java(countActiveCourses(category))")
    CategoryDTOs.CategoryResponseDto toDto(Category category);

    Category toEntity(CategoryDTOs.CreateCategoryDTO createCategoryRequest);

    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    void updateCategoryFromDto(CategoryDTOs.UpdateCategoryDTO updateCategoryRequest, @MappingTarget Category category);

    default Long countActiveCourses(Category category) {
        if (category.getCourses() == null) return 0L;
        return category.getCourses().stream()
                .filter(course -> course.getDeletedAt() == null
                        && course.getStatus() != CourseStatus.ARCHIVED)
                .count();
    }

}
</file>

<file path="src/main/java/com/online/course/management/project/mapper/ChapterMapper.java">
package com.online.course.management.project.mapper;

import com.online.course.management.project.dto.ChapterDTOs;
import com.online.course.management.project.dto.LessonDTOs;
import com.online.course.management.project.entity.Chapter;
import com.online.course.management.project.entity.Course;
import com.online.course.management.project.entity.Lesson;
import com.online.course.management.project.enums.CourseStatus;
import org.mapstruct.*;

import java.util.List;

@Mapper(componentModel = "spring",
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        uses = {LessonMapper.class})
public interface ChapterMapper {

    @Mapping(target = "courseId", source = "course.id")
    @Mapping(target = "courseTitle", source = "course.title")
    @Mapping(target = "totalLessons", expression = "java(getActiveLessonCount(chapter))")
    @Mapping(target = "completedLessons", expression = "java(getCompletedLessonCount(chapter))")
    @Mapping(target = "inProgressLessons", expression = "java(getInProgressLessonCount(chapter))")
    ChapterDTOs.ChapterResponseDto toDto(Chapter chapter);

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "course", ignore = true)
    @Mapping(target = "lessons", expression = "java(mapCreateLessonDTOs(dto.getLessons(), chapter))")
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "deletedAt", ignore = true)
    Chapter toEntity(ChapterDTOs.CreateChapterDTO dto);

    @Mapping(target = "courseId", source = "course.id")
    @Mapping(target = "courseTitle", source = "course.title")
    @Mapping(target = "courseStatus", source = "course.status")
    @Mapping(target = "completedLessons", expression = "java(getCompletedLessonCount(chapter))")
    @Mapping(target = "inProgressLessons", expression = "java(getInProgressLessonCount(chapter))")
    ChapterDTOs.ChapterDetailResponseDto toDetailDto(Chapter chapter);

    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "deletedAt", ignore = true)
    void updateChapterFromDto(ChapterDTOs.UpdateChapterDTO dto, @MappingTarget Chapter chapter);

    List<ChapterDTOs.ChapterResponseDto> toDtoList(List<Chapter> chapters);

    default void setCourse(Chapter chapter, Course course) {
        chapter.setCourse(course);
    }

    default Integer getActiveLessonCount(Chapter chapter) {
        if (chapter.getLessons() == null) return 0;
        return (int) chapter.getLessons().stream()
                .filter(lesson -> lesson.getDeletedAt() == null)
                .count();
    }

    default Integer getCompletedLessonCount(Chapter chapter) {
        // TODO: Implement when user progress tracking is added
        return 0;
    }

    default Integer getInProgressLessonCount(Chapter chapter) {
        // TODO: Implement when user progress tracking is added
        return 0;
    }


    @Named("mapCreateLessonDTOs")
    default List<Lesson> mapCreateLessonDTOs(List<LessonDTOs.CreateLessonDTO> lessonDtos, Chapter chapter) {
        if (lessonDtos == null) {
            return null;
        }

        return lessonDtos.stream()
                .map(dto -> {
                    Lesson lesson = new Lesson();
                    lesson.setTitle(dto.getTitle());
                    lesson.setContent(dto.getContent());
                    lesson.setOrder(dto.getOrder());
                    lesson.setType(dto.getType());
                    lesson.setStatus(CourseStatus.DRAFT);
                    lesson.setChapter(chapter);
                    return lesson;
                })
                .toList();
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/mapper/CourseMapper.java">
package com.online.course.management.project.mapper;

import com.online.course.management.project.dto.CourseDTOS;
import com.online.course.management.project.entity.Category;
import com.online.course.management.project.entity.Course;
import com.online.course.management.project.entity.User;
import org.mapstruct.*;

import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

@Mapper(componentModel = "spring",
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public interface CourseMapper {

    @Mapping(target = "instructor", source = "instructor")
    @Mapping(target = "categoryNames", expression = "java(mapCategoryNames(course))")
    CourseDTOS.CourseDetailsResponseDto toDto(Course course);

    @Mapping(target = "roles", expression = "java(mapUserRoles(user))")
    CourseDTOS.InstructorDetailsDto toInstructorDto(User user);

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "instructor", ignore = true)
    @Mapping(target = "categories", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "deletedAt", ignore = true)
    Course toEntity(CourseDTOS.CreateCourseRequestDTO dto);

    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "instructor", ignore = true)
    @Mapping(target = "categories", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "deletedAt", ignore = true)
    void updateCourseFromDto(CourseDTOS.UpdateCourseRequestDTO dto, @MappingTarget Course course);

    default Set<String> mapCategoryNames(Course course) {
        if (course.getCategories() == null) return new HashSet<>();
        return course.getCategories().stream()
                .map(Category::getName)
                .collect(Collectors.toSet());
    }

    default Set<String> mapUserRoles(User user) {
        if (user.getUserRoles() == null) return new HashSet<>();
        return user.getUserRoles().stream()
                .map(userRole -> userRole.getRole().getName().name())
                .collect(Collectors.toSet());
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/mapper/LessonMapper.java">
package com.online.course.management.project.mapper;

import com.online.course.management.project.dto.LessonDTOs;
import com.online.course.management.project.entity.Chapter;
import com.online.course.management.project.entity.Lesson;
import org.mapstruct.*;

@Mapper(componentModel = "spring",
        unmappedTargetPolicy = ReportingPolicy.IGNORE)
public interface LessonMapper {

    @Mapping(target = "chapterId", source = "chapter.id")
    @Mapping(target = "chapterTitle", source = "chapter.title")
    LessonDTOs.LessonResponseDto toDto(Lesson lesson);

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "chapter", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "deletedAt", ignore = true)
    Lesson toEntity(LessonDTOs.CreateLessonDTO dto);

    @Mapping(target = "chapterId", source = "chapter.id")
    @Mapping(target = "chapterTitle", source = "chapter.title")
    @Mapping(target = "courseId", source = "chapter.course.id")
    @Mapping(target = "courseTitle", source = "chapter.course.title")
    @Mapping(target = "completedByUsers", expression = "java(getCompletedUsersCount(lesson))")
    @Mapping(target = "inProgressByUsers", expression = "java(getInProgressUsersCount(lesson))")
    LessonDTOs.LessonDetailResponseDto toDetailDto(Lesson lesson);

    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "chapter", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "deletedAt", ignore = true)
    void updateLessonFromDto(LessonDTOs.UpdateLessonDTO dto, @MappingTarget Lesson lesson);

    default void setChapter(Lesson lesson, Chapter chapter) {
        lesson.setChapter(chapter);
    }

    // These methods would be implemented when we add user progress tracking
    default Integer getCompletedUsersCount(Lesson lesson) {
        // TODO: Implement when user progress tracking is added
        return 0;
    }

    default Integer getInProgressUsersCount(Lesson lesson) {
        // TODO: Implement when user progress tracking is added
        return 0;
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/mapper/UserMapper.java">
package com.online.course.management.project.mapper;

import com.online.course.management.project.dto.UserDTOs;
import com.online.course.management.project.entity.User;
import com.online.course.management.project.entity.UserRole;
import com.online.course.management.project.enums.UserStatus;
import org.mapstruct.*;
import org.springframework.stereotype.Component;

import java.util.Set;
import java.util.stream.Collectors;

@Mapper(componentModel = "spring", unmappedSourcePolicy = ReportingPolicy.IGNORE)
public interface UserMapper {

    @Mapping(target = "passwordHash", ignore = true)
    @Mapping(target = "userRoles", ignore = true)
    User toEntity(UserDTOs.UserRegistrationDto dto);


    UserDTOs.UserResponseDto toDto(User user);

    @Mapping(target = "roles", expression = "java(mapRoles(user.getUserRoles()))")
    UserDTOs.UserWithRolesResponseDto toUserWithRolesDto(User user);

    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    void updateUserFromDto(UserDTOs.UpdateProfileDto dto, @MappingTarget User user);

    default Set<String> mapRoles(Set<UserRole> userRoles) {
        return userRoles.stream()
                .map(userRole -> userRole.getRole().getName().name())
                .collect(Collectors.toSet());
    }


}
</file>

<file path="src/main/java/com/online/course/management/project/ProjectApplication.java">
package com.online.course.management.project;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

@SpringBootApplication
@EnableCaching
@EnableAspectJAutoProxy
public class ProjectApplication {

    public static void main(String[] args) {
        SpringApplication.run(ProjectApplication.class, args);
    }

}
</file>

<file path="src/main/java/com/online/course/management/project/repository/ICategoryRepository.java">
package com.online.course.management.project.repository;

import com.online.course.management.project.entity.Category;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.Optional;

@Repository
public interface ICategoryRepository extends JpaRepository<Category, Long>, JpaSpecificationExecutor<Category> {
    // Create & update operations
    @Override
    <S extends Category> S save(S category);

    // Read operations
    Optional<Category> findById(Long id);

    boolean existsByName(String name);

    @Query("""
            SELECT c FROM Category c 
            WHERE (:archived IS NULL 
                OR (:archived = true AND c.deletedAt IS NOT NULL)
                OR (:archived = false AND c.deletedAt IS NULL)
            )
            AND (:name IS NULL OR LOWER(c.name) LIKE LOWER(CONCAT('%', :name, '%')))
            AND (:fromDate IS NULL OR c.createdAt >= :fromDate)
            AND (:toDate IS NULL OR c.createdAt <= :toDate)
            """)
    Page<Category> searchCategories(
            @Param("name") String name,
            @Param("fromDate") LocalDateTime fromDate,
            @Param("toDate") LocalDateTime toDate,
            @Param("archived") Boolean archived,
            Pageable pageable
    );

    @Query("""
            SELECT COUNT(c) FROM Category c 
            WHERE (:archived IS NULL 
                OR (:archived = true AND c.deletedAt IS NOT NULL)
                OR (:archived = false AND c.deletedAt IS NULL)
            )
            AND (:name IS NULL OR LOWER(c.name) LIKE LOWER(CONCAT('%', :name, '%')))
            AND (:fromDate IS NULL OR c.createdAt >= :fromDate)
            AND (:toDate IS NULL OR c.createdAt <= :toDate)
            """)
    long countCategories(

            @Param("name") String name,
            @Param("fromDate") LocalDateTime fromDate,
            @Param("toDate") LocalDateTime toDate,
            @Param("archived") Boolean archived
    );

    // Delete operations (soft delete)
    @Modifying
    @Query("UPDATE Category c SET c.deletedAt = CURRENT_TIMESTAMP WHERE c.id = :id")
    void softDeleteCategory(@Param("id") Long id);

    // Restore operation
    @Modifying
    @Query("UPDATE Category c SET c.deletedAt = NULL, c.updatedAt = CURRENT_TIMESTAMP WHERE c.id = :id")
    void restoreCategory(@Param("id") Long id);

}
</file>

<file path="src/main/java/com/online/course/management/project/repository/IChapterRepository.java">
package com.online.course.management.project.repository;

import com.online.course.management.project.entity.Chapter;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.jpa.repository.query.Procedure;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface IChapterRepository extends JpaRepository<Chapter, Long>, JpaSpecificationExecutor<Chapter> {

    // Create & update operations
    @Override
    <S extends Chapter> S save(S chapter);

    // Search chapters with basic filters
    @Query(value = """
            SELECT ch.*
            FROM chapters ch
            WHERE (:title IS NULL OR LOWER(ch.title) LIKE LOWER(CONCAT('%', :title, '%')))
            AND (:status IS NULL OR ch.status = :status)
            AND (:courseId IS NULL OR ch.course_id = :courseId)
            AND (:fromDate IS NULL OR ch.created_at >= :fromDate)
            AND (:toDate IS NULL OR ch.created_at <= :toDate)
            AND ch.deleted_at IS NULL
            """,
            countQuery = """
                    SELECT COUNT(*)
                    FROM chapters ch
                    WHERE (:title IS NULL OR LOWER(ch.title) LIKE LOWER(CONCAT('%', :title, '%')))
                    AND (:status IS NULL OR ch.status = :status)
                    AND (:courseId IS NULL OR ch.course_id = :courseId)
                    AND (:fromDate IS NULL OR ch.created_at >= :fromDate)
                    AND (:toDate IS NULL OR ch.created_at <= :toDate)
                    AND ch.deleted_at IS NULL
                    """,
            nativeQuery = true)
    Page<Chapter> searchChapters(
            @Param("title") String title,
            @Param("status") String status,
            @Param("courseId") Long courseId,
            @Param("fromDate") LocalDateTime fromDate,
            @Param("toDate") LocalDateTime toDate,
            Pageable pageable
    );

    // Find all chapters by course ID
    @Query(value = """ 
            select *
            from chapters ch
            where ch.course_id = :courseId
            and ch.deleted_at is null
            order by ch.order_number
            """
            ,
            nativeQuery = true)
    List<Chapter> findAllChaptersByCourseId(@Param("courseId") Long courseId);


    // Batch soft delete chapters and their lessons
    @Modifying
    @Query(value = """
                   UPDATE chapters
                   SET\s
                       deleted_at = CURRENT_TIMESTAMP,
                       updated_at = CURRENT_TIMESTAMP,
                       status = 'ARCHIVED'
                   WHERE id IN (:chapterIds)
            """, nativeQuery = true)
    void batchSoftDeleteChapters(@Param("chapterIds") List<Long> chapterIds);

    @Modifying
    @Query(value = """
            UPDATE lessons
                    SET\s
                        deleted_at = CURRENT_TIMESTAMP,
                        updated_at = CURRENT_TIMESTAMP,
                        status = 'ARCHIVED'
                    WHERE chapter_id IN (:chapterIds)
                    AND deleted_at IS NULL
            """, nativeQuery = true)
    void batchSoftDeleteLessonsChapters(@Param("chapterIds") List<Long> chapterIds);

    // Restore soft deleted chapters and their lessons
    @Modifying
    @Query(value = """ 
            update chapters
            set deleted_at = null,
                status = 'DRAFT',
                updated_at = CURRENT_TIMESTAMP
            where id in (:chapterIds)
            and deleted_at is not null;
            """,
            nativeQuery = true)
    void batchRestoreChapters(@Param("chapterIds") List<Long> chapterIds);

    @Modifying
    @Query(value = """
            UPDATE lessons
                    SET\s
                        deleted_at = null,
                        updated_at = CURRENT_TIMESTAMP,
                        status = 'DRAFT'
                    WHERE chapter_id IN (:chapterIds)
                    AND deleted_at IS NOT NULL
            """, nativeQuery = true)
    void batchRestoreLessonsChapters(@Param("chapterIds") List<Long> chapterIds);

    // Check if chapters exist
    @Query("SELECT COUNT(c) = :expectedCount FROM Chapter c WHERE c.id IN :ids")
    boolean validateChaptersExist(@Param("ids") List<Long> ids, @Param("expectedCount") int expectedCount);

    // Validate chapter order in course
    @Query("""
            SELECT exists (
            select 1
            FROM Chapter ch
            WHERE ch.course.id = :courseId
            AND ch.order = :order
            AND ch.deletedAt IS NULL )
            """)
    boolean isOrderNumberChapterTaken(
            @Param("courseId") Long courseId,
            @Param("order") Integer order
    );

    // Call stored procedure to reorder chapters
    @Procedure(procedureName = "sp_reorder_chapters")
    void reorderChapters(@Param("p_course_id") Long courseId);
}
</file>

<file path="src/main/java/com/online/course/management/project/repository/ICourseRepository.java">
package com.online.course.management.project.repository;

import com.online.course.management.project.entity.Course;
import com.online.course.management.project.enums.CourseStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.Set;

@Repository
public interface ICourseRepository extends JpaRepository<Course, Long>, JpaSpecificationExecutor<Course> {

    // Create & update operations
    @Override
    <S extends Course> S save(S course);


    @Query(value = """
             SELECT DISTINCT
                 c.*,
                 u.id as instructor_user_id,
                 u.username as instructor_username,
                 u.email as instructor_email,
                 u.real_name as instructor_name,
                 GROUP_CONCAT(DISTINCT cat.name ORDER BY cat.name) as category_names
             FROM courses c
             LEFT JOIN users u ON c.instructor_id = u.id
             LEFT JOIN course_categories cc ON c.id = cc.course_id
             LEFT JOIN categories cat ON cc.category_id = cat.id
            WHERE c.instructor_id = :instructorId
             AND (IF(:includeArchived = true, true, c.status != 'ARCHIVED'))
             GROUP BY c.id, u.id, u.username, u.email, u.real_name
             """,
            countQuery = """
                    SELECT COUNT(DISTINCT c.id)
                    FROM courses c
                    WHERE c.instructor_id = :instructorId
                    AND (CASE\s
                        WHEN :includeArchived = true THEN true
                        ELSE c.status != 'ARCHIVED'
                    END)
                    """,
            nativeQuery = true)
    Page<Course> findByInstructorId(
            @Param("instructorId") Long instructorId,
            @Param("includeArchived") Boolean includeArchived,
            Pageable pageable
    );

    @Query(value = """
            SELECT DISTINCT c.*,
                u.username as instructor_username,
                u.email as instructor_email,
                u.real_name as instructor_name,
                GROUP_CONCAT(DISTINCT cat.name ORDER BY cat.name) as category_names
            FROM courses c
            LEFT JOIN users u ON c.instructor_id = u.id
            LEFT JOIN course_categories cc ON c.id = cc.course_id
            LEFT JOIN categories cat ON cc.category_id = cat.id
            WHERE c.id = :id 
            GROUP BY c.id, u.username, u.email, u.real_name
            HAVING c.id IS NOT NULL
            """, nativeQuery = true)
    Optional<Course> findByIdWithDetails(@Param("id") Long id);

    @Query(value = """
            SELECT DISTINCT
                c.*,
                u.username as instructor_username,
                u.email as instructor_email,
                u.real_name as instructor_name,
                GROUP_CONCAT(DISTINCT cat.name ORDER BY cat.name) as category_names
            FROM courses c
            LEFT JOIN users u ON c.instructor_id = u.id
            LEFT JOIN course_categories cc ON c.id = cc.course_id
            LEFT JOIN categories cat ON cc.category_id = cat.id
            WHERE c.status = :status
            GROUP BY c.id, u.username, u.email, u.real_name
            """,
            countQuery = """
                        SELECT COUNT(DISTINCT c.id)
                        FROM courses c
                        WHERE c.status = :status
                    """,
            nativeQuery = true)
    Page<Course> findByStatus(
            @Param("status") String status,
            Pageable pageable
    );

    @Query(value = """
            SELECT DISTINCT
                c.*,
                u.username as instructor_username,
                u.email as instructor_email,
                u.real_name as instructor_name,
                GROUP_CONCAT(DISTINCT cat.name ORDER BY cat.name) as category_names
            FROM courses c
            LEFT JOIN users u ON c.instructor_id = u.id
            LEFT JOIN course_categories cc ON c.id = cc.course_id
            LEFT JOIN categories cat ON cc.category_id = cat.id
            WHERE c.status != 'ARCHIVED'
            AND c.deleted_at IS NULL
            GROUP BY c.id, u.username, u.email, u.real_name
            ORDER BY c.created_at DESC
            LIMIT :limit
            """, nativeQuery = true)
    List<Course> findLatestCourses(@Param("limit") int limit);

    @Query(value = """
            SELECT DISTINCT
                        c.*,
                        u.username as instructor_username,
                        u.email as instructor_email,
                        u.real_name as instructor_name,
                        GROUP_CONCAT(DISTINCT cat.name ORDER BY cat.name) as category_names
                    FROM courses c
                    LEFT JOIN users u ON c.instructor_id = u.id
                    LEFT JOIN course_categories cc ON c.id = cc.course_id
                    LEFT JOIN categories cat ON cc.category_id = cat.id
                    WHERE (:title IS NULL OR LOWER(c.title) LIKE CONCAT('%', LOWER(:title), '%'))
                    AND (IF(:includeArchived = true, true, c.status != 'ARCHIVED'))
                    AND (:status IS NULL OR c.status = :status)
                    AND (:instructorName IS NULL OR LOWER(u.real_name) LIKE CONCAT('%', LOWER(:instructorName), '%'))
                    AND (:fromDate IS NULL OR c.created_at >= :fromDate)
                    AND (:toDate IS NULL OR c.created_at <= :toDate)
                    AND cc.category_id IN (:categoryIds)
                    GROUP BY\s
                        c.id,
                        u.id,
                        u.username,
                        u.email,
                        u.real_name,
                        c.status,
                        c.updated_at,
                        c.created_at
            """,
            countQuery = """
                    SELECT COUNT(c.id)
                        FROM courses c
                        JOIN course_categories cc ON c.id = cc.course_id
                        LEFT JOIN users u ON c.instructor_id = u.id
                        WHERE (:title IS NULL OR LOWER(c.title) LIKE CONCAT('%', LOWER(:title), '%'))
                        AND (IF(:includeArchived = true, true, c.status != 'ARCHIVED'))
                        AND (:status IS NULL OR c.status = :status)
                        AND (:instructorName IS NULL OR LOWER(u.real_name) LIKE CONCAT('%', LOWER(:instructorName), '%'))
                        AND (:fromDate IS NULL OR c.created_at >= :fromDate)
                        AND (:toDate IS NULL OR c.created_at <= :toDate)
                        AND cc.category_id IN (:categoryIds)
                    """,
            nativeQuery = true)
    Page<Course> searchCourses(
            @Param("title") String title,
            @Param("status") String status,
            @Param("instructorName") String instructorName,
            @Param("fromDate") LocalDateTime fromDate,
            @Param("toDate") LocalDateTime toDate,
            @Param("categoryIds") Set<Long> categoryIds,
            @Param("includeArchived") Boolean includeArchived,
            Pageable pageable
    );

    // Archive operation (special form of soft delete)
    @Modifying
    @Query(value = """
            UPDATE courses
            SET status = 'ARCHIVED',
                deleted_at = CURRENT_TIMESTAMP,
                updated_at = CURRENT_TIMESTAMP
            WHERE id = :courseId
            """, nativeQuery = true)
    void archiveCourse(@Param("courseId") Long courseId);

    @Modifying
    @Query(value = """
            UPDATE courses
            SET status = 'DRAFT',
                deleted_at = NULL,
                updated_at = CURRENT_TIMESTAMP
            WHERE id = :courseId
            AND status = 'ARCHIVED'
            """, nativeQuery = true)
    void unarchiveCourse(@Param("courseId") Long courseId);

    @Modifying
    @Query(value = """
            INSERT INTO course_categories (course_id, category_id)
            VALUES (:courseId, :categoryId)
            """, nativeQuery = true)
    void addCourseCategory(
            @Param("courseId") Long courseId,
            @Param("categoryId") Long categoryId
    );

}
</file>

<file path="src/main/java/com/online/course/management/project/repository/ILessonRepository.java">
package com.online.course.management.project.repository;

import com.online.course.management.project.entity.Lesson;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.jpa.repository.query.Procedure;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface ILessonRepository extends JpaRepository<Lesson, Long>, JpaSpecificationExecutor<Lesson> {

    @Override
    <S extends Lesson> S save(S lesson);

    // Find Lesson details by id
    @Query(value = """
            select l.*,
                   c.title  as course_title,
                   c.id     as course_id,
                   ch.title as chapter_title,
                   ch.id    as chapterId
            from lessons l
                     left join chapters ch on ch.id = l.chapter_id
                     left join courses c on c.id = ch.course_id
            where l.id = :lesson_id
            """, nativeQuery = true)
    Optional<Lesson> findLessonDetailsById(@Param("lesson_id") Long lesson_id);

    // Search lessons with filters
    @Query(value = """
            SELECT l.*,
                   c.id as courseId,
                   ch.id as chapterId
            FROM lessons l
            LEFT JOIN chapters ch ON l.chapter_id = ch.id
            LEFT JOIN courses c ON ch.course_id = c.id
            WHERE (:title IS NULL OR LOWER(l.title) LIKE LOWER(CONCAT('%', :title, '%')))
            AND (:status IS NULL OR l.status = :status)
            AND (
                :#{#courseIds.size()} = 0\s
                OR c.id IN (:courseIds)
            )
            AND (
                :#{#chapterIds.size()} = 0\s
                OR ch.id IN (:chapterIds)
            )
            AND (:type IS NULL OR l.type = :type)
            AND (:fromDate IS NULL OR l.created_at >= :fromDate)
            AND (:toDate IS NULL OR l.created_at <= :toDate)
            AND l.deleted_at IS NULL
            """,
            countQuery = """
                    SELECT COUNT(l.id)
                    FROM lessons l
                    LEFT JOIN chapters ch ON l.chapter_id = ch.id
                    LEFT JOIN courses c ON ch.course_id = c.id
                    WHERE (:title IS NULL OR LOWER(l.title) LIKE LOWER(CONCAT('%', :title, '%')))
                    AND (:status IS NULL OR l.status = :status)
                    AND (
                        :#{#courseIds.size()} = 0\s
                        OR c.id IN (:courseIds)
                    )
                    AND (
                        :#{#chapterIds.size()} = 0\s
                        OR ch.id IN (:chapterIds)
                    )
                    AND (:type IS NULL OR l.type = :type)
                    AND (:fromDate IS NULL OR l.created_at >= :fromDate)
                    AND (:toDate IS NULL OR l.created_at <= :toDate)
                    AND l.deleted_at IS NULL
                    """,
            nativeQuery = true)
    Page<Lesson> searchLessons(
            @Param("title") String title,
            @Param("status") String status,
            @Param("courseIds") List<Long> courseIds,
            @Param("chapterIds") List<Long> chapterIds,
            @Param("type") String type,
            @Param("fromDate") LocalDateTime fromDate,
            @Param("toDate") LocalDateTime toDate,
            Pageable pageable
    );

    // Remove soft deleted lessons
    @Modifying
    @Query(value = """
            update lessons
            set deleted_at = CURRENT_TIMESTAMP,
                 updated_at = CURRENT_TIMESTAMP,
                status = 'ARCHIVED'
            where id in (:lessonIds)
            and deleted_at is null;
            """,
            nativeQuery = true)
    void batchSoftDeleteLessons(@Param("lessonIds") List<Long> lessonsIds);

    // Restore soft deleted lessons
    @Modifying
    @Query(value = """         
            update lessons
            set deleted_at = null,
                 updated_at = CURRENT_TIMESTAMP,
                status = 'DRAFT'
            where id in (:lessonIds)
            and deleted_at is not null;
            """,
            nativeQuery = true)
    void batchRestoreLessons(@Param("lessonIds") List<Long> lessonsIds);

    @Query("""
            SELECT exists (
            FROM Lesson l 
            WHERE l.chapter.id = :chapterId 
            AND l.order = :order 
            AND l.deletedAt IS NULL )
            """)
    boolean isOrderNumberLessonTaken(@Param("chapterId") Long chapterId, @Param("order") Integer order);

    // Validate lessons belong to chapter
    @Query("""
            SELECT COUNT(l) = :expectedCount 
            FROM Lesson l 
            WHERE l.id IN :lessonIds 
            """)
    Boolean validateLessonsExists(
            @Param("lessonIds") List<Long> lessonIds,
            @Param("expectedCount") int expectedCount
    );

    // Call stored procedure to reorder lessons
    @Procedure(procedureName = "sp_reorder_lessons")
    void reorderLessons(@Param("p_chapter_id") Long chapterId);
}
</file>

<file path="src/main/java/com/online/course/management/project/repository/IRoleRepository.java">
package com.online.course.management.project.repository;

import com.online.course.management.project.entity.Role;
import com.online.course.management.project.enums.RoleType;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface IRoleRepository extends JpaRepository<Role, Long> {
    Optional<Role> findByName(RoleType name);
    boolean existsByName(RoleType name);
}
</file>

<file path="src/main/java/com/online/course/management/project/repository/IUserRepository.java">
package com.online.course.management.project.repository;

import com.online.course.management.project.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;


import java.util.Optional;

@Repository
public interface IUserRepository extends JpaRepository<User, Long>, JpaSpecificationExecutor<User> {
    Optional<User> findByUsername(String username);

    Optional<User> findByEmail(String email);

    Optional<User> findByUsernameOrEmail(String username, String email);

    boolean existsByUsername(String username);

    boolean existsByEmail(String email);


    @Query("SELECT u FROM User u LEFT JOIN FETCH u.userRoles WHERE u.username = :username OR u.email = :email")
    Optional<User> findByUsernameOrEmailWithRoles(@Param("username") String username, @Param("email") String email);
}
</file>

<file path="src/main/java/com/online/course/management/project/repository/IUserRoleRepository.java">
package com.online.course.management.project.repository;

import com.online.course.management.project.entity.UserRole;
import com.online.course.management.project.entity.UserRoleId;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface IUserRoleRepository extends JpaRepository<UserRole, UserRoleId> {
    List<UserRole> findByUserId(Long userId);

    List<UserRole> findByRoleId(Long roleId);
}
</file>

<file path="src/main/java/com/online/course/management/project/security/CustomAccessDeniedHandler.java">
package com.online.course.management.project.security;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.online.course.management.project.dto.ErrorResponseDTO;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.stereotype.Component;

import java.io.IOException;

@Component
public class CustomAccessDeniedHandler implements AccessDeniedHandler {

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response,
                       AccessDeniedException accessDeniedException) throws IOException {
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setStatus(HttpStatus.FORBIDDEN.value());

        ErrorResponseDTO errorResponse = new ErrorResponseDTO(
                "Access denied: You don't have permission to access this resource",
                HttpStatus.FORBIDDEN.value()
        );

        objectMapper.writeValue(response.getOutputStream(), errorResponse);
    }

}
</file>

<file path="src/main/java/com/online/course/management/project/security/CustomUserDetails.java">
package com.online.course.management.project.security;

import com.online.course.management.project.entity.User;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.stream.Collectors;

public class CustomUserDetails implements UserDetails {

    private final User user;

    public CustomUserDetails(User user) {
        this.user = user;
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return user.getUserRoles().stream()
                .map(userRole -> new SimpleGrantedAuthority("ROLE_" + userRole.getRole().getName().name()))
                .collect(Collectors.toSet());
    }

    @Override
    public String getPassword() {
        return user.getPasswordHash();
    }

    @Override
    public String getUsername() {
        return user.getUsername();
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return user.getDeletedAt() == null;
    }

    public Long getId() {
        return user.getId();
    }

    public String getEmail() {
        return user.getEmail();
    }

    public String getRealName() {
        return user.getRealName();
    }


    public User getUser() {
        return user;
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/security/CustomUserDetailsService.java">
package com.online.course.management.project.security;

import com.online.course.management.project.entity.User;
import com.online.course.management.project.repository.IUserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class CustomUserDetailsService implements UserDetailsService {

    private final IUserRepository userRepository;

    @Autowired
    public CustomUserDetailsService(IUserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    @Transactional(readOnly = true)
    public UserDetails loadUserByUsername(String usernameOrEmail) throws UsernameNotFoundException {
        User user = userRepository.findByUsernameOrEmailWithRoles(usernameOrEmail, usernameOrEmail)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with username or email: " + usernameOrEmail));

        return new CustomUserDetails(user);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/security/JwtAuthenticationEntryPoint.java">
package com.online.course.management.project.security;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.online.course.management.project.dto.ErrorResponseDTO;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;

@Component
public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    private final ObjectMapper objectMapper;

    @Autowired
    public JwtAuthenticationEntryPoint(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
    }

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) throws IOException {

        response.setStatus(HttpStatus.UNAUTHORIZED.value());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);

        String message;
        if (request.getAttribute("expired") != null) {
            message = "JWT token has expired";
        } else if (request.getAttribute("invalid") != null) {
            message = "Invalid JWT token";
        } else if (authException != null && authException.getMessage() != null) {
            message = authException.getMessage();
        } else {
            message = "Authentication required: Please provide a valid JWT token";
        }

        ErrorResponseDTO errorResponse = new ErrorResponseDTO(
                message,
                HttpStatus.UNAUTHORIZED.value()
        );

        objectMapper.writeValue(response.getOutputStream(), errorResponse);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/security/JwtUtil.java">
package com.online.course.management.project.security;

import io.jsonwebtoken.*;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

@Component
public class JwtUtil {

    @Value("${jwt.secret}")
    private String secret;

    @Value("${jwt.expiration}")
    private Long expiration;

    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    private Claims extractAllClaims(String token) {
        return Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody();
    }

    public Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    public String generateToken(UserDetails userDetails) {
        Map<String, Object> claims = new HashMap<>();
        return createToken(claims, userDetails.getUsername());
    }

    private String createToken(Map<String, Object> claims, String subject) {
        return Jwts.builder().setClaims(claims).setSubject(subject).setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(new Date(System.currentTimeMillis() + expiration * 1000))
                .signWith(SignatureAlgorithm.HS256, secret).compact();
    }

    // New method to validate token without UserDetails
    public Boolean validateToken(String token) {
        Jwts.parser().setSigningKey(secret).parseClaimsJws(token);
        return !isTokenExpired(token);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/security/RequiredRole.java">
package com.online.course.management.project.security;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RequiredRole {
    String[] value();
}
</file>

<file path="src/main/java/com/online/course/management/project/security/UserSecurity.java">
package com.online.course.management.project.security;

import com.online.course.management.project.entity.User;
import com.online.course.management.project.repository.IUserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;

@Component("userSecurity")
public class UserSecurity {
    private final IUserRepository userRepository;

    @Autowired
    public UserSecurity(IUserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public boolean isUserOwner(Authentication authentication, Long userId) {
        String username = authentication.getName();
        User user = userRepository.findByUsername(username).orElse(null);
        return user != null && user.getId().equals(userId);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/service/impl/CategoryServiceImpl.java">
package com.online.course.management.project.service.impl;

import com.online.course.management.project.dto.CategoryDTOs;
import com.online.course.management.project.entity.Category;
import com.online.course.management.project.exception.business.ForbiddenException;
import com.online.course.management.project.mapper.CategoryMapper;
import com.online.course.management.project.repository.ICategoryRepository;
import com.online.course.management.project.service.interfaces.ICategoryService;
import com.online.course.management.project.utils.category.CategoryServiceUtils;
import jakarta.transaction.Transactional;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.util.stream.Collectors;

@Service
@Slf4j
public class CategoryServiceImpl implements ICategoryService {

    private final ICategoryRepository categoryRepository;
    private final CategoryMapper categoryMapper;
    private final CategoryServiceUtils categoryServiceUtils;

    @Autowired
    public CategoryServiceImpl(ICategoryRepository categoryRepository, CategoryMapper categoryMapper, CategoryServiceUtils categoryServiceUtils) {
        this.categoryRepository = categoryRepository;
        this.categoryMapper = categoryMapper;
        this.categoryServiceUtils = categoryServiceUtils;
    }

    @Override
    @Transactional
    public CategoryDTOs.CategoryResponseDto createCategory(CategoryDTOs.CreateCategoryDTO request) {
        log.info("Creating new category with name: {}", request.getName());

        if (isCategoryNameExist(request.getName())) {
            throw new IllegalArgumentException("Category with name already exists");
        }

        if (request.getName() == null || request.getName().isEmpty()) {
            throw new IllegalArgumentException("Category name cannot be empty");
        }

        Category category = categoryMapper.toEntity(request);
        Category savedCategory = categoryRepository.save(category);

        return categoryMapper.toDto(savedCategory);
    }

    @Override
    @Transactional
    public CategoryDTOs.CategoryResponseDto updateCategory(Long id, CategoryDTOs.UpdateCategoryDTO request) {
        log.info("Updating category with id: {}", id);


        if (isCategoryNameExist(request.getName())) {
            throw new IllegalArgumentException("Category with name already exists");
        }

        Category category = categoryServiceUtils.getCategoryOrThrow(id);

        categoryMapper.updateCategoryFromDto(request, category);

        Category updatedCategory = categoryRepository.save(category);

        return categoryMapper.toDto(updatedCategory);
    }

    @Override
    @Transactional
    @CacheEvict(value = "categories", key = "#id")
    public void deleteCategory(Long id) {
        log.info("Soft deleting category with id: {}", id);

        Category category = categoryServiceUtils.getCategoryOrThrow(id);

        if (category.getDeletedAt() != null) {
            throw new ForbiddenException("Cannot delete archived category");
        }

        categoryRepository.softDeleteCategory(id);
    }

    @Override
    @Cacheable(value = "categories", key = "#id")
    public CategoryDTOs.CategoryResponseDto getCategoryById(Long id) {
        log.info("Fetching category with id: {}", id);

        return categoryMapper.toDto(categoryServiceUtils.getCategoryOrThrow(id));
    }

    @Override
    public boolean isCategoryNameExist(String categoryName) {
        return categoryRepository.existsByName(categoryName);
    }


    @Override
    public Page<CategoryDTOs.CategoryResponseDto> searchCategories(CategoryDTOs.CategorySearchDTO request, Pageable pageable) {
        log.info("Searching categories with criteria: {}", request);

        Page<Category> categories = categoryRepository.searchCategories(
                request.getName(),
                request.getFromDate(),
                request.getToDate(),
                request.getArchived(),
                pageable
        );

        long totalCount = categoryRepository.countCategories(
                request.getName(),
                request.getFromDate(),
                request.getToDate(),
                request.getArchived()
        );

        return new PageImpl<>(
                categories.getContent().stream()
                        .map(categoryMapper::toDto)
                        .collect(Collectors.toList()),
                pageable,
                totalCount
        );
    }

    @Override
    @Transactional
    @CacheEvict(value = "categories", key = "#id")
    public void restoreCategory(Long id) {
        log.info("Restoring category with id: {}", id);

        Category category = categoryServiceUtils.getCategoryOrThrow(id);

        if (category.getDeletedAt() == null) {
            throw new IllegalArgumentException("Category is not soft deleted");
        }

        categoryRepository.restoreCategory(id);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/service/impl/ChapterServiceImpl.java">
package com.online.course.management.project.service.impl;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.online.course.management.project.dto.ChapterDTOs;
import com.online.course.management.project.entity.Chapter;
import com.online.course.management.project.entity.Course;
import com.online.course.management.project.entity.Lesson;
import com.online.course.management.project.enums.CourseStatus;
import com.online.course.management.project.exception.business.InvalidRequestException;
import com.online.course.management.project.mapper.ChapterMapper;
import com.online.course.management.project.repository.IChapterRepository;
import com.online.course.management.project.service.interfaces.IChapterService;
import com.online.course.management.project.utils.chapter.ChapterServiceUtils;
import com.online.course.management.project.utils.course.CourseServiceUtils;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

@Service
@Slf4j
public class ChapterServiceImpl implements IChapterService {

    private final IChapterRepository chapterRepository;
    private final ChapterMapper chapterMapper;
    private final ChapterServiceUtils chapterServiceUtils;
    private final CourseServiceUtils courseServiceUtils;

    @Autowired
    public ChapterServiceImpl
            (IChapterRepository chapterRepository,
             ChapterMapper chapterMapper,
             ChapterServiceUtils chapterServiceUtils,
             CourseServiceUtils courseServiceUtils) {
        this.chapterRepository = chapterRepository;
        this.chapterMapper = chapterMapper;
        this.chapterServiceUtils = chapterServiceUtils;
        this.courseServiceUtils = courseServiceUtils;
    }

    @Override
    @Transactional
    public ChapterDTOs.ChapterDetailResponseDto createChapter(ChapterDTOs.CreateChapterDTO request) {
        log.info("Creating new chapter for course ID: {}", request.getCourseId());

        // Get and validate course
        Course course = courseServiceUtils.getCourseWithValidation(request.getCourseId());

        // Validate order number
        validateChapterOrder(course.getId(), request.getOrder());

        // Create and save chapter first
        Chapter chapter = chapterServiceUtils.createChapterWithLessons(request, course);
        chapter.setCourse(course);
        chapter.setStatus(CourseStatus.DRAFT);

        // Handle lessons if provided
        if (request.getLessons() != null && !request.getLessons().isEmpty()) {
            chapterServiceUtils.validateBulkLessonsOrders(chapter.getId(), chapter.getLessons());
        }

        Chapter savedChapter = chapterRepository.save(chapter);

        return chapterMapper.toDetailDto(savedChapter);
    }

    @Override
    @Transactional
    public List<ChapterDTOs.ChapterDetailResponseDto> bulkCreateChapters(ChapterDTOs.BulkCreateChapterDTO request) {
        log.info("Bulk creating chapters for course ID: {}", request.getChapters().get(0).getCourseId());

        // Validate request
        chapterServiceUtils.validateBulkCreateRequest(request);

        // Get and validate course
        Course course = courseServiceUtils.getCourseWithValidation(request.getChapters().get(0).getCourseId());

        // Validate all chapter orders
        chapterServiceUtils.validateBulkChapterOrders(course.getId(), request.getChapters());

        // Create and save chapters with their lessons
        List<Chapter> chapters = new ArrayList<>();
        for (ChapterDTOs.CreateChapterDTO chapterDto : request.getChapters()) {
            Chapter chapter = chapterServiceUtils.createChapterWithLessons(chapterDto, course);
            chapters.add(chapter);
        }

        // Save all chapters
        List<Chapter> savedChapters = chapterRepository.saveAll(chapters);

        log.info("Successfully created {} chapters with their lessons", savedChapters.size());

        // Map to response DTOs
        return savedChapters.stream().map(chapterMapper::toDetailDto).collect(Collectors.toList());
    }


    @Override
    @Transactional
    public ChapterDTOs.ChapterDetailResponseDto updateChapter(Long id, ChapterDTOs.UpdateChapterDTO request) {
        log.info("Updating chapter with ID: {}", id);

        // Get chapter details and validate access
        Chapter chapter = chapterServiceUtils.getChapterOrThrow(id);
        chapterServiceUtils.validateChapterAccess(chapter);

        updateBasicFields(chapter, request);

        if (request.getStatus() != null) {
            handleStatusChange(chapter, request.getStatus());
        }

        Chapter savedChapter = chapterRepository.save(chapter);
        return chapterMapper.toDetailDto(savedChapter);
    }

    private void updateBasicFields(Chapter chapter, ChapterDTOs.UpdateChapterDTO request) {
        if (request.getTitle() != null) {
            chapter.setTitle(request.getTitle());
        }
        if (request.getDescription() != null) {
            chapter.setDescription(request.getDescription());
        }
        if (request.getOrder() != null) {
            validateChapterOrder(chapter.getCourse().getId(), request.getOrder());
            chapter.setOrder(request.getOrder());
        }
    }

    @Transactional
    protected void handleStatusChange(Chapter chapter, CourseStatus newStatus) {
        try {
            chapterServiceUtils.validateChapterStatus(chapter.getStatus(), newStatus);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }

        LocalDateTime now = LocalDateTime.now();

        // Handle archival case
        if (newStatus == CourseStatus.ARCHIVED && chapter.getStatus() != CourseStatus.ARCHIVED) {
            // Set the chapter status and dates
            chapter.setStatus(newStatus);
            chapter.setDeletedAt(now);
            chapter.setUpdatedAt(now);

            // Update lessons status
            if (chapter.getLessons() != null) {
                for (Lesson lesson : chapter.getLessons()) {
                    lesson.setStatus(CourseStatus.ARCHIVED);
                    lesson.setDeletedAt(now);
                    lesson.setUpdatedAt(now);
                }
            }
        }

        // Handle restoration case
        else if (newStatus != CourseStatus.ARCHIVED && chapter.getStatus() == CourseStatus.ARCHIVED) {
            // Set the chapter status and dates
            chapter.setStatus(newStatus);
            chapter.setDeletedAt(null);
            chapter.setUpdatedAt(now);

            // Update lessons status
            if (chapter.getLessons() != null) {
                for (Lesson lesson : chapter.getLessons()) {
                    lesson.setStatus(CourseStatus.DRAFT);
                    lesson.setDeletedAt(null);
                    lesson.setUpdatedAt(now);
                }
            }
        }
        // Handle other status changes
        else {
            chapter.setStatus(newStatus);
            chapter.setUpdatedAt(now);
        }
    }

    @Override
    @Transactional
    public List<ChapterDTOs.ChapterResponseDto> bulkUpdateChapters
            (List<Long> ids, List<ChapterDTOs.UpdateChapterDTO> chapters) {
        log.info("Bulk updating {} chapters", ids.size());

        if (chapters.size() != ids.size()) {
            throw new InvalidRequestException("Number of chapter IDs and update requests must match");
        }

        chapterServiceUtils.validateBulkOperation(ids);

        List<Chapter> updatedChapters = new ArrayList<>();
        for (int i = 0; i < ids.size(); i++) {
            Chapter chapter = chapterServiceUtils.getChapterOrThrow(ids.get(i));
            chapterServiceUtils.validateChapterAccess(chapter);

            ChapterDTOs.UpdateChapterDTO updateDto = chapters.get(i);


            // Validate status if provided
            if (updateDto.getStatus() != null) {
                handleStatusChange(chapter, updateDto.getStatus());
            }

            updateBasicFields(chapter, updateDto);
            updatedChapters.add(chapter);
        }

        // Build CASE statements
        List<Chapter> savedChapters = chapterRepository.saveAll(updatedChapters);

        log.info("Successfully updated {} chapters", chapters.size());
        return savedChapters.stream().map(chapterMapper::toDto).collect(Collectors.toList());
    }

    @Override
    @Transactional
    public void deleteChapter(Long id) {
        log.info("Soft deleting chapter with ID: {}", id);

        Chapter chapter = chapterServiceUtils.getChapterOrThrow(id);
        chapterServiceUtils.validateChapterAccess(chapter);

        if (chapter.getDeletedAt() != null) {
            throw new InvalidRequestException("Chapter is already deleted");
        }

        chapterRepository.batchSoftDeleteChapters(List.of(id));
        chapterRepository.batchSoftDeleteLessonsChapters(List.of(id));

        log.info("Chapter soft deleted successfully");
    }

    @Override
    @Transactional
    public void bulkDeleteChapters(List<Long> ids) {
        log.info("Bulk deleting {} chapters", ids.size());

        chapterServiceUtils.validateBulkOperation(ids);

        List<Chapter> chapters = chapterRepository.findAllById(ids);

        for (Chapter chapter : chapters) {
            chapterServiceUtils.validateChapterAccess(chapter);
        }

        chapterRepository.batchSoftDeleteChapters(ids);
        chapterRepository.batchSoftDeleteLessonsChapters(ids);

        log.info("Successfully deleted {} chapters", ids.size());
    }

    @Override
    @Transactional
    public void restoreChapter(Long id) {
        log.info("Restoring chapter with ID: {}", id);

        Chapter chapter = chapterServiceUtils.getChapterOrThrow(id);
        chapterServiceUtils.validateChapterAccess(chapter);

        if (chapter.getDeletedAt() == null) {
            throw new InvalidRequestException("Chapter is not deleted");
        }

        chapterRepository.batchRestoreChapters(List.of(id));
        chapterRepository.batchRestoreLessonsChapters(List.of(id));

        log.info("Chapter restored successfully");
    }

    @Override
    @Transactional
    public void bulkRestoreChapters(List<Long> ids) {
        log.info("Bulk restoring {} chapters", ids.size());

        chapterServiceUtils.validateBulkOperation(ids);

        List<Chapter> chapters = chapterRepository.findAllById(ids);

        for (Chapter chapter : chapters) {
            chapterServiceUtils.validateChapterAccess(chapter);
        }

        chapterRepository.batchRestoreChapters(ids);
        chapterRepository.batchRestoreLessonsChapters(ids);

        log.info("Successfully restored {} chapters", ids.size());
    }

    @Override
    @Cacheable(value = "chapters", key = "#id")
    public ChapterDTOs.ChapterResponseDto getChapterById(Long id) {
        log.info("Fetching chapter with ID: {}", id);
        return chapterMapper.toDto(chapterServiceUtils.getChapterOrThrow(id));
    }

    @Override
    @Cacheable(value = "chapters", key = "'detail-' + #id")
    public ChapterDTOs.ChapterDetailResponseDto getChapterWithLessons(Long id) {
        log.info("Fetching chapter details with lessons for ID: {}", id);
        return chapterMapper.toDetailDto(chapterServiceUtils.getChapterOrThrow(id));
    }

    @Override
    public List<ChapterDTOs.ChapterResponseDto> getAllChaptersByCourseId(Long courseId) {
        log.info("Fetching all chapters for course ID: {}", courseId);

        courseServiceUtils.GetCourseWithoutValidation(courseId);

        List<Chapter> chapters = chapterRepository.findAllChaptersByCourseId(courseId);
        return chapters.stream().map(chapterMapper::toDto).collect(Collectors.toList());
    }

    @Override
    public Page<ChapterDTOs.ChapterResponseDto> searchChapters(ChapterDTOs.ChapterSearchDTO request, Pageable
            pageable) {
        log.info("Searching chapters with criteria: {}", request);

        // Validate and create sort if provided

        if (request.getSort() != null) {
            chapterServiceUtils.validateSortFields(request.getSort());
        }
        pageable = PageRequest.of(pageable.getPageNumber(), pageable.getPageSize(), chapterServiceUtils.createChapterSort(request.getSort()));

        log.info(pageable.toString());

        Page<Chapter> chaptersPage = chapterRepository.searchChapters(request.getTitle(), request.getStatus() != null ? request.getStatus().name() : null, request.getCourseId(), request.getFromDate(), request.getToDate(), pageable);

        List<ChapterDTOs.ChapterResponseDto> chapterDtos = chaptersPage.getContent().stream().map(chapterMapper::toDto).collect(Collectors.toList());

        return new PageImpl<>(chapterDtos, pageable, chaptersPage.getTotalElements());
    }

    @Override
    @Transactional
    public void reorderChapters(Long courseId) {
        log.info("Reordering chapters for course ID: {}", courseId);
        courseServiceUtils.getCourseWithValidation(courseId);

        // Update order numbers
        chapterRepository.reorderChapters(courseId);

        log.info("Chapters reordered successfully");
    }

    private void validateChapterOrder(Long courseId, Integer order) {
        var takenChapterOrder = chapterServiceUtils.validateChapterOrder(courseId, order);
        if (takenChapterOrder != null) {
            throw new InvalidRequestException(takenChapterOrder);
        }
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/service/impl/CourseServiceImpl.java">
package com.online.course.management.project.service.impl;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.online.course.management.project.dto.CourseDTOS;
import com.online.course.management.project.entity.Category;
import com.online.course.management.project.entity.Course;
import com.online.course.management.project.entity.User;
import com.online.course.management.project.enums.CourseStatus;
import com.online.course.management.project.exception.business.InvalidRequestException;
import com.online.course.management.project.exception.business.ResourceNotFoundException;
import com.online.course.management.project.mapper.CourseMapper;
import com.online.course.management.project.repository.ICourseRepository;
import com.online.course.management.project.repository.IUserRepository;
import com.online.course.management.project.service.interfaces.ICourseService;
import com.online.course.management.project.utils.course.CourseServiceUtils;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

@Service
@Slf4j
public class CourseServiceImpl implements ICourseService {

    private final ICourseRepository courseRepository;
    private final IUserRepository userRepository;
    private final CourseMapper courseMapper;
    private final CourseServiceUtils courseServiceUtils;


    @Autowired
    public CourseServiceImpl(
            ICourseRepository courseRepository,
            IUserRepository userRepository,
            CourseMapper courseMapper,
            CourseServiceUtils courseServiceUtils) {
        this.courseRepository = courseRepository;
        this.userRepository = userRepository;
        this.courseMapper = courseMapper;
        this.courseServiceUtils = courseServiceUtils;
    }

    @Override
    @Transactional
    @CacheEvict(value = "courses", allEntries = true)
    public CourseDTOS.CourseDetailsResponseDto createCourse(CourseDTOS.CreateCourseRequestDTO request) {
        log.info("Creating new course with title: {}", request.getTitle());

        Course course = courseMapper.toEntity(request);

        if (request.getInstructorId() != null) {
            User instructor = courseServiceUtils.determineInstructor(request.getInstructorId());
            course.setInstructor(instructor);
        }

        // Important: Initialize the categories set if null
        if (course.getCategories() == null) {
            course.setCategories(new HashSet<>());
        }

        if (request.getCategoryIds() != null && !request.getCategoryIds().isEmpty()) {
            Set<Category> categories = courseServiceUtils.validateCategories(request.getCategoryIds());
            for (Category category : categories) {
                course.addCategory(category);
            }
        }

        Course savedCourse = courseRepository.save(course);
        return courseMapper.toDto(savedCourse);
    }

    @Override
    @Transactional
    @CacheEvict(value = "courses", key = "#id")
    public CourseDTOS.CourseDetailsResponseDto updateCourse(Long id, CourseDTOS.UpdateCourseRequestDTO request) {
        log.info("Updating course with id: {}", id);

        Course course = courseServiceUtils.getCourseWithValidation(id);

        if (request.getInstructorId() != null) {
            User newInstructor = courseServiceUtils.determineInstructor(request.getInstructorId());
            course.setInstructor(newInstructor);
        }

        // If status is being updated, validate the transition
        if (request.getStatus() != null) {
            try {
                courseServiceUtils.validateCourseStatus(course.getStatus(), request.getStatus());
            } catch (JsonProcessingException e) {
                throw new InvalidRequestException("Error processing status validation");
            }

            // Handle archived status and deletedAt
            if (request.getStatus() == CourseStatus.ARCHIVED) {
                course.setDeletedAt(LocalDateTime.now());
            } else if (course.getStatus() == CourseStatus.ARCHIVED) {
                // If transitioning from ARCHIVED to another status, clear deletedAt
                course.setDeletedAt(null);
            }
        }

        courseMapper.updateCourseFromDto(request, course);

        if (request.getCategoryIds() != null && !request.getCategoryIds().isEmpty()) {
            courseServiceUtils.updateCourseCategories(course, request.getCategoryIds());
        }

        Course updatedCourse = courseRepository.save(course);
        return courseMapper.toDto(updatedCourse);
    }

    @Override
    @Transactional
    @CacheEvict(value = "courses", key = "#id")
    public void archiveCourse(Long id) {
        log.info("Archiving course with id: {}", id);
        courseServiceUtils.getCourseWithValidation(id);
        courseRepository.archiveCourse(id);
    }

    @Override
    @Transactional
    @CacheEvict(value = "courses", key = "#id")
    public void unarchiveCourse(Long id) {
        log.info("Unarchiving course with id: {}", id);
        courseServiceUtils.getCourseWithValidation(id);
        courseRepository.unarchiveCourse(id);
    }

    @Override
    @Transactional(readOnly = true)
    @Cacheable(value = "courses", key = "#id")
    public CourseDTOS.CourseDetailsResponseDto getCourseById(Long id) {
        log.info("Fetching course with id: {}", id);
        Course course = courseServiceUtils.GetCourseWithoutValidation(id);
        return courseMapper.toDto(course);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<CourseDTOS.CourseDetailsResponseDto> searchCourses(
            CourseDTOS.SearchCourseRequestDTO request,
            Pageable pageable) {
        log.info("Searching courses with criteria: {}", request);

        // Validate and create sort if provided in request
        if (request.getSort() != null && !request.getSort().isEmpty()) {
            courseServiceUtils.validateSortFields(request.getSort());
            pageable = PageRequest.of(
                    pageable.getPageNumber(),
                    pageable.getPageSize(),
                    courseServiceUtils.createSort(request.getSort())
            );
        } else {
            // Use default sort if none provided
            pageable = PageRequest.of(
                    pageable.getPageNumber(),
                    pageable.getPageSize(),
                    courseServiceUtils.handleCreateDefaultSort()
            );
        }

        return courseRepository.searchCourses(
                request.getTitle(),
                request.getStatus() != null ? request.getStatus().name() : null,
                request.getInstructorName(),
                request.getFromDate(),
                request.getToDate(),
                request.getCategoryIds(),
                request.getIncludeArchived(),
                pageable
        ).map(courseMapper::toDto);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<CourseDTOS.CourseDetailsResponseDto> getCoursesByInstructor(
            Long instructorId,
            boolean includeArchived,
            Pageable pageable) {
        log.info("Fetching courses for instructor: {}, includeArchived: {}",
                instructorId, includeArchived);

        if (!userRepository.existsById(instructorId)) {
            throw new ResourceNotFoundException("Instructor not found");
        }

        pageable = PageRequest.of(
                pageable.getPageNumber(),
                pageable.getPageSize(),
                courseServiceUtils.handleCreateDefaultSort()
        );

        return courseRepository.findByInstructorId(instructorId, includeArchived, pageable)
                .map(courseMapper::toDto);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<CourseDTOS.CourseDetailsResponseDto> getCoursesByStatus(
            CourseStatus status,
            Pageable pageable) {
        log.info("Fetching courses with status: {}", status);

        // Use default sort if none provided

        pageable = PageRequest.of(
                pageable.getPageNumber(),
                pageable.getPageSize(),
                courseServiceUtils.handleCreateDefaultSort()
        );

        return courseRepository.findByStatus(status.name(), pageable)
                .map(courseMapper::toDto);
    }

    @Override
    @Transactional(readOnly = true)
    @Cacheable(value = "latestCourses", key = "#limit")
    public List<CourseDTOS.CourseDetailsResponseDto> getLatestCourses(int limit) {
        log.info("Fetching latest {} courses", limit);
        return courseRepository.findLatestCourses(limit)
                .stream()
                .map(courseMapper::toDto)
                .collect(Collectors.toList());
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/service/impl/LessonServiceImpl.java">
package com.online.course.management.project.service.impl;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.online.course.management.project.dto.LessonDTOs;
import com.online.course.management.project.entity.Chapter;
import com.online.course.management.project.entity.Lesson;
import com.online.course.management.project.enums.CourseStatus;
import com.online.course.management.project.exception.business.InvalidRequestException;
import com.online.course.management.project.mapper.LessonMapper;
import com.online.course.management.project.repository.ILessonRepository;
import com.online.course.management.project.service.interfaces.ILessonService;
import com.online.course.management.project.utils.chapter.ChapterServiceUtils;
import com.online.course.management.project.utils.lesson.LessonServiceUtils;
import jakarta.transaction.Transactional;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;

@Service
@Slf4j
public class LessonServiceImpl implements ILessonService {

    private final ILessonRepository lessonRepository;
    private final LessonMapper lessonMapper;
    private final LessonServiceUtils lessonServiceUtils;
    private final ChapterServiceUtils chapterServiceUtils;

    @Autowired
    public LessonServiceImpl(ILessonRepository lessonRepository, LessonMapper lessonMapper, LessonServiceUtils lessonServiceUtils, ChapterServiceUtils chapterServiceUtils) {
        this.lessonRepository = lessonRepository;
        this.lessonMapper = lessonMapper;
        this.lessonServiceUtils = lessonServiceUtils;
        this.chapterServiceUtils = chapterServiceUtils;
    }


    @Override
    @Transactional
    public LessonDTOs.LessonResponseDto createLesson(LessonDTOs.CreateLessonDTOWithChapterId request) {

        // Check if chapter exists
        Chapter chapter = chapterServiceUtils.getChapterOrThrow(request.getChapterId());

        // Check chapter's accessibility
        chapterServiceUtils.validateChapterAccess(chapter);

        // Check order of lesson
        var takenLessonOrder = lessonServiceUtils.hasLessonOrderTakenSingle(chapter.getId(), request.getOrder());

        if (takenLessonOrder != null) {
            throw new InvalidRequestException(
                    takenLessonOrder
            );
        }

        Lesson lessonToCreate = lessonMapper.toEntity(request);

        lessonToCreate.setChapter(chapter);

        Lesson savedLesson = lessonRepository.save(lessonToCreate);
        return lessonMapper.toDto(savedLesson);
    }

    @Override
    @Transactional
    public List<LessonDTOs.LessonResponseDto> bulkCreateLessons(LessonDTOs.BulkCreateLessonDTO request) {

        // Check if chapter exists
        Chapter chapter = chapterServiceUtils.getChapterOrThrow(request.getChapterId());

        // Check chapter's accessibility
        chapterServiceUtils.validateChapterAccess(chapter);

        List<LessonDTOs.CreateLessonDTO> listLessonsPayload = request.getLessons();

        List<Lesson> lessons = listLessonsPayload.stream().map(lessonMapper::toEntity).toList();

        List<String> takenLessonOrders = lessonServiceUtils.hasLessonOrderTakenMultiple(request.getChapterId(), lessons);

        // Check order of lessons
        if (!takenLessonOrders.isEmpty()) {
            throw new InvalidRequestException(
                    String.format("One or more lesson orders have been taken in this chapter: %s",
                            String.join(", ", takenLessonOrders)
                    )
            );
        }

        // Check if lessons list contains duplicates
        if (lessonServiceUtils.IsListOrdersContainsDuplicates(lessons.stream().map(Lesson::getOrder).toList())) {
            throw new InvalidRequestException("Duplicate lesson order found");
        }

        chapter.setLessons(lessons);

        List<Lesson> savedLessons = lessonRepository.saveAll(lessons);

        return savedLessons.stream().map(lessonMapper::toDto).toList();
    }

    @Override
    @Transactional
    public LessonDTOs.LessonResponseDto updateLesson(Long id, LessonDTOs.UpdateLessonDTO request) {

        Lesson lessonToUpdate = lessonServiceUtils.GetLessonOrThrow(id);

        // Validate accessibility
        chapterServiceUtils.validateChapterAccess(lessonToUpdate.getChapter());

        // Validate order
        if (request.getOrder() != null) {
            var takenLessonOrder = lessonServiceUtils.hasLessonOrderTakenSingle(lessonToUpdate.getChapter().getId(), request.getOrder());

            if (takenLessonOrder != null) {
                throw new InvalidRequestException(
                        takenLessonOrder
                );
            }
        }

        // Validate status
        if (request.getStatus() != null) {
            try {
                lessonServiceUtils.validateLessonStatus(lessonToUpdate.getStatus(), request.getStatus());
            } catch (JsonProcessingException e) {
                throw new RuntimeException(e);
            }

            if (request.getStatus() == CourseStatus.ARCHIVED) {
                lessonToUpdate.setDeletedAt(LocalDateTime.now());
            } else {
                lessonToUpdate.setDeletedAt(null);
            }
        }

        lessonMapper.updateLessonFromDto(request, lessonToUpdate);

        Lesson savedLesson = lessonRepository.save(lessonToUpdate);
        return lessonMapper.toDto(savedLesson);
    }

    @Override
    @Transactional
    public List<LessonDTOs.LessonResponseDto> bulkUpdateLessons(LessonDTOs.BulkUpdateLessonDTO request) {

        if (request.getLessonIds().size() != request.getLessons().size()) {
            throw new InvalidRequestException("Number of lesson IDs and update requests must match");
        }

        // Validate number of allowed lessons per request
        lessonServiceUtils.validateBulkOperation(request.getLessonIds());

        List<LessonDTOs.UpdateLessonDTO> listLessonsPayload = request.getLessons();
        List<Lesson> lessonsToUpdate = lessonRepository.findAllById(request.getLessonIds());

        // Validate accessibility
        lessonsToUpdate.forEach(lesson -> chapterServiceUtils.validateChapterAccess(lesson.getChapter()));

        // Validate order
        List<Integer> payloadOrders = request.getLessons().stream().map(LessonDTOs.UpdateLessonDTO::getOrder).filter(Objects::nonNull).toList();

        if (!payloadOrders.isEmpty() && lessonServiceUtils.IsListOrdersContainsDuplicates(payloadOrders)) {
            throw new InvalidRequestException("Duplicate lesson order found");
        }

        List<String> takenLessonOrders = new ArrayList<>();
        for (Integer order : payloadOrders) {
            var takenLessonOrder = lessonServiceUtils.hasLessonOrderTakenSingle(lessonsToUpdate.get(0).getChapter().getId(), order);
            if (takenLessonOrder != null) {
                takenLessonOrders.add(takenLessonOrder);
            }
        }

        if (!takenLessonOrders.isEmpty()) {
            throw new InvalidRequestException(
                    String.format("One or more lesson orders have been taken in this chapter: %s",
                            String.join(", ", takenLessonOrders)
                    )
            );
        }

        // Validate status
        for (int i = 0; i < lessonsToUpdate.size(); i++) {
            LessonDTOs.UpdateLessonDTO lessonDTOPayload = listLessonsPayload.get(i);
            if (lessonDTOPayload.getStatus() != null) {

                try {
                    lessonServiceUtils.validateLessonStatus(lessonsToUpdate.get(i).getStatus(), lessonDTOPayload.getStatus());
                } catch (JsonProcessingException e) {
                    throw new RuntimeException(e);
                }

                if (lessonDTOPayload.getStatus() == CourseStatus.ARCHIVED) {
                    lessonsToUpdate.get(i).setDeletedAt(LocalDateTime.now());
                } else {
                    lessonsToUpdate.get(i).setDeletedAt(null);
                }
            }
        }

        // Map update info
        for (int i = 0; i < lessonsToUpdate.size(); i++) {
            LessonDTOs.UpdateLessonDTO lessonDTOPayload = listLessonsPayload.get(i);
            lessonMapper.updateLessonFromDto(lessonDTOPayload, lessonsToUpdate.get(i));
        }

        List<Lesson> savedLessons = lessonRepository.saveAll(lessonsToUpdate);

        return savedLessons.stream().map(lessonMapper::toDto).toList();
    }

    @Override
    @Transactional
    public void deleteSingleLesson(Long id) {
        log.info("Deleting lesson with ID: {}", id);

        Lesson lessonToDelete = lessonServiceUtils.GetLessonOrThrow(id);
        chapterServiceUtils.validateChapterAccess(lessonToDelete.getChapter());

        if (lessonToDelete.getDeletedAt() != null) {
            throw new InvalidRequestException("Lesson is already deleted");
        }

        lessonRepository.batchSoftDeleteLessons(List.of(id));

        log.info("Deleted lesson with ID: {}", id);
    }

    @Override
    @Transactional
    public void bulkDeleteLessons(List<Long> ids) {
        log.info("Bulk deleting {} lessons", ids.size());

        List<Lesson> lessonsToDelete = lessonRepository.findAllById(ids);

        lessonServiceUtils.validateBulkOperation(ids);

        for (Lesson lesson : lessonsToDelete) {
            chapterServiceUtils.validateChapterAccess(lesson.getChapter());
        }

        lessonRepository.batchSoftDeleteLessons(ids);

        log.info("Successfully deleted {} lessons", ids.size());
    }

    @Override
    @Transactional
    public void restoreLesson(Long id) {
        log.info("Restoring lesson with ID: {}", id);

        Lesson lessonToRestore = lessonServiceUtils.GetLessonOrThrow(id);
        chapterServiceUtils.validateChapterAccess(lessonToRestore.getChapter());

        if (lessonToRestore.getDeletedAt() == null) {
            throw new InvalidRequestException("Lesson is not deleted");
        }

        lessonRepository.batchRestoreLessons(List.of(id));

        log.info("Restored lesson with ID: {}", id);
    }

    @Override
    @Transactional
    public void bulkRestoreLessons(List<Long> ids) {
        log.info("Bulk restoring {} lessons", ids.size());

        List<Lesson> lessonsToRestore = lessonRepository.findAllById(ids);

        lessonServiceUtils.validateBulkOperation(ids);

        for (Lesson lesson : lessonsToRestore) {
            chapterServiceUtils.validateChapterAccess(lesson.getChapter());
        }

        lessonRepository.batchRestoreLessons(ids);

        log.info("Successfully restored {} lessons", ids.size());
    }

    @Override
    @Transactional
    public Page<LessonDTOs.LessonDetailResponseDto> searchLessons(LessonDTOs.LessonSearchDTO request) {
        log.info("Searching lessons with criteria: {}", request);

        Pageable pageable = null;

        // Validate and create sort if provided
        if (request.getSort() != null) {
            lessonServiceUtils.validateSortFields(request.getSort());

        }
        pageable = PageRequest.of(
                request.getPage() - 1,
                request.getLimit(),
                lessonServiceUtils.createLessonSortParams(request.getSort())
        );

        // Ensure courseIds and chapterIds are not null
        List<Long> courseIds = request.getCourseIds() != null ? request.getCourseIds() : Collections.emptyList();
        List<Long> chapterIds = request.getChapterIds() != null ? request.getChapterIds() : Collections.emptyList();

        return lessonRepository.searchLessons(
                request.getTitle(),
                request.getStatus() != null ? request.getStatus().name() : null,
                courseIds,
                chapterIds,
                request.getType() != null ? request.getType().name() : null,
                request.getFromDate(),
                request.getToDate(),
                pageable
        ).map(lessonMapper::toDetailDto);
    }

    @Override
    @Transactional
    public void reorderLessons(Long chapterId) {
        log.info("Reordering lessons for chapter ID: {}", chapterId);

        if (chapterId == null || chapterId < 1) {
            throw new InvalidRequestException("Chapter ID is required");
        }

        Chapter chapter = chapterServiceUtils.getChapterOrThrow(chapterId);
        chapterServiceUtils.validateChapterAccess(chapter);

        lessonRepository.reorderLessons(chapterId);

        log.info("Lessons reordered successfully");
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/service/impl/UserServiceImpl.java">
package com.online.course.management.project.service.impl;

import com.online.course.management.project.dto.UserDTOs;
import com.online.course.management.project.entity.Role;
import com.online.course.management.project.entity.User;
import com.online.course.management.project.enums.RoleType;
import com.online.course.management.project.exception.business.ForbiddenException;
import com.online.course.management.project.exception.business.ResourceNotFoundException;
import com.online.course.management.project.mapper.UserMapper;
import com.online.course.management.project.repository.IRoleRepository;
import com.online.course.management.project.repository.IUserRepository;
import com.online.course.management.project.service.interfaces.IUserService;
import com.online.course.management.project.utils.user.UserServiceUtils;
import jakarta.transaction.Transactional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import lombok.extern.slf4j.Slf4j;

import java.time.LocalDateTime;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

@Service
@Slf4j
public class UserServiceImpl implements IUserService {

    private final IUserRepository userRepository;
    private final IRoleRepository roleRepository;
    private final PasswordEncoder passwordEncoder;
    private final UserMapper userMapper;
    private final UserServiceUtils userServiceUtils;

    @Autowired
    public UserServiceImpl(IUserRepository userRepository, IRoleRepository roleRepository, PasswordEncoder passwordEncoder, UserMapper userMapper, UserServiceUtils userServiceUtils) {
        this.userRepository = userRepository;
        this.roleRepository = roleRepository;
        this.passwordEncoder = passwordEncoder;
        this.userMapper = userMapper;
        this.userServiceUtils = userServiceUtils;
    }

    @Override
    @Transactional
    public UserDTOs.UserResponseDto registerUser(UserDTOs.UserRegistrationDto registrationDto) {
        log.info("Registering new user with email: {}", registrationDto.getEmail());
        userServiceUtils.validateNewUser(registrationDto);
        User user = userServiceUtils.createUserFromDto(registrationDto);
        userServiceUtils.assignDefaultRole(user);
        User savedUser = userRepository.save(user);

        log.info("User registered successfully with id: {}", savedUser.getId());
        return userMapper.toDto(savedUser);
    }


    @Override
    @Transactional
    public UserDTOs.UserResponseDto updateUserProfile(Long userId, UserDTOs.UpdateProfileDto updateProfileDto) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User not found"));

        userMapper.updateUserFromDto(updateProfileDto, user);

        if (updateProfileDto.getPassword() != null) {

            if (user.getUserRoles().stream().anyMatch(role -> role.getRole().getName() == RoleType.ADMIN)) {
                throw new ForbiddenException("Can not change password for admin user");
            }

            user.setPasswordHash(passwordEncoder.encode(updateProfileDto.getPassword()));
        }

        User updatedUser = userRepository.save(user);
        return userMapper.toDto(updatedUser);
    }

    /**
     * @param userId
     * @param newRoles
     * @param currentUserId
     */
    @Override
    @Transactional
    public Set<String> updateUserRoles(Long userId, Set<RoleType> newRoles, Long currentUserId) {

        log.info("Updating roles for user {}. New roles: {}", userId, newRoles);

        User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User not found"));


        boolean isInitialAdmin = "admin@gmail.com".equals(user.getEmail());
        boolean isCurrentlyAdmin = user.getUserRoles().stream()
                .anyMatch(userRole -> userRole.getRole().getName() == RoleType.ADMIN);
        boolean isAttemptingToAssignAdminRole = newRoles.contains(RoleType.ADMIN);

        // Prevent assigning ADMIN role to non-admin users
        if (!isCurrentlyAdmin && isAttemptingToAssignAdminRole) {
            throw new ForbiddenException("Cannot assign ADMIN role to a non-admin user");
        }

        boolean isRemovingAdminRole = isCurrentlyAdmin && !isAttemptingToAssignAdminRole;

        // Prevent removing ADMIN role from the initial admin account
        if (isInitialAdmin && isRemovingAdminRole) {
            throw new ForbiddenException("Cannot remove ADMIN role from the initial admin account");
        }

        // If the current user is updating their own roles
        if (userId.equals(currentUserId) && isRemovingAdminRole) {
            // Prevent users from removing their own ADMIN role
            throw new ForbiddenException("You cannot remove your own ADMIN role");

        }

        Set<Role> rolesToSet = newRoles.stream()
                .map(roleType -> roleRepository.findByName(roleType)
                        .orElseThrow(() -> new ResourceNotFoundException("Role not found: " + roleType)))
                .collect(Collectors.toSet());

        // log old roles of user
        log.info("Current user roles: {}", user.getUserRoles().stream()
                .map(ur -> ur.getRole().getName().name())
                .collect(Collectors.toSet()));

        // Clear existing roles and add new ones
        user.getUserRoles().clear();
        for (Role role : rolesToSet) {
            user.addRole(role);
        }

        User savedUser = userRepository.save(user);

        // Log the roles after saving
        Set<String> updatedRoles = savedUser.getUserRoles().stream()
                .map(userRole -> userRole.getRole().getName().name())
                .collect(Collectors.toSet());
        log.info("Updated roles for user {}: {}", userId, updatedRoles);

        return updatedRoles;
    }

    /**
     * @param pageable
     * @return
     */
    @Override
    public Page<UserDTOs.UserWithRolesResponseDto> getAllUsers(Pageable pageable) {
        Page<User> users = userRepository.findAll(pageable);
        return users.map(userMapper::toUserWithRolesDto);
    }


    @Override
    public Page<UserDTOs.UserWithRolesResponseDto> searchUsers(UserDTOs.UserSearchRequestDto searchUsersPayload, Pageable pageable) {
        Specification<User> querySpecification = userServiceUtils.createSpecification(searchUsersPayload);

        Page<User> users = userRepository.findAll(querySpecification, pageable);
        return users.map(userMapper::toUserWithRolesDto);
    }

    @Override
    public long countUsers(Optional<UserDTOs.UserSearchRequestDto> searchUsersPayload) {
        if (searchUsersPayload.isPresent()) {
            Specification<User> querySpecification = userServiceUtils.createSpecification(searchUsersPayload.get());
            return userRepository.count(querySpecification);
        } else {
            return userRepository.count();
        }
    }

    @Override
    @Cacheable(value = "users", key = "#id")
    public Optional<User> getUserById(Long id) {
        log.debug("Fetching user with id: {}", id);
        return userRepository.findById(id);
    }

    @Override
    public Optional<User> getUserByUsername(String username) {
        return userRepository.findByUsername(username);
    }

    @Override
    public Optional<User> getUserByEmail(String email) {
        return userRepository.findByEmail(email);
    }

    @Override
    @Transactional
    @CacheEvict(value = "users", key = "#user.id")
    public User updateUser(User user) {
        log.info("Updating user with id: {}", user.getId());
        return userRepository.save(user);
    }

    @Override
    @Transactional
    public void softDeleteUser(Long id) {


        userRepository.findById(id).ifPresent(user -> {

            if (user.getUserRoles().stream().anyMatch(role -> role.getRole().getName() == RoleType.ADMIN)) {
                throw new ForbiddenException("Can not delete admin user");
            }

            user.setDeletedAt(LocalDateTime.now());
            userRepository.save(user);
        });
    }

    @Override
    public boolean existsByUsername(String username) {
        return userRepository.existsByUsername(username);
    }

    @Override
    public boolean existsByEmail(String email) {
        return userRepository.existsByEmail(email);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/service/interfaces/ICategoryService.java">
package com.online.course.management.project.service.interfaces;

import com.online.course.management.project.dto.CategoryDTOs;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

public interface ICategoryService {
    CategoryDTOs.CategoryResponseDto createCategory(CategoryDTOs.CreateCategoryDTO request);

    CategoryDTOs.CategoryResponseDto updateCategory(Long id, CategoryDTOs.UpdateCategoryDTO request);

    void deleteCategory(Long id);

    CategoryDTOs.CategoryResponseDto getCategoryById(Long id);

    boolean isCategoryNameExist(String categoryName);

    Page<CategoryDTOs.CategoryResponseDto> searchCategories(CategoryDTOs.CategorySearchDTO request, Pageable pageable);

    void restoreCategory(Long id);
}
</file>

<file path="src/main/java/com/online/course/management/project/service/interfaces/IChapterService.java">
package com.online.course.management.project.service.interfaces;

import com.online.course.management.project.dto.ChapterDTOs;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.List;

public interface IChapterService {

    ChapterDTOs.ChapterDetailResponseDto createChapter(ChapterDTOs.CreateChapterDTO request);

    List<ChapterDTOs.ChapterDetailResponseDto> bulkCreateChapters(ChapterDTOs.BulkCreateChapterDTO request);

    ChapterDTOs.ChapterDetailResponseDto updateChapter(Long id, ChapterDTOs.UpdateChapterDTO request);

    List<ChapterDTOs.ChapterResponseDto> bulkUpdateChapters(List<Long> ids, List<ChapterDTOs.UpdateChapterDTO> chapters);

    void deleteChapter(Long id);

    void bulkDeleteChapters(List<Long> ids);

    void restoreChapter(Long id);

    void bulkRestoreChapters(List<Long> ids);


    ChapterDTOs.ChapterResponseDto getChapterById(Long id);

    ChapterDTOs.ChapterDetailResponseDto getChapterWithLessons(Long id);

    List<ChapterDTOs.ChapterResponseDto> getAllChaptersByCourseId(Long courseId);

    Page<ChapterDTOs.ChapterResponseDto> searchChapters(
            ChapterDTOs.ChapterSearchDTO request,
            Pageable pageable
    );

    void reorderChapters(Long courseId);
}
</file>

<file path="src/main/java/com/online/course/management/project/service/interfaces/ICourseService.java">
package com.online.course.management.project.service.interfaces;

import com.online.course.management.project.dto.CourseDTOS;
import com.online.course.management.project.enums.CourseStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.List;
import java.util.Optional;
import java.util.Set;

public interface ICourseService {
    /**
     * Creates a new course
     */
    CourseDTOS.CourseDetailsResponseDto createCourse(CourseDTOS.CreateCourseRequestDTO request);

    /**
     * Updates an existing course
     */
    CourseDTOS.CourseDetailsResponseDto updateCourse(Long id, CourseDTOS.UpdateCourseRequestDTO request);

    /**
     * Archives a course (soft delete)
     */
    void archiveCourse(Long id);

    /**
     * Restores an archived course
     */
    void unarchiveCourse(Long id);

    /**
     * Gets course details by ID
     */
    CourseDTOS.CourseDetailsResponseDto getCourseById(Long id);

    /**
     * Searches courses with filters and pagination
     */
    Page<CourseDTOS.CourseDetailsResponseDto> searchCourses(CourseDTOS.SearchCourseRequestDTO request, Pageable pageable);

    /**
     * Gets courses by instructor with pagination
     */
    Page<CourseDTOS.CourseDetailsResponseDto> getCoursesByInstructor(Long instructorId, boolean includeArchived, Pageable pageable);

    /**
     * Gets courses by status with pagination
     */
    Page<CourseDTOS.CourseDetailsResponseDto> getCoursesByStatus(CourseStatus status, Pageable pageable);

    /**
     * Gets the latest courses
     */
    List<CourseDTOS.CourseDetailsResponseDto> getLatestCourses(int limit);
}
</file>

<file path="src/main/java/com/online/course/management/project/service/interfaces/ILessonService.java">
package com.online.course.management.project.service.interfaces;

import com.online.course.management.project.dto.LessonDTOs;
import org.springframework.data.domain.Page;

import java.util.List;

public interface ILessonService {

    LessonDTOs.LessonResponseDto createLesson(LessonDTOs.CreateLessonDTOWithChapterId request);

    List<LessonDTOs.LessonResponseDto> bulkCreateLessons(LessonDTOs.BulkCreateLessonDTO request);

    LessonDTOs.LessonResponseDto updateLesson(Long id, LessonDTOs.UpdateLessonDTO request);

    List<LessonDTOs.LessonResponseDto> bulkUpdateLessons(LessonDTOs.BulkUpdateLessonDTO request);

    void deleteSingleLesson(Long id);

    void bulkDeleteLessons(List<Long> ids);

    void restoreLesson(Long id);

    void bulkRestoreLessons(List<Long> ids);

    Page<LessonDTOs.LessonDetailResponseDto> searchLessons(LessonDTOs.LessonSearchDTO request);

    void reorderLessons(Long chapterId);
}
</file>

<file path="src/main/java/com/online/course/management/project/service/interfaces/IUserService.java">
package com.online.course.management.project.service.interfaces;

import com.online.course.management.project.dto.UserDTOs;
import com.online.course.management.project.entity.User;
import com.online.course.management.project.enums.RoleType;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.time.LocalDateTime;
import java.util.Optional;
import java.util.Set;

public interface IUserService {
    UserDTOs.UserResponseDto registerUser(UserDTOs.UserRegistrationDto userRegistrationDto);

    Optional<User> getUserById(Long id);

    Optional<User> getUserByUsername(String username);

    Optional<User> getUserByEmail(String email);

    User updateUser(User user);

    void softDeleteUser(Long id);

    boolean existsByUsername(String username);

    boolean existsByEmail(String email);

    UserDTOs.UserResponseDto updateUserProfile(Long userId, UserDTOs.UpdateProfileDto updateProfileDto);

    Set<String> updateUserRoles(Long userId, Set<RoleType> roleNames, Long currentUserId);

    Page<UserDTOs.UserWithRolesResponseDto> getAllUsers(Pageable pageable);

    Page<UserDTOs.UserWithRolesResponseDto> searchUsers(
            UserDTOs.UserSearchRequestDto searchUsersPayload,
            Pageable pageable
    );

    long countUsers(Optional<UserDTOs.UserSearchRequestDto> searchUsersPayload);
}
</file>

<file path="src/main/java/com/online/course/management/project/utils/category/CategoryServiceUtils.java">
package com.online.course.management.project.utils.category;

import com.online.course.management.project.entity.Category;
import com.online.course.management.project.exception.business.ResourceNotFoundException;
import com.online.course.management.project.repository.ICategoryRepository;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

@Component
@Slf4j
public class CategoryServiceUtils {

    private final ICategoryRepository categoryRepository;

    public CategoryServiceUtils(ICategoryRepository categoryRepository) {
        this.categoryRepository = categoryRepository;
    }

    public Category getCategoryOrThrow(Long id) {
        return categoryRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Category not found with id: " + id));
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/utils/chapter/ChapterServiceUtils.java">
package com.online.course.management.project.utils.chapter;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.online.course.management.project.dto.ChapterDTOs;
import com.online.course.management.project.dto.LessonDTOs;
import com.online.course.management.project.entity.Chapter;
import com.online.course.management.project.entity.Course;
import com.online.course.management.project.entity.Lesson;
import com.online.course.management.project.enums.CourseStatus;
import com.online.course.management.project.exception.business.ForbiddenException;
import com.online.course.management.project.exception.business.InvalidRequestException;
import com.online.course.management.project.exception.business.ResourceNotFoundException;
import com.online.course.management.project.repository.IChapterRepository;
import com.online.course.management.project.repository.ILessonRepository;
import com.online.course.management.project.utils.course.CourseServiceUtils;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.JpaSort;
import org.springframework.stereotype.Component;

import java.util.*;
import java.util.stream.Collectors;

@Component
@Slf4j
public class ChapterServiceUtils {

    private final IChapterRepository chapterRepository;
    private final ILessonRepository lessonRepository;
    private final CourseServiceUtils courseServiceUtils;
    private final ObjectMapper objectMapper;
    private static final int MAX_BULK_OPERATION_SIZE = 5;

    public ChapterServiceUtils(
            IChapterRepository chapterRepository,
            CourseServiceUtils courseServiceUtils,
            ObjectMapper objectMapper,
            ILessonRepository lessonRepository) {
        this.chapterRepository = chapterRepository;
        this.courseServiceUtils = courseServiceUtils;
        this.objectMapper = objectMapper;
        this.lessonRepository = lessonRepository;
    }

    /**
     * Gets a chapter by ID or throws an exception if not found
     */
    public Chapter getChapterOrThrow(Long id) {
        return chapterRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException(
                        String.format("Chapter not found with id: %d", id)
                ));
    }

    /**
     * Validates chapter order number within a course
     */
    public String validateChapterOrder(Long courseId, Integer order) {
        log.debug("Validating order {} for course {}",
                order, courseId);

        if (order == null || order < 1) {
            throw new InvalidRequestException("Order must be greater than 0");
        }

        if (chapterRepository.isOrderNumberChapterTaken(courseId, order)) {
            return String.format("Order number %d is already taken in this course", order);
        }

        return null;
    }

    /**
     * Validates chapter status transitions
     */
    public void validateChapterStatus(CourseStatus currentStatus, CourseStatus newStatus)
            throws JsonProcessingException {
        if (newStatus == null) {
            throw new InvalidRequestException("Chapter status cannot be null");
        }

        // If it's a new chapter (currentStatus is null), only allow DRAFT
        if (currentStatus == null && newStatus != CourseStatus.DRAFT) {
            throw new InvalidRequestException(
                    String.format("New chapter must be created with status DRAFT, received: %s", newStatus)
            );
        }

        // Define valid transitions for each status
        Map<CourseStatus, Set<CourseStatus>> validTransitions = Map.of(
                CourseStatus.DRAFT, Set.of(CourseStatus.PUBLISHED, CourseStatus.ARCHIVED),
                CourseStatus.PUBLISHED, Set.of(CourseStatus.DRAFT, CourseStatus.ARCHIVED),
                CourseStatus.ARCHIVED, Set.of(CourseStatus.DRAFT)
        );

        // Validate the transition
        if (currentStatus != null && !validTransitions.get(currentStatus).contains(newStatus)) {
            String errorMessage = String.format("Invalid status transition: %s",
                    objectMapper.writeValueAsString(Map.of(
                            "currentStatus", currentStatus,
                            "newStatus", newStatus,
                            "allowedTransitions", validTransitions.get(currentStatus)
                    ))
            );
            throw new InvalidRequestException(errorMessage);
        }
    }

    /**
     * Validates bulk operation requirements
     */
    public void validateBulkOperation(List<Long> chapterIds) {
        if (chapterIds == null || chapterIds.isEmpty()) {
            throw new InvalidRequestException("No chapter IDs provided");
        }

        if (chapterIds.size() > MAX_BULK_OPERATION_SIZE) {
            throw new InvalidRequestException(
                    String.format("Maximum of %d chapters can be processed at once", MAX_BULK_OPERATION_SIZE)
            );
        }

        // Check for duplicates
        Set<Long> uniqueIds = new HashSet<>(chapterIds);
        if (uniqueIds.size() != chapterIds.size()) {
            throw new InvalidRequestException("Duplicate chapter IDs found");
        }

        // Validate all chapters exist
        if (!chapterRepository.validateChaptersExist(chapterIds, chapterIds.size())) {
            throw new ResourceNotFoundException("One or more chapters not found");
        }
    }

    /**
     * Validates access to a chapter based on course status and user permissions
     */
    public void validateChapterAccess(Chapter chapter) {
        Course course = chapter.getCourse();

        if (course.getStatus() == CourseStatus.ARCHIVED) {
            throw new ForbiddenException(
                    String.format("Cannot modify chapter %d - course %d is archived",
                            chapter.getId(), course.getId())
            );
        }

        courseServiceUtils.validateCourseAccess(course);
    }

    /**
     * Validates sort parameters for chapter queries
     */
    public void validateSortFields(Map<String, String> sort) {
        Set<String> validFields = Set.of(
                "title",
                "order_number",
                "status",
                "created_at",
                "updated_at"
        );

        Set<String> invalidFields = sort.keySet().stream()
                .filter(field -> !validFields.contains(field))
                .collect(Collectors.toSet());

        if (!invalidFields.isEmpty()) {
            throw new InvalidRequestException(
                    String.format("Invalid sort fields: %s. Valid fields are: %s",
                            String.join(", ", invalidFields),
                            String.join(", ", validFields))
            );
        }

        // Validate sort directions
        sort.values().forEach(direction -> {
            if (!direction.equalsIgnoreCase("asc") && !direction.equalsIgnoreCase("desc")) {
                throw new InvalidRequestException(
                        String.format("Invalid sort direction: %s. Must be 'asc' or 'desc'", direction)
                );
            }
        });
    }

    /**
     * Creates a Sort object for chapter queries with default sorting
     */
    public Sort createChapterSort(Map<String, String> sortParams) {
        if (sortParams == null || sortParams.isEmpty()) {
            return Sort.by(Sort.Direction.ASC, "order_number");
        }

        List<Sort.Order> orders = sortParams.entrySet().stream()
                .map(entry -> {
                    Sort.Direction direction = entry.getValue().equalsIgnoreCase("asc") ?
                            Sort.Direction.ASC : Sort.Direction.DESC;
                    return JpaSort.unsafe(direction, entry.getKey()).getOrderFor(entry.getKey());
                })
                .collect(Collectors.toList());

        return Sort.by(orders);
    }

    public void validateBulkCreateRequest(ChapterDTOs.BulkCreateChapterDTO request) {
        if (request.getChapters() == null || request.getChapters().isEmpty()) {
            throw new InvalidRequestException("No chapters provided for creation");
        }

        if (request.getChapters().size() > 5) {
            throw new InvalidRequestException("Maximum 5 chapters can be created at once");
        }

        // Validate chapter orders uniqueness
        Set<Integer> chapterOrders = new HashSet<>();
        for (ChapterDTOs.CreateChapterDTO chapter : request.getChapters()) {
            if (!chapterOrders.add(chapter.getOrder())) {
                throw new InvalidRequestException(String.format("Duplicate chapter order found: %d", chapter.getOrder()));
            }

            // Validate lessons if present
            if (chapter.getLessons() != null && !chapter.getLessons().isEmpty()) {
                validateLessons(chapter.getLessons());
            }
        }
    }

    public void validateBulkChapterOrders(Long courseId, List<ChapterDTOs.CreateChapterDTO> chapters) {
        List<String> conflictingOrders = new ArrayList<>();

        for (ChapterDTOs.CreateChapterDTO chapter : chapters) {
            var takenOrder = validateChapterOrder(courseId, chapter.getOrder());
            if (takenOrder != null) {
                conflictingOrders.add(takenOrder);
            }
        }

        if (!conflictingOrders.isEmpty()) {
            throw new InvalidRequestException("Order conflicts found: " + String.join(", ", conflictingOrders));
        }
    }

    public void validateBulkLessonsOrders(Long chapterId, List<Lesson> lessons) {
        // Validate lesson orders
        List<String> takenLessonOrders = new ArrayList<>();
        for (Lesson lesson : lessons) {
            if (lessonRepository.isOrderNumberLessonTaken(chapterId, lesson.getOrder())) {
                takenLessonOrders.add(String.format("Order number %d is already taken in this chapter", lesson.getOrder()));
            }
        }

        if (!takenLessonOrders.isEmpty()) {
            throw new InvalidRequestException(String.format("One or more lessons have duplicate order numbers: %s", String.join(", ", takenLessonOrders)));
        }
    }

    public Chapter createChapterWithLessons(ChapterDTOs.CreateChapterDTO dto, Course course) {
        Chapter chapter = new Chapter();
        chapter.setCourse(course);
        chapter.setTitle(dto.getTitle());
        chapter.setDescription(dto.getDescription());
        chapter.setOrder(dto.getOrder());
        chapter.setStatus(CourseStatus.DRAFT);

        if (dto.getLessons() != null && !dto.getLessons().isEmpty()) {
            List<Lesson> lessons = dto.getLessons().stream().map(lessonDto -> {
                Lesson lesson = new Lesson();
                lesson.setChapter(chapter);
                lesson.setTitle(lessonDto.getTitle());
                lesson.setContent(lessonDto.getContent());
                lesson.setOrder(lessonDto.getOrder()); // Maintain original order
                lesson.setType(lessonDto.getType());
                lesson.setStatus(CourseStatus.DRAFT);
                return lesson;
            }).collect(Collectors.toList());

            chapter.setLessons(lessons);
        }

        return chapter;
    }

    public void validateLessons(List<LessonDTOs.CreateLessonDTO> lessons) {
        // Validate orders
        Set<Integer> seenOrders = new HashSet<>();
        List<Integer> duplicateOrders = new ArrayList<>();

        for (LessonDTOs.CreateLessonDTO lesson : lessons) {
            // Validate order is positive
            if (lesson.getOrder() <= 0) {
                throw new InvalidRequestException(String.format("Invalid lesson order: %d. Order must be greater than 0", lesson.getOrder()));
            }

            // Check for duplicates
            if (!seenOrders.add(lesson.getOrder())) {
                duplicateOrders.add(lesson.getOrder());
            }
        }

        if (!duplicateOrders.isEmpty()) {
            throw new InvalidRequestException("Duplicate lesson orders found: " + duplicateOrders.stream().map(String::valueOf).collect(Collectors.joining(", ")));
        }
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/utils/course/CourseServiceUtils.java">
package com.online.course.management.project.utils.course;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.online.course.management.project.entity.Category;
import com.online.course.management.project.entity.Course;
import com.online.course.management.project.entity.User;
import com.online.course.management.project.enums.CourseStatus;
import com.online.course.management.project.enums.RoleType;
import com.online.course.management.project.exception.business.ForbiddenException;
import com.online.course.management.project.exception.business.InvalidRequestException;
import com.online.course.management.project.exception.business.ResourceNotFoundException;
import com.online.course.management.project.repository.ICategoryRepository;
import com.online.course.management.project.repository.ICourseRepository;
import com.online.course.management.project.repository.IUserRepository;
import com.online.course.management.project.security.CustomUserDetails;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.JpaSort;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;

import java.util.*;
import java.util.stream.Collectors;

@Component
@Slf4j
public class CourseServiceUtils {

    private static final String DEFAULT_SORT_FIELD = "created_at";
    private final IUserRepository userRepository;
    private final ICourseRepository courseRepository;
    private final ICategoryRepository categoryRepository;

    @Autowired
    public CourseServiceUtils(IUserRepository userRepository, ICourseRepository courseRepository, ICategoryRepository categoryRepository) {
        this.userRepository = userRepository;
        this.courseRepository = courseRepository;
        this.categoryRepository = categoryRepository;
    }

    public Sort handleCreateDefaultSort() {
        return Sort.by(Sort.Direction.DESC, DEFAULT_SORT_FIELD);
    }

    private void validateInstructorRole(User user) {
        boolean isInstructor = user.getUserRoles().stream()
                .anyMatch(role -> role.getRole().getName() == RoleType.INSTRUCTOR);
        if (!isInstructor) {
            throw new InvalidRequestException("User is not an instructor");
        }
    }

    public User getCurrentUser() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        CustomUserDetails userDetails = (CustomUserDetails) authentication.getPrincipal();
        return userDetails.getUser();
    }

    public User determineInstructor(Long instructorId) {
        if (instructorId != null) {

            User instructor = userRepository.findById(instructorId)
                    .orElseThrow(() -> new ResourceNotFoundException("Instructor not found"));
            validateInstructorRole(instructor);
            return instructor;
        }
        return getCurrentUser();
    }

    private boolean hasAdminRole() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        return authentication.getAuthorities().stream()
                .anyMatch(a -> a.getAuthority().equals("ROLE_ADMIN"));
    }

    public void validateCourseAccess(Course course) {
        if (!hasAdminRole() && !isInstructor(course)) {
            throw new ForbiddenException("You don't have permission to modify this course");
        }
    }

    private boolean isInstructor(Course course) {
        return course.getInstructor().getId().equals(getCurrentUser().getId());
    }

    public Course getCourseWithValidation(Long id) {
        Course course = courseRepository.findByIdWithDetails(id)
                .orElseThrow(() -> new ResourceNotFoundException("Course not found"));
        validateCourseAccess(course);
        return course;
    }

    public Course GetCourseWithoutValidation(Long id) {
        return courseRepository.findByIdWithDetails(id)
                .orElseThrow(() -> new ResourceNotFoundException("Course not found"));
    }

    public Set<Category> validateCategories(Set<Long> categoryIds) {
        if (categoryIds == null || categoryIds.isEmpty()) {
            throw new InvalidRequestException("Category IDs must not be empty");
        }

        try {
            ObjectMapper objectMapper = new ObjectMapper();

            // Find all categories
            Set<Category> foundCategories = new HashSet<>(categoryRepository.findAllById(categoryIds));

            // Check for non-existent categories
            if (foundCategories.size() != categoryIds.size()) {
                Set<Long> foundIds = foundCategories.stream()
                        .map(Category::getId)
                        .collect(Collectors.toSet());

                Set<Long> notFoundIds = categoryIds.stream()
                        .filter(id -> !foundIds.contains(id))
                        .collect(Collectors.toSet());

                String notFoundMessage = String.format("Categories not found: %s",
                        objectMapper.writeValueAsString(
                                notFoundIds.stream()
                                        .map(id -> Map.of(
                                                "id", id,
                                                "nameCategory", "Not Found"
                                        ))
                                        .collect(Collectors.toList())
                        )
                );

                throw new ResourceNotFoundException(notFoundMessage);
            }

            // Check for deleted categories
            Set<Category> deletedCategories = foundCategories.stream()
                    .filter(cat -> cat.getDeletedAt() != null)
                    .collect(Collectors.toSet());

            if (!deletedCategories.isEmpty()) {
                String deletedCategoriesMessage = String.format("Cannot use deleted categories: %s",
                        objectMapper.writeValueAsString(
                                deletedCategories.stream()
                                        .map(cat -> Map.of(
                                                "id", cat.getId(),
                                                "nameCategory", cat.getName()
                                        ))
                                        .collect(Collectors.toList())
                        )
                );

                throw new InvalidRequestException(deletedCategoriesMessage);
            }

            return foundCategories;

        } catch (JsonProcessingException e) {
            throw new InvalidRequestException("Error processing category validation");
        }
    }

    public void updateCourseCategories(Course course, Set<Long> categoryIds) {
        Set<Category> validCategories = validateCategories(categoryIds);
        course.getCategories().clear();
        validCategories.forEach(course::addCategory);
    }

    // Update the helper method to handle Sort conversion
    public Sort createSort(Map<String, String> sortParams) {
        log.info("Sort params received: {}", sortParams);

        if (sortParams == null || sortParams.isEmpty()) {
            return Sort.by(Sort.Direction.DESC, DEFAULT_SORT_FIELD);
        }

        // Define mapping of sort fields to actual columns
        Map<String, String> fieldMappings = Map.of(
                "title", "title",
                "created_at", "created_at",
                "updated_at", "updated_at",
                "status", "status",
                "username", "LENGTH(instructor_username)",
                "email", "LENGTH(instructor_email)"
        );

        // Create sort orders dynamically
        List<Sort.Order> orders = sortParams.entrySet().stream()
                .map(entry -> {
                    String mappedField = fieldMappings.getOrDefault(entry.getKey(), entry.getKey());
                    Sort.Direction direction = entry.getValue().equalsIgnoreCase("asc") ?
                            Sort.Direction.ASC : Sort.Direction.DESC;

                    log.info("Creating sort order - field: {}, mapped to: {}, direction: {}",
                            entry.getKey(), mappedField, direction);
                    return JpaSort.unsafe(direction, mappedField).getOrderFor(mappedField);

                })
                .collect(Collectors.toList());

        log.info("Final sort orders: {}", orders);
        return Sort.by(orders);
    }

    // Update the helper method to include all valid sort fields
    public void validateSortFields(Map<String, String> sort) {
        Set<String> validFields = Set.of(
                "title",
                "created_at",
                "updated_at",
                "status",
                "username",
                "email"
        );

        // Validate fields
        Set<String> invalidFields = sort.keySet().stream()
                .filter(field -> !validFields.contains(field))
                .collect(Collectors.toSet());

        if (!invalidFields.isEmpty()) {
            throw new InvalidRequestException(
                    "Invalid sort fields: " + String.join(", ", invalidFields) +
                            ". Valid fields are: " + String.join(", ", validFields)
            );
        }

        // Validate directions
        sort.values().forEach(direction -> {
            if (!direction.equalsIgnoreCase("asc") && !direction.equalsIgnoreCase("desc")) {
                throw new InvalidRequestException(
                        "Invalid sort direction: " + direction + ". Must be 'asc' or 'desc'"
                );
            }
        });
    }


    public void validateCourseStatus(CourseStatus currentStatus, CourseStatus newStatus) throws JsonProcessingException {
        if (newStatus == null) {
            throw new InvalidRequestException("Course status cannot be null");
        }

        // If it's a new course (currentStatus is null), only allow DRAFT
        if (currentStatus == null && newStatus != CourseStatus.DRAFT) {
            throw new InvalidRequestException(
                    String.format("New course must be created with status DRAFT, received: %s", newStatus)
            );
        }

        // Define valid transitions for each status
        Map<CourseStatus, Set<CourseStatus>> validTransitions = Map.of(
                CourseStatus.DRAFT, Set.of(CourseStatus.PUBLISHED, CourseStatus.ARCHIVED),
                CourseStatus.PUBLISHED, Set.of(CourseStatus.DRAFT, CourseStatus.ARCHIVED),
                CourseStatus.ARCHIVED, Set.of(CourseStatus.DRAFT)
        );


        // If current status exists, validate the transition
        if (currentStatus != null && !validTransitions.get(currentStatus).contains(newStatus)) {
            try {

                CourseStatus.valueOf(newStatus.name());
                ObjectMapper objectMapper = new ObjectMapper();
                String errorMessage = String.format("Invalid status transition: %s",
                        objectMapper.writeValueAsString(Map.of(
                                "currentStatus", currentStatus,
                                "newStatus", newStatus,
                                "allowedTransitions", validTransitions.get(currentStatus)
                        ))
                );
                throw new InvalidRequestException(errorMessage);
            } catch (IllegalArgumentException e) {
                ObjectMapper objectMapper = new ObjectMapper();
                String errorMessage = String.format("Invalid course status: %s",
                        objectMapper.writeValueAsString(Map.of(
                                "providedStatus", newStatus,
                                "allowedStatuses", Arrays.stream(CourseStatus.values())
                                        .map(Enum::name)
                                        .collect(Collectors.toList())
                        ))
                );
                throw new InvalidRequestException(errorMessage);
            }
        }
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/utils/exception/GlobalExceptionUtils.java">
package com.online.course.management.project.utils.exception;

import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class GlobalExceptionUtils {
    public static List<String> getKnownProperties(Set<?> knownPropertyIds) {
        if (knownPropertyIds == null) {
            return List.of();
        }
        return knownPropertyIds.stream()
                .map(Object::toString)
                .sorted()
                .collect(Collectors.toList());
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/utils/generator/JwtSecretGenerator.java">
package com.online.course.management.project.utils.generator;

import java.security.SecureRandom;
import java.util.Base64;

public class JwtSecretGenerator {
    public static void main(String[] args) {
        SecureRandom random = new SecureRandom();
        byte[] secret = new byte[32]; // 256 bits
        random.nextBytes(secret);
        String encodedSecret = Base64.getEncoder().encodeToString(secret);
        System.out.println("Generated JWT Secret Key: " + encodedSecret);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/utils/generator/PasswordHashGenerator.java">
package com.online.course.management.project.utils.generator;

import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

public class PasswordHashGenerator {
    public static void main(String[] args) {
        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
        String password = "123456";
        String hash = encoder.encode(password);
        System.out.println("BCrypt hash for password '" + password + "':");
        System.out.println(hash);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/utils/lesson/LessonServiceUtils.java">
package com.online.course.management.project.utils.lesson;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.online.course.management.project.entity.Lesson;
import com.online.course.management.project.enums.CourseStatus;
import com.online.course.management.project.exception.business.InvalidRequestException;
import com.online.course.management.project.exception.business.ResourceNotFoundException;
import com.online.course.management.project.repository.IChapterRepository;
import com.online.course.management.project.repository.ILessonRepository;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.JpaSort;
import org.springframework.stereotype.Component;

import java.util.*;
import java.util.stream.Collectors;

@Component
@Slf4j
public class LessonServiceUtils {

    private final ILessonRepository lessonRepository;
    private final IChapterRepository chapterRepository;
    private final ObjectMapper objectMapper;

    private static final int MAX_BULK_OPERATION_SIZE = 5;

    @Autowired
    public LessonServiceUtils(ILessonRepository lessonRepository, IChapterRepository chapterRepository, ObjectMapper objectMapper) {
        this.lessonRepository = lessonRepository;
        this.chapterRepository = chapterRepository;
        this.objectMapper = objectMapper;
    }

    public Lesson GetLessonOrThrow(Long id) {
        return lessonRepository.findLessonDetailsById(id).orElseThrow(() -> new ResourceNotFoundException("Lesson not found"));
    }

    public String hasLessonOrderTakenSingle(Long chapterId, Integer order) {
        if (lessonRepository.isOrderNumberLessonTaken(chapterId, order)) {
            return String.format("Order number %d is already taken in this chapter", order);
        }

        return null;
    }

    public List<String> hasLessonOrderTakenMultiple(Long chapterId, List<Lesson> lessonsList) {

        List<String> takenLessonOrders = new ArrayList<>();
        for (Lesson lesson : lessonsList) {
            var takenLessonOrder = hasLessonOrderTakenSingle(chapterId, lesson.getOrder());

            if (takenLessonOrder != null) {
                takenLessonOrders.add(takenLessonOrder);
            }
        }

        return takenLessonOrders;
    }

    public boolean IsListOrdersContainsDuplicates(List<Integer> listOrders) {
        return listOrders.stream().distinct().count() != listOrders.size();
    }

    public void validateLessonStatus(CourseStatus currentStatus, CourseStatus newStatus)
            throws JsonProcessingException {
        if (newStatus == null) {
            throw new InvalidRequestException("Lesson status cannot be null");
        }

        // Valid status transitions
        Map<CourseStatus, Set<CourseStatus>> validTransitions = Map.of(
                CourseStatus.DRAFT, Set.of(CourseStatus.PUBLISHED, CourseStatus.ARCHIVED),
                CourseStatus.PUBLISHED, Set.of(CourseStatus.DRAFT, CourseStatus.ARCHIVED),
                CourseStatus.ARCHIVED, Set.of(CourseStatus.DRAFT)
        );

        // Validate the transition
        if (currentStatus != null && !validTransitions.get(currentStatus).contains(newStatus)) {
            String errorMessage = String.format("Invalid status transition: %s",
                    objectMapper.writeValueAsString(Map.of(
                            "currentStatus", currentStatus,
                            "newStatus", newStatus,
                            "allowedTransitions", validTransitions.get(currentStatus)
                    ))
            );
            throw new InvalidRequestException(errorMessage);
        }
    }

    public void validateBulkOperation(List<Long> lessonIds) {
        if (lessonIds == null || lessonIds.isEmpty()) {
            throw new InvalidRequestException("No lessons IDs provided");
        }

        if (lessonIds.size() > MAX_BULK_OPERATION_SIZE) {
            throw new InvalidRequestException(
                    String.format("Maximum of %d lessons can be processed at once", MAX_BULK_OPERATION_SIZE)
            );
        }

        // Check for duplicates
        Set<Long> uniqueIds = new HashSet<>(lessonIds);
        if (uniqueIds.size() != lessonIds.size()) {
            throw new InvalidRequestException("Duplicate lessons IDs found");
        }

        // Validate all lessons exist
        if (!lessonRepository.validateLessonsExists(lessonIds, lessonIds.size())) {
            throw new ResourceNotFoundException("One or more lessons not found");
        }
    }


    public void validateSortFields(Map<String, String> sort) {
        Set<String> validFields = Set.of(
                "title",
                "order_number",
                "status",
                "type",
                "created_at"
        );

        Set<String> invalidFields = sort.keySet().stream()
                .filter(field -> !validFields.contains(field))
                .collect(Collectors.toSet());

        if (!invalidFields.isEmpty()) {
            throw new InvalidRequestException(
                    String.format("Invalid sort fields: %s. Valid fields are: %s",
                            String.join(", ", invalidFields),
                            String.join(", ", validFields))
            );
        }

        // Validate sort directions
        sort.values().forEach(direction -> {
            if (!direction.equalsIgnoreCase("asc") && !direction.equalsIgnoreCase("desc")) {
                throw new InvalidRequestException(
                        String.format("Invalid sort direction: %s. Must be 'asc' or 'desc'", direction)
                );
            }
        });
    }

    public Sort createLessonSortParams(Map<String, String> sortParams) {
        if (sortParams == null || sortParams.isEmpty()) {
            return Sort.by(Sort.Direction.DESC, "created_at");
        }

        List<Sort.Order> orders = sortParams.entrySet().stream()
                .map(entry -> {
                    Sort.Direction direction = entry.getValue().equalsIgnoreCase("asc") ?
                            Sort.Direction.ASC : Sort.Direction.DESC;
                    return JpaSort.unsafe(direction, entry.getKey()).getOrderFor(entry.getKey());
                })
                .collect(Collectors.toList());

        return Sort.by(orders);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/utils/user/UserControllerUtils.java">
package com.online.course.management.project.utils.user;

import com.online.course.management.project.enums.RoleType;
import com.online.course.management.project.exception.business.InvalidRoleInfoException;
import com.online.course.management.project.exception.business.UnauthorizedException;
import com.online.course.management.project.exception.business.account.EmailAlreadyExistsException;
import com.online.course.management.project.exception.business.account.WrongEmailPasswordException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.stereotype.Component;

import java.util.HashSet;
import java.util.Set;

@Component
@Slf4j
public class UserControllerUtils {

    private final AuthenticationManager authenticationManager;

    public UserControllerUtils(AuthenticationManager authenticationManager) {
        this.authenticationManager = authenticationManager;
    }

    public Authentication authenticate(String usernameOrEmail, String password) {
        try {
            return authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(usernameOrEmail, password));
        } catch (AuthenticationException e) {
            log.error("Error during authentication", e);
            throw new WrongEmailPasswordException("Invalid username/email or password");
        }
    }

    public Set<RoleType> validateRoles(Set<String> roles) {
        Set<RoleType> validRoles = new HashSet<>();
        Set<String> invalidRoles = new HashSet<>();

        for (String role : roles) {
            try {
                validRoles.add(RoleType.valueOf(role.toUpperCase()));
            } catch (IllegalArgumentException e) {
                invalidRoles.add(role);
            }
        }

        if (!invalidRoles.isEmpty()) {
            throw new InvalidRoleInfoException("Invalid role(s) provided: " + String.join(", ", invalidRoles));
        }

        return validRoles;
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/utils/user/UserServiceUtils.java">
package com.online.course.management.project.utils.user;

import com.online.course.management.project.dto.UserDTOs;
import com.online.course.management.project.entity.Role;
import com.online.course.management.project.entity.User;
import com.online.course.management.project.enums.RoleType;
import com.online.course.management.project.enums.UserStatus;
import com.online.course.management.project.exception.business.account.AccountException;
import com.online.course.management.project.exception.business.ResourceNotFoundException;
import com.online.course.management.project.exception.business.account.EmailAlreadyExistsException;
import com.online.course.management.project.mapper.UserMapper;
import com.online.course.management.project.repository.IRoleRepository;
import com.online.course.management.project.repository.IUserRepository;
import jakarta.persistence.criteria.Predicate;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;

@Component
@Slf4j
public class UserServiceUtils {
    private final IUserRepository userRepository;
    private final IRoleRepository roleRepository;
    private final UserMapper userMapper;
    private final PasswordEncoder passwordEncoder;


    public UserServiceUtils(IUserRepository userRepository, IRoleRepository roleRepository, UserMapper userMapper, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.roleRepository = roleRepository;
        this.userMapper = userMapper;
        this.passwordEncoder = passwordEncoder;

    }

    public String generateUsernameFromEmail(String email) {
        String baseUsername = email.split("@")[0];
        String username = baseUsername;
        int suffix = 1;

        while (userRepository.existsByUsername(username)) {
            username = baseUsername + suffix;
            suffix++;
        }

        return username;
    }

    public void assignDefaultRole(User user) {
        Role userRole = roleRepository.findByName(RoleType.USER)
                .orElseThrow(() -> new ResourceNotFoundException("Default user role not found"));
        user.addRole(userRole);
    }

    public void validateNewUser(UserDTOs.UserRegistrationDto registrationDto) {
        if (userRepository.existsByEmail(registrationDto.getEmail())) {
            throw new EmailAlreadyExistsException("Email already exists: " + registrationDto.getEmail());
        }
    }

    public User createUserFromDto(UserDTOs.UserRegistrationDto registrationDto) {
        User user = userMapper.toEntity(registrationDto);
        user.setUsername(generateUsernameFromEmail(registrationDto.getEmail()));
        user.setPasswordHash(passwordEncoder.encode(registrationDto.getPassword()));
        return user;
    }

    public Specification<User> createSpecification(UserDTOs.UserSearchRequestDto searchUsersPayload) {
        return (root, query, criteriaBuilder) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (searchUsersPayload.getUsername() != null && !searchUsersPayload.getUsername().isEmpty()) {
                predicates.add(criteriaBuilder.like(criteriaBuilder.lower(root.get("username")), "%" + searchUsersPayload.getUsername().toLowerCase() + "%"));
            }
            if (searchUsersPayload.getEmail() != null && !searchUsersPayload.getEmail().isEmpty()) {
                predicates.add(criteriaBuilder.like(criteriaBuilder.lower(root.get("email")), "%" + searchUsersPayload.getEmail().toLowerCase() + "%"));
            }
            if (searchUsersPayload.getRealName() != null && !searchUsersPayload.getRealName().isEmpty()) {
                predicates.add(criteriaBuilder.like(criteriaBuilder.lower(root.get("realName")), "%" + searchUsersPayload.getRealName().toLowerCase() + "%"));
            }
            if (searchUsersPayload.getStatus() != null && !searchUsersPayload.getStatus().isEmpty()) {
                predicates.add(criteriaBuilder.equal(root.get("status"), UserStatus.valueOf(searchUsersPayload.getStatus().toUpperCase())));
            }
            if (searchUsersPayload.getFromDate() != null) {
                predicates.add(criteriaBuilder.greaterThanOrEqualTo(root.get("createdAt"), searchUsersPayload.getFromDate()));
            }
            if (searchUsersPayload.getToDate() != null) {
                predicates.add(criteriaBuilder.lessThanOrEqualTo(root.get("createdAt"), searchUsersPayload.getToDate()));
            }

            return criteriaBuilder.and(predicates.toArray(new Predicate[0]));
        };
    }


}
</file>

<file path="src/main/resources/application.properties">
spring.datasource.url=jdbc:mysql://localhost:3306/onlinecoursemanagement
spring.datasource.username=Huyvictory
spring.datasource.password=12345
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
# JPA / Hibernate properties
spring.jpa.hibernate.ddl-auto=validate
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
spring.jpa.properties.hibernate.format_sql=true
# Flyway configuration
spring.flyway.enabled=true
spring.flyway.locations=classpath:db/migration
spring.flyway.baseline-version=16
spring.flyway.baseline-on-migrate=true
# Logging
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
logging.level.root=INFO
logging.level.org.springframework.security=DEBUG
logging.level.com.online.course.management.project=DEBUG
logging.pattern.console=%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(%5p) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %clr([%X{class}]){yellow} %clr([%X{method}]){yellow} %m%n%wEx
# JWT configuration
jwt.secret=tfHDo2eVbfqEZFAjEisFcgGpdyUuB7OrmqkW2J++4CY=
jwt.expiration=3600
# Cache configuration
spring.cache.type=caffeine
spring.cache.caffeine.spec=maximumSize=500,expireAfterWrite=60m
# Output
spring.output.ansi.enabled=ALWAYS
# Exception handling
spring.mvc.throw-exception-if-no-handler-found=true
spring.web.resources.add-mappings=false
spring.jackson.deserialization.fail-on-unknown-properties=true
server.error.path=/error
</file>

<file path="src/main/resources/db/migration/V10__Update_non_admin_passwords.sql">
-- V10__Update_non_admin_passwords.sql

-- Create a temporary function to generate BCrypt hash
DELIMITER //

DROP FUNCTION IF EXISTS bcrypt_hash//
CREATE FUNCTION bcrypt_hash(password VARCHAR(255)) RETURNS VARCHAR(255)
    DETERMINISTIC
BEGIN
    -- BCrypt hash for password '123456'
    -- This is equivalent to BCryptPasswordEncoder.encode("123456")
RETURN '$2a$10$wtXh4Q7bsC.6y4D.yKvbl.X9D4TNeSXz70rCz63PVtb9xoyxC0Jly';
END//

DELIMITER ;

-- Update passwords for all non-admin users
UPDATE users u
    LEFT JOIN user_roles ur ON u.id = ur.user_id
    LEFT JOIN roles r ON ur.role_id = r.id
    SET u.password_hash = bcrypt_hash('123456')
WHERE u.email != 'admin@gmail.com'  -- Exclude admin user
  AND (r.name != 'ADMIN' OR r.name IS NULL);  -- Extra safety check for non-admin users

-- Log the number of updated users
SELECT CONCAT('Updated passwords for ', ROW_COUNT(), ' users') as migration_log;

-- Clean up
DROP FUNCTION IF EXISTS bcrypt_hash;
</file>

<file path="src/main/resources/db/migration/V11__Update_non_admin_passwords.sql">
-- V10__Update_non_admin_passwords.sql

-- Create a temporary function to generate BCrypt hash
DELIMITER //

DROP FUNCTION IF EXISTS bcrypt_hash//
CREATE FUNCTION bcrypt_hash(password VARCHAR(255)) RETURNS VARCHAR(255)
    DETERMINISTIC
BEGIN
    -- BCrypt hash for password '123456'
    -- This is equivalent to BCryptPasswordEncoder.encode("123456")
RETURN '$2a$10$wtXh4Q7bsC.6y4D.yKvbl.X9D4TNeSXz70rCz63PVtb9xoyxC0Jly';
END//

DELIMITER ;

-- Update passwords for all non-admin users
UPDATE users u
    LEFT JOIN user_roles ur ON u.id = ur.user_id
    LEFT JOIN roles r ON ur.role_id = r.id
    SET u.password_hash = bcrypt_hash('123456')
WHERE u.email != 'admin@gmail.com'  -- Exclude admin user
  AND (r.name != 'ADMIN' OR r.name IS NULL);  -- Extra safety check for non-admin users

-- Log the number of updated users
SELECT CONCAT('Updated passwords for ', ROW_COUNT(), ' users') as migration_log;

-- Clean up
DROP FUNCTION IF EXISTS bcrypt_hash;
</file>

<file path="src/main/resources/db/migration/V12__Add_chapter_and_lesson_tables.sql">
-- Create chapters table
CREATE TABLE chapters
(
    id           BIGINT AUTO_INCREMENT PRIMARY KEY,
    course_id    BIGINT       NOT NULL,
    title        VARCHAR(255) NOT NULL,
    description  TEXT,
    order_number INT          NOT NULL,
    status       VARCHAR(20)  NOT NULL DEFAULT 'DRAFT',
    created_at   DATETIME     NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at   DATETIME     NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at   DATETIME,
    CONSTRAINT fk_chapter_course
        FOREIGN KEY (course_id)
            REFERENCES courses (id)
) ENGINE = InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE = utf8mb4_unicode_ci;

-- Create lessons table
CREATE TABLE lessons
(
    id           BIGINT AUTO_INCREMENT PRIMARY KEY,
    chapter_id   BIGINT       NOT NULL,
    title        VARCHAR(255) NOT NULL,
    content      TEXT,
    order_number INT          NOT NULL,
    type         VARCHAR(20)  NOT NULL,
    status       VARCHAR(20)  NOT NULL DEFAULT 'DRAFT',
    created_at   DATETIME     NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at   DATETIME     NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at   DATETIME,
    CONSTRAINT fk_lesson_chapter
        FOREIGN KEY (chapter_id)
            REFERENCES chapters (id)
) ENGINE = InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE = utf8mb4_unicode_ci;

-- Add indexes for better query performance
CREATE INDEX idx_chapters_course_id ON chapters (course_id);
CREATE INDEX idx_chapters_status ON chapters (status);
CREATE INDEX idx_chapters_order ON chapters (order_number);
CREATE INDEX idx_chapters_deleted_at ON chapters (deleted_at);

CREATE INDEX idx_lessons_chapter_id ON lessons (chapter_id);
CREATE INDEX idx_lessons_status ON lessons (status);
CREATE INDEX idx_lessons_type ON lessons (type);
CREATE INDEX idx_lessons_order ON lessons (order_number);
CREATE INDEX idx_lessons_deleted_at ON lessons (deleted_at);
</file>

<file path="src/main/resources/db/migration/V13__Trigger_validate_soft_delete_Course_Chapter_Lesson.sql">
-- Add triggers for maintaining data consistency
DELIMITER //

-- Prevent modifying chapters of archived courses
CREATE TRIGGER trg_prevent_chapter_mod_archived_course
    BEFORE UPDATE
    ON chapters
    FOR EACH ROW
BEGIN
    DECLARE course_status VARCHAR(20);

    SELECT status
    INTO course_status
    FROM courses
    WHERE id = NEW.course_id;

    IF course_status = 'ARCHIVED' AND
       (NEW.status != 'ARCHIVED' OR
        NEW.title != OLD.title OR
        NEW.description != OLD.description OR
        NEW.order_number != OLD.order_number OR
        NEW.course_id != OLD.course_id)
    THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Cannot modify chapter of an archived course';
    END IF;
END//

-- Prevent modifying lessons of archived chapters or courses
CREATE TRIGGER trg_prevent_lesson_mod_archived_chapter_course
    BEFORE
        UPDATE
    ON lessons
    FOR EACH ROW
BEGIN
    DECLARE chapter_status VARCHAR(20);
    DECLARE course_status VARCHAR(20);

    SELECT c.status, co.status
    INTO chapter_status, course_status
    FROM chapters c
             JOIN course co ON c.course_id = co.id
    WHERE c.id = NEW.chapter_id;

    IF chapter_status = "ARCHIVED" OR course_status = "ARCHIVED" AND
                                      (NEW.status != "ARCHIVED" OR
                                       NEW.type != OLD.type OR
                                       NEW.title != OLD.title OR
                                       NEW.content != OLD.content OR
                                       NEW.order_number != OLD.order_number OR
                                       NEW.chapter_id != OLD.chapter_id
                                          )
    THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Cannot modify lesson of an archived chapter or course';
    END IF;
END//

-- Stored procedure for reordering chapters after bulk operation
CREATE PROCEDURE sp_reorder_chapters(IN p_course_id BIGINT)
BEGIN
    SET @rank := 0;

    -- Update orders of active chapters
    UPDATE chapters c
        JOIN (SELECT id, (@rank := @rank + 1) as new_order
              FROM chapters
              WHERE course_id = p_course_id
                AND deleted_at IS NULL
              ORDER BY order_number) as ranked ON c.id = ranked.id
    SET c.order_number = ranked.new_order
    WHERE c.course_id = p_course_id
      AND c.deleted_at IS NULL;

    -- Set order to 0 for all soft-deleted chapters
    UPDATE chapters
    SET order_number = 0
    WHERE course_id = p_course_id
      AND deleted_at IS NOT NULL;
END//

-- Stored procedure for reordering lessons after bulk operation
CREATE PROCEDURE sp_reorder_lessons(IN p_chapter_id BIGINT)
BEGIN
    SET @rank := 0;

    -- Update orders of active lessons
    UPDATE lessons l
        JOIN (SELECT id, (@rank := @rank + 1) as new_order
              FROM lessons
              WHERE chapter_id = p_chapter_id
                AND deleted_at IS NULL
              ORDER BY order_number) as ranked ON l.id = ranked.id
    SET l.order_number = ranked.new_order
    WHERE l.chapter_id = p_chapter_id
      AND l.deleted_at IS NULL;

    -- Set order to 0 for all soft-deleted lessons
    UPDATE lessons
    SET order_number = 0
    WHERE chapter_id = p_chapter_id
      AND deleted_at IS NOT NULL;
END//
</file>

<file path="src/main/resources/db/migration/V14__Add_trigger_archive_lessons.sql">
-- V14__Add_trigger_archive_lessons.sql

DROP TRIGGER IF EXISTS trg_chapter_archive_lessons;

CREATE TRIGGER trg_chapter_archive_lessons
    AFTER UPDATE ON chapters
    FOR EACH ROW
BEGIN
    -- When chapter is archived
    IF NEW.status = 'ARCHIVED' AND OLD.status != 'ARCHIVED' THEN
        UPDATE lessons
        SET status = 'ARCHIVED',
            deleted_at = CURRENT_TIMESTAMP,
            updated_at = CURRENT_TIMESTAMP
        WHERE chapter_id = NEW.id
          AND deleted_at IS NULL;

        -- When chapter is unarchived
    ELSEIF NEW.status != 'ARCHIVED' AND OLD.status = 'ARCHIVED' THEN
        UPDATE lessons
        SET status = 'DRAFT',
            deleted_at = NULL,
            updated_at = CURRENT_TIMESTAMP
        WHERE chapter_id = NEW.id
          AND status = 'ARCHIVED';
    END IF;
END;
</file>

<file path="src/main/resources/db/migration/V15__Add_user_enrollment_progress_rating_tables.sql">
-- Create user_courses table
CREATE TABLE user_courses
(
    id              BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id         BIGINT      NOT NULL,
    course_id       BIGINT      NOT NULL,
    enrollment_date DATETIME    NOT NULL DEFAULT CURRENT_TIMESTAMP,
    completion_date DATETIME,
    status          VARCHAR(20) NOT NULL DEFAULT 'ENROLLED',
    CONSTRAINT fk_user_courses_user FOREIGN KEY (user_id) REFERENCES users (id),
    CONSTRAINT fk_user_courses_course FOREIGN KEY (course_id) REFERENCES courses (id),
    CONSTRAINT uk_user_courses_user_course UNIQUE (user_id, course_id),
    CONSTRAINT chk_user_courses_status CHECK (status IN ('ENROLLED', 'IN_PROGRESS', 'COMPLETED', 'DROPPED'))
) ENGINE = InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE = utf8mb4_unicode_ci;

-- Create indexes for user_courses
CREATE INDEX idx_user_courses_user_id ON user_courses (user_id);
CREATE INDEX idx_user_courses_course_id ON user_courses (course_id);
CREATE INDEX idx_user_courses_status ON user_courses (status);
CREATE INDEX idx_user_courses_enrollment_date ON user_courses (enrollment_date);

-- Create user_lesson_progress table
CREATE TABLE user_lesson_progress
(
    id               BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id          BIGINT      NOT NULL,
    course_id        BIGINT      NOT NULL,
    chapter_id       BIGINT      NOT NULL,
    lesson_id        BIGINT      NOT NULL,
    status           VARCHAR(20) NOT NULL DEFAULT 'NOT_STARTED',
    last_accessed_at DATETIME,
    completion_date  DATETIME,
    CONSTRAINT fk_user_lesson_progress_user FOREIGN KEY (user_id) REFERENCES users (id),
    CONSTRAINT fk_user_lesson_progress_course FOREIGN KEY (course_id) REFERENCES courses (id),
    CONSTRAINT fk_user_lesson_progress_chapter FOREIGN KEY (chapter_id) REFERENCES chapters (id),
    CONSTRAINT fk_user_lesson_progress_lesson FOREIGN KEY (lesson_id) REFERENCES lessons (id),
    CONSTRAINT uk_user_lesson_progress_unique_progress UNIQUE (user_id, course_id, chapter_id, lesson_id),
    CONSTRAINT chk_user_lesson_progress_status CHECK (status IN ('NOT_STARTED', 'IN_PROGRESS', 'COMPLETED', 'DROPPED'))
) ENGINE = InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE = utf8mb4_unicode_ci;

-- Create indexes for user_lesson_progress
CREATE INDEX idx_user_lesson_progress_user_id ON user_lesson_progress (user_id);
CREATE INDEX idx_user_lesson_progress_course_id ON user_lesson_progress (course_id);
CREATE INDEX idx_user_lesson_progress_chapter_id ON user_lesson_progress (chapter_id);
CREATE INDEX idx_user_lesson_progress_lesson_id ON user_lesson_progress (lesson_id);
CREATE INDEX idx_user_lesson_progress_status ON user_lesson_progress (status);
CREATE INDEX idx_user_lesson_progress_last_accessed ON user_lesson_progress (last_accessed_at);

-- Create course_ratings table
CREATE TABLE course_ratings
(
    id          BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id     BIGINT   NOT NULL,
    course_id   BIGINT   NOT NULL,
    rating      INT      NOT NULL,
    review_text TEXT,
    created_at  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at  DATETIME,
    CONSTRAINT fk_course_ratings_user FOREIGN KEY (user_id) REFERENCES users (id),
    CONSTRAINT fk_course_ratings_course FOREIGN KEY (course_id) REFERENCES courses (id),
    CONSTRAINT uk_course_ratings_user_course UNIQUE (user_id, course_id),
    CONSTRAINT chk_course_ratings_rating CHECK (rating >= 1 AND rating <= 5)
) ENGINE = InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE = utf8mb4_unicode_ci;

-- Create indexes for course_ratings
CREATE INDEX idx_course_ratings_user_id ON course_ratings (user_id);
CREATE INDEX idx_course_ratings_course_id ON course_ratings (course_id);
CREATE INDEX idx_course_ratings_rating ON course_ratings (rating);
CREATE INDEX idx_course_ratings_deleted_at ON course_ratings (deleted_at);
</file>

<file path="src/main/resources/db/migration/V16__Add_flexible_progress_tracking_triggers.sql">
DELIMITER //

-- Trigger to ensure basic enrollment validation
CREATE TRIGGER trg_verify_enrollment_and_lesson
    BEFORE INSERT ON user_lesson_progress
    FOR EACH ROW
BEGIN
    DECLARE is_enrolled INT;
    DECLARE valid_lesson INT;
    DECLARE chapter_course_id BIGINT;

    -- Check enrollment
    SELECT COUNT(*) INTO is_enrolled
    FROM user_courses
    WHERE user_id = NEW.user_id
      AND course_id = NEW.course_id
      AND status != 'DROPPED';

    IF is_enrolled = 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'User must be enrolled in the course before tracking progress';
    END IF;

    -- Verify lesson belongs to the specified chapter and course
    SELECT COUNT(*), c.course_id
    INTO valid_lesson, chapter_course_id
    FROM lessons l
             JOIN chapters c ON l.chapter_id = c.id
    WHERE l.id = NEW.lesson_id
      AND l.chapter_id = NEW.chapter_id
      AND c.course_id = NEW.course_id;

    IF valid_lesson = 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Invalid lesson-chapter-course relationship';
    END IF;
END//

-- Trigger to update course progress status
CREATE TRIGGER trg_update_course_status_after_progress
    AFTER UPDATE ON user_lesson_progress
    FOR EACH ROW
BEGIN
    DECLARE total_lessons INT;
    DECLARE completed_lessons INT;
    DECLARE in_progress_lessons INT;
    DECLARE course_status VARCHAR(20);

    -- Get total number of lessons in the course
    SELECT COUNT(DISTINCT l.id)
    INTO total_lessons
    FROM lessons l
             JOIN chapters c ON l.chapter_id = c.id
    WHERE c.course_id = NEW.course_id
      AND l.deleted_at IS NULL
      AND c.deleted_at IS NULL;

    -- Get number of completed and in-progress lessons
    SELECT
        COUNT(CASE WHEN status = 'COMPLETED' THEN 1 END),
        COUNT(CASE WHEN status = 'IN_PROGRESS' THEN 1 END)
    INTO completed_lessons, in_progress_lessons
    FROM user_lesson_progress
    WHERE user_id = NEW.user_id
      AND course_id = NEW.course_id;

    -- Determine course status based on progress
    IF completed_lessons = total_lessons THEN
        SET course_status = 'COMPLETED';
    ELSEIF completed_lessons > 0 OR in_progress_lessons > 0 THEN
        SET course_status = 'IN_PROGRESS';
    ELSE
        SET course_status = 'ENROLLED';
    END IF;

    -- Update user_courses status
    UPDATE user_courses
    SET status = course_status,
        completion_date = IF(course_status = 'COMPLETED', CURRENT_TIMESTAMP, NULL)
    WHERE user_id = NEW.user_id
      AND course_id = NEW.course_id;
END//

-- Helper function to calculate chapter completion percentage
DELIMITER //

CREATE FUNCTION calculate_chapter_completion(
    p_user_id BIGINT,
    p_chapter_id BIGINT
)
    RETURNS DECIMAL(5,2)
    DETERMINISTIC
    READS SQL DATA
BEGIN
    DECLARE total_lessons INT;
    DECLARE completed_lessons INT;

    -- Get total lessons in chapter
    SELECT COUNT(*)
    INTO total_lessons
    FROM lessons
    WHERE chapter_id = p_chapter_id
      AND deleted_at IS NULL;

    -- Get completed lessons in chapter
    SELECT COUNT(*)
    INTO completed_lessons
    FROM user_lesson_progress ulp
             JOIN lessons l ON ulp.lesson_id = l.id
    WHERE ulp.user_id = p_user_id
      AND l.chapter_id = p_chapter_id
      AND ulp.status = 'COMPLETED';

    -- Return percentage or 0 if no lessons
    RETURN IF(total_lessons > 0, (completed_lessons / total_lessons) * 100, 0);
END //

DELIMITER ;
</file>

<file path="src/main/resources/db/migration/V2__Update_User_table.sql">
-- V2__Update_user_table.sql

-- Rename 'name' column to 'real_name' if it exists
SET @renameColumn = (SELECT IF(
                                    EXISTS(SELECT *
                                           FROM information_schema.COLUMNS
                                           WHERE TABLE_SCHEMA = DATABASE()
                                             AND TABLE_NAME = 'users'
                                             AND COLUMN_NAME = 'name'),
                                    'ALTER TABLE users CHANGE COLUMN name real_name VARCHAR(100)',
                                    'SELECT 1'
                            ));
PREPARE renameStmt FROM @renameColumn;
EXECUTE renameStmt;
DEALLOCATE PREPARE renameStmt;

-- Add 'real_name' column if it doesn't exist
SET @addColumn = (SELECT IF(
                                 NOT EXISTS(SELECT *
                                            FROM information_schema.COLUMNS
                                            WHERE TABLE_SCHEMA = DATABASE()
                                              AND TABLE_NAME = 'users'
                                              AND COLUMN_NAME = 'real_name'),
                                 'ALTER TABLE users ADD COLUMN real_name VARCHAR(100)',
                                 'SELECT 1'
                         ));
PREPARE addStmt FROM @addColumn;
EXECUTE addStmt;
DEALLOCATE PREPARE addStmt;

-- Add other new columns if they don't exist
SET @addCreatedAt = (SELECT IF(
                                    NOT EXISTS(SELECT *
                                               FROM information_schema.COLUMNS
                                               WHERE TABLE_SCHEMA = DATABASE()
                                                 AND TABLE_NAME = 'users'
                                                 AND COLUMN_NAME = 'created_at'),
                                    'ALTER TABLE users ADD COLUMN created_at DATETIME',
                                    'SELECT 1'
                            ));
PREPARE addCreatedAtStmt FROM @addCreatedAt;
EXECUTE addCreatedAtStmt;
DEALLOCATE PREPARE addCreatedAtStmt;

SET @addUpdatedAt = (SELECT IF(
                                    NOT EXISTS(SELECT *
                                               FROM information_schema.COLUMNS
                                               WHERE TABLE_SCHEMA = DATABASE()
                                                 AND TABLE_NAME = 'users'
                                                 AND COLUMN_NAME = 'updated_at'),
                                    'ALTER TABLE users ADD COLUMN updated_at DATETIME',
                                    'SELECT 1'
                            ));
PREPARE addUpdatedAtStmt FROM @addUpdatedAt;
EXECUTE addUpdatedAtStmt;
DEALLOCATE PREPARE addUpdatedAtStmt;

SET @addDeletedAt = (SELECT IF(
                                    NOT EXISTS(SELECT *
                                               FROM information_schema.COLUMNS
                                               WHERE TABLE_SCHEMA = DATABASE()
                                                 AND TABLE_NAME = 'users'
                                                 AND COLUMN_NAME = 'deleted_at'),
                                    'ALTER TABLE users ADD COLUMN deleted_at DATETIME',
                                    'SELECT 1'
                            ));
PREPARE addDeletedAtStmt FROM @addDeletedAt;
EXECUTE addDeletedAtStmt;
DEALLOCATE PREPARE addDeletedAtStmt;

-- Modify existing columns
ALTER TABLE users
    MODIFY COLUMN username VARCHAR(50) NOT NULL,
    MODIFY COLUMN email VARCHAR(320) NOT NULL,
    MODIFY COLUMN password_hash VARCHAR(60) NOT NULL;

-- Add unique constraints if they don't exist
SET @addUsernameConstraint = (SELECT IF(
                                             NOT EXISTS(SELECT *
                                                        FROM information_schema.TABLE_CONSTRAINTS
                                                        WHERE CONSTRAINT_SCHEMA = DATABASE()
                                                          AND TABLE_NAME = 'users'
                                                          AND CONSTRAINT_NAME = 'uk_users_username'),
                                             'ALTER TABLE users ADD CONSTRAINT uk_users_username UNIQUE (username)',
                                             'SELECT 1'
                                     ));
PREPARE usernameConstraintStmt FROM @addUsernameConstraint;
EXECUTE usernameConstraintStmt;
DEALLOCATE PREPARE usernameConstraintStmt;

SET @addEmailConstraint = (SELECT IF(
                                          NOT EXISTS(SELECT *
                                                     FROM information_schema.TABLE_CONSTRAINTS
                                                     WHERE CONSTRAINT_SCHEMA = DATABASE()
                                                       AND TABLE_NAME = 'users'
                                                       AND CONSTRAINT_NAME = 'uk_users_email'),
                                          'ALTER TABLE users ADD CONSTRAINT uk_users_email UNIQUE (email)',
                                          'SELECT 1'
                                  ));
PREPARE emailConstraintStmt FROM @addEmailConstraint;
EXECUTE emailConstraintStmt;
DEALLOCATE PREPARE emailConstraintStmt;

-- Update existing rows to set created_at and updated_at if they are NULL
UPDATE users
SET created_at = NOW(),
    updated_at = NOW()
WHERE created_at IS NULL
   OR updated_at IS NULL;
</file>

<file path="src/main/resources/db/migration/V3__Add_status_to_users.sql">
-- V3__Add_status_to_users.sql

-- Add status column if it doesn't exist
SET
@addStatus = (SELECT IF(
    NOT EXISTS(
        SELECT * FROM information_schema.COLUMNS
        WHERE TABLE_SCHEMA = DATABASE()
        AND TABLE_NAME = 'users'
        AND COLUMN_NAME = 'status'
    ),
    'ALTER TABLE users ADD COLUMN status VARCHAR(20) NOT NULL DEFAULT "ACTIVE"',
    'SELECT 1'
));

PREPARE addStatusStmt FROM @addStatus;
EXECUTE addStatusStmt;
DEALLOCATE PREPARE addStatusStmt;

-- Update existing rows to set status if they are NULL
UPDATE users
SET status = 'ACTIVE'
WHERE status IS NULL;

-- Add constraint to ensure status is one of the allowed values
ALTER TABLE users
    ADD CONSTRAINT chk_users_status
        CHECK (status IN ('ACTIVE', 'INACTIVE', 'SUSPENDED'));
</file>

<file path="src/main/resources/db/migration/V4__Add_course_and_category_tables.sql">
-- V4__Add_course_and_category_tables.sql

-- Drop any tables that might have been partially created
DROP TABLE IF EXISTS course_categories;
DROP TABLE IF EXISTS courses;
DROP TABLE IF EXISTS categories;

-- Create Categories table if not exists
SET @createCategories = (SELECT IF(
                                        NOT EXISTS(SELECT *
                                                   FROM information_schema.TABLES
                                                   WHERE TABLE_SCHEMA = DATABASE()
                                                     AND TABLE_NAME = 'categories'),
                                        'CREATE TABLE categories (
                                            id BIGINT AUTO_INCREMENT PRIMARY KEY,
                                            name VARCHAR(100) NOT NULL UNIQUE,
                                            created_at DATETIME NOT NULL,
                                            updated_at DATETIME NOT NULL,
                                            deleted_at DATETIME
                                        )',
                                        'SELECT 1'
                                ));

PREPARE createCategoriesStmt FROM @createCategories;
EXECUTE createCategoriesStmt;
DEALLOCATE PREPARE createCategoriesStmt;

-- Create Courses table if not exists
SET @createCourses = (SELECT IF(
                                     NOT EXISTS(SELECT *
                                                FROM information_schema.TABLES
                                                WHERE TABLE_SCHEMA = DATABASE()
                                                  AND TABLE_NAME = 'courses'),
                                     'CREATE TABLE courses (
                                         id BIGINT AUTO_INCREMENT PRIMARY KEY,
                                         title VARCHAR(255) NOT NULL,
                                         description TEXT,
                                         instructor_id BIGINT NOT NULL,
                                         status VARCHAR(20) NOT NULL,
                                         created_at DATETIME NOT NULL,
                                         updated_at DATETIME NOT NULL,
                                         deleted_at DATETIME,
                                         FOREIGN KEY (instructor_id) REFERENCES users(id),
                                         CONSTRAINT chk_courses_status CHECK (status IN ("DRAFT", "PUBLISHED", "ARCHIVED"))
                                     )',
                                     'SELECT 1'
                             ));

PREPARE createCoursesStmt FROM @createCourses;
EXECUTE createCoursesStmt;
DEALLOCATE PREPARE createCoursesStmt;

-- Create Course_Categories junction table if not exists
SET @createCourseCategories = (SELECT IF(
                                              NOT EXISTS(SELECT *
                                                         FROM information_schema.TABLES
                                                         WHERE TABLE_SCHEMA = DATABASE()
                                                           AND TABLE_NAME = 'course_categories'),
                                              'CREATE TABLE course_categories (
                                                  course_id BIGINT NOT NULL,
                                                  category_id BIGINT NOT NULL,
                                                  PRIMARY KEY (course_id, category_id),
                                                  FOREIGN KEY (course_id) REFERENCES courses(id),
                                                  FOREIGN KEY (category_id) REFERENCES categories(id)
                                              )',
                                              'SELECT 1'
                                      ));

PREPARE createCourseCategoriesStmt FROM @createCourseCategories;
EXECUTE createCourseCategoriesStmt;
DEALLOCATE PREPARE createCourseCategoriesStmt;
</file>

<file path="src/main/resources/db/migration/V5__Add_indexes_to_course_and_category.sql">
-- V5__Add_indexes_to_course_and_category.sql

-- Add index for instructor_id in courses table
CREATE INDEX idx_courses_instructor ON courses(instructor_id);

-- Add index for status in courses table
CREATE INDEX idx_courses_status ON courses(status);

-- Add index for deleted_at in courses table
CREATE INDEX idx_courses_deleted_at ON courses(deleted_at);

-- Add index for deleted_at in categories table
CREATE INDEX idx_categories_deleted_at ON categories(deleted_at);

-- Add index for name in categories table for faster lookups
CREATE INDEX idx_categories_name ON categories(name);
</file>

<file path="src/main/resources/db/migration/V6__Add_course_status_validation.sql">
-- V6__Add_course_status_validation.sql

-- Drop existing constraint if it exists
SET @constraint_name = (
    SELECT CONSTRAINT_NAME
    FROM information_schema.TABLE_CONSTRAINTS
    WHERE TABLE_NAME = 'courses'
    AND CONSTRAINT_TYPE = 'CHECK'
    AND CONSTRAINT_SCHEMA = DATABASE()
);

SET @drop_sql = IF(@constraint_name IS NOT NULL,
    CONCAT('ALTER TABLE courses DROP CONSTRAINT ', @constraint_name),
    'SELECT 1'
);

PREPARE stmt FROM @drop_sql;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

-- Add new constraint that enforces archived course logic
ALTER TABLE courses
    ADD CONSTRAINT chk_courses_status_deleted
        CHECK (
            (status = 'ARCHIVED' AND deleted_at IS NOT NULL) OR
            (status != 'ARCHIVED' AND deleted_at IS NULL)
            );

-- Drop existing trigger if exists
DROP TRIGGER IF EXISTS trg_course_archive_before_update;

-- Create trigger for handling course archiving
CREATE TRIGGER trg_course_archive_before_update
    BEFORE UPDATE ON courses
    FOR EACH ROW
BEGIN
    IF NEW.status = 'ARCHIVED' AND OLD.status != 'ARCHIVED' THEN
        SET NEW.deleted_at = CURRENT_TIMESTAMP;
        SET NEW.updated_at = CURRENT_TIMESTAMP;
    ELSEIF NEW.status != 'ARCHIVED' AND OLD.status = 'ARCHIVED' THEN
        SET NEW.deleted_at = NULL;
        SET NEW.updated_at = CURRENT_TIMESTAMP;
END IF;
END;

-- Update any existing inconsistent data
UPDATE courses
SET deleted_at = CURRENT_TIMESTAMP
WHERE status = 'ARCHIVED' AND deleted_at IS NULL;

UPDATE courses
SET deleted_at = NULL
WHERE status != 'ARCHIVED' AND deleted_at IS NOT NULL;
</file>

<file path="src/main/resources/db/migration/V7__Add_course_and_category_triggers.sql">
-- V7__Add_course_and_category_triggers.sql

-- Drop existing triggers if they exist
DROP TRIGGER IF EXISTS trg_course_archive_before_update;
DROP TRIGGER IF EXISTS trg_category_soft_delete_before_update;
DROP TRIGGER IF EXISTS trg_course_category_validation;

-- Create trigger for handling course archiving
CREATE TRIGGER trg_course_archive_before_update
    BEFORE UPDATE
    ON courses
    FOR EACH ROW
BEGIN
    -- When archiving a course
    IF NEW.status = 'ARCHIVED' AND OLD.status != 'ARCHIVED' THEN
        SET NEW.deleted_at = CURRENT_TIMESTAMP;
        SET NEW.updated_at = CURRENT_TIMESTAMP;
    -- When un-archiving a course
    ELSEIF NEW.status != 'ARCHIVED' AND OLD.status = 'ARCHIVED' THEN
        SET NEW.deleted_at = NULL;
        SET NEW.updated_at = CURRENT_TIMESTAMP;
END IF;
END;

-- Create trigger for handling category soft delete
CREATE TRIGGER trg_category_soft_delete_before_update
    BEFORE UPDATE
    ON categories
    FOR EACH ROW
BEGIN
    -- When soft deleting a category
    IF NEW.deleted_at IS NOT NULL AND OLD.deleted_at IS NULL THEN
        -- Delete all course-category relationships for this category
    DELETE
    FROM course_categories
    WHERE category_id = OLD.id;

    SET NEW.updated_at = CURRENT_TIMESTAMP;
    -- When restoring a category
    ELSEIF NEW.deleted_at IS NULL AND OLD.deleted_at IS NOT NULL THEN
        SET NEW.updated_at = CURRENT_TIMESTAMP;
END IF;
END;

-- Create trigger to prevent invalid course-category relationships
CREATE TRIGGER trg_course_category_validation
    BEFORE INSERT
    ON course_categories
    FOR EACH ROW
BEGIN
    DECLARE course_status VARCHAR(20);
    DECLARE category_deleted_at DATETIME;

    -- Get course status
    SELECT status, deleted_at
    INTO course_status
    FROM courses
    WHERE id = NEW.course_id;

    -- Get category deleted_at
    SELECT deleted_at
    INTO category_deleted_at
    FROM categories
    WHERE id = NEW.category_id;

    -- Prevent adding relationships for archived courses or deleted categories
    IF course_status = 'ARCHIVED' OR category_deleted_at IS NOT NULL THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Cannot create relationship: Course is archived or Category is deleted';
END IF;
END;

-- Update any existing inconsistent data
UPDATE courses
SET deleted_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE status = 'ARCHIVED'
  AND deleted_at IS NULL;

UPDATE courses
SET deleted_at = NULL,
    updated_at = CURRENT_TIMESTAMP
WHERE status != 'ARCHIVED' AND deleted_at IS NOT NULL;

-- Remove any invalid course-category relationships
DELETE
cc FROM course_categories cc
INNER JOIN courses c ON cc.course_id = c.id
WHERE c.status = 'ARCHIVED';

DELETE
cc FROM course_categories cc
INNER JOIN categories cat ON cc.category_id = cat.id
WHERE cat.deleted_at IS NOT NULL;
</file>

<file path="src/main/resources/db/migration/V8__Make_instructor_id_nullable.sql">
-- V8__Make_instructor_id_nullable.sql

-- First, drop the foreign key constraint if it exists
SET @constraint_name = (
    SELECT CONSTRAINT_NAME
    FROM information_schema.KEY_COLUMN_USAGE
    WHERE TABLE_NAME = 'courses'
    AND COLUMN_NAME = 'instructor_id'
    AND REFERENCED_TABLE_NAME = 'users'
    AND CONSTRAINT_SCHEMA = DATABASE()
);

SET @drop_fk_sql = IF(
    @constraint_name IS NOT NULL,
    CONCAT('ALTER TABLE courses DROP FOREIGN KEY ', @constraint_name),
    'SELECT 1'
);

PREPARE stmt FROM @drop_fk_sql;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

-- Now modify the instructor_id column to be nullable
ALTER TABLE courses
    MODIFY COLUMN instructor_id BIGINT NULL;

-- Re-add the foreign key constraint but allow NULL values
ALTER TABLE courses
    ADD CONSTRAINT fk_courses_instructor
        FOREIGN KEY (instructor_id) REFERENCES users(id);

-- Add an index on instructor_id if it doesn't exist already
SET @index_exists = (
    SELECT COUNT(*)
    FROM information_schema.STATISTICS
    WHERE TABLE_SCHEMA = DATABASE()
    AND TABLE_NAME = 'courses'
    AND INDEX_NAME = 'idx_courses_instructor'
);

SET @create_index_sql = IF(
    @index_exists = 0,
    'CREATE INDEX idx_courses_instructor ON courses(instructor_id)',
    'SELECT 1'
);

PREPARE stmt FROM @create_index_sql;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
</file>

<file path="src/main/resources/db/migration/V9__Add_course_archive_category_trigger.sql">
-- V9__Add_course_archive_category_trigger.sql

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS trg_course_archive_status_update;

DELIMITER //

CREATE TRIGGER trg_course_archive_status_update
    AFTER UPDATE ON courses
    FOR EACH ROW
BEGIN
    -- When course is archived, remove all its category associations
    IF NEW.status = 'ARCHIVED' AND OLD.status != 'ARCHIVED' THEN
        -- Log the removal (optional, for debugging)
        -- INSERT INTO logs (message) VALUES (CONCAT('Removing categories for archived course: ', NEW.id));

    DELETE FROM course_categories
    WHERE course_id = NEW.id;
END IF;
END//

DELIMITER ;
</file>

<file path="src/main/resources/Python_Scripts/generate_chapters_lessons.py">
import mysql.connector
from faker import Faker
import random
from datetime import datetime, timedelta

# Initialize Faker
fake = Faker()

# Database configuration
db_config = {
    'host': 'localhost',
    'user': 'Huyvictory',
    'password': '12345',
    'database': 'onlinecoursemanagement'
}


def connect_to_database():
    """Establish database connection"""
    try:
        return mysql.connector.connect(**db_config)
    except mysql.connector.Error as err:
        print(f"Error connecting to database: {err}")
        raise


def get_course_data(cursor):
    """Get all courses from the database"""
    cursor.execute("""
        SELECT id, title, status, created_at, deleted_at 
        FROM courses 
        ORDER BY id
    """)
    return cursor.fetchall()


def extract_course_topic(course_title):
    """Extract the main topic from course title"""
    prefixes = ['Ultimate', 'Advanced', 'Introduction to', 'Fundamentals of', 'Essential',
                'Complete Guide to', 'Professional', 'Modern', 'Mastering', 'Practical']

    title = course_title
    for prefix in prefixes:
        if title.startswith(prefix):
            title = title[len(prefix):].strip()

    return title.strip()


def generate_chapter_title(course_topic):
    """Generate a contextual chapter title based on course topic"""
    core_topics = {
        'Video editor': [
            'Introduction to Video Editing Basics',
            'Video Composition and Framing',
            'Advanced Editing Techniques',
            'Color Correction and Grading',
            'Audio Editing and Sound Design',
            'Transitions and Effects',
            'Project Organization and Workflow',
            'Final Output and Delivery'
        ],
        'Engineer': [
            'Engineering Fundamentals',
            'Design Principles and Methodology',
            'Technical Analysis and Planning',
            'Project Implementation Strategies',
            'Quality Assurance and Testing',
            'Documentation and Standards',
            'Performance Optimization',
            'Professional Best Practices'
        ],
        'Management': [
            'Management Principles and Theory',
            'Leadership and Team Building',
            'Strategic Planning and Execution',
            'Resource Allocation and Optimization',
            'Performance Management',
            'Risk Management and Mitigation',
            'Change Management Strategies',
            'Organizational Development'
        ],
        'Development': [
            'Core Development Concepts',
            'Software Architecture and Design',
            'Code Quality and Best Practices',
            'Testing and Debugging Strategies',
            'Performance Optimization',
            'Security Implementation',
            'Deployment and Maintenance',
            'Advanced Development Patterns'
        ],
        'Design': [
            'Design Fundamentals and Principles',
            'User Experience and Interface Design',
            'Visual Composition and Layout',
            'Color Theory and Typography',
            'Interactive Design Patterns',
            'Prototyping and Testing',
            'Design Systems and Standards',
            'Advanced Design Techniques'
        ]
    }

    # Determine which category to use based on course topic
    selected_topics = None
    for key in core_topics:
        if key.lower() in course_topic.lower():
            selected_topics = core_topics[key]
            break

    # Use generic topics if no specific match found
    if not selected_topics:
        selected_topics = [
            f'Understanding {course_topic} Fundamentals',
            f'Core Principles of {course_topic}',
            f'Advanced {course_topic} Concepts',
            f'Practical {course_topic} Applications',
            f'Professional {course_topic} Techniques',
            f'{course_topic} Best Practices',
            f'{course_topic} Analysis and Implementation',
            f'Mastering {course_topic} Skills'
        ]

    return random.choice(selected_topics)


def generate_lesson_title(chapter_title, lesson_number, total_lessons):
    """Generate a contextual lesson title that follows a logical progression"""
    main_topic = chapter_title.split(':')[-1].strip() if ':' in chapter_title else chapter_title

    if lesson_number == 1:
        patterns = [
            f'Fundamentals of {main_topic}',
            f'Introduction to {main_topic}',
            f'Getting Started with {main_topic}',
            f'Core Concepts of {main_topic}'
        ]
    elif lesson_number == total_lessons:
        patterns = [
            f'Advanced Applications in {main_topic}',
            f'Mastering {main_topic}',
            f'Professional {main_topic} Techniques',
            f'Real-world {main_topic} Projects'
        ]
    else:
        position_ratio = lesson_number / total_lessons
        if position_ratio < 0.33:
            patterns = [
                f'Understanding {main_topic} Principles',
                f'Essential {main_topic} Concepts',
                f'Building Blocks of {main_topic}',
                f'{main_topic} Foundations'
            ]
        elif position_ratio < 0.66:
            patterns = [
                f'Practical {main_topic} Applications',
                f'Implementing {main_topic}',
                f'{main_topic} in Practice',
                f'Working with {main_topic}'
            ]
        else:
            patterns = [
                f'Advanced {main_topic} Techniques',
                f'Professional {main_topic} Skills',
                f'Complex {main_topic} Scenarios',
                f'Optimizing {main_topic}'
            ]

    return random.choice(patterns)


def generate_content_section(topic, section_type):
    """Generate specific content sections based on topic and type"""
    if section_type == "objectives":
        objectives = [
            f"Understand key concepts of {topic}",
            f"Apply practical techniques in {topic}",
            f"Analyze various approaches to {topic}",
            f"Evaluate best practices in {topic}",
            f"Implement effective solutions for {topic}",
            f"Master advanced techniques in {topic}"
        ]
        return random.sample(objectives, k=3)

    elif section_type == "key_points":
        points = [
            f"Essential principles of {topic}",
            f"Common challenges in {topic} and their solutions",
            f"Best practices for {topic} implementation",
            f"Important considerations when working with {topic}",
            f"Industry standards for {topic}",
            f"Professional tips for {topic}"
        ]
        return random.sample(points, k=3)

    elif section_type == "practice":
        exercises = [
            f"Implement a basic {topic} solution",
            f"Analyze a real-world {topic} scenario",
            f"Optimize an existing {topic} implementation",
            f"Troubleshoot common {topic} issues",
            f"Design a complete {topic} solution",
            f"Review and improve {topic} performance"
        ]
        return random.sample(exercises, k=3)


def generate_lesson_content(lesson_type, lesson_title):
    """Generate structured lesson content based on lesson type and title"""
    topic = lesson_title.split('of ')[-1] if 'of ' in lesson_title else lesson_title

    def generate_text_content():
        learning_objectives = "\n".join([f"- {obj}" for obj in generate_content_section(topic, "objectives")])
        key_points = "\n".join([f"- {point}" for point in generate_content_section(topic, "key_points")])
        practice_exercises = "\n".join(
            [f"{i + 1}. {ex}" for i, ex in enumerate(generate_content_section(topic, "practice"))])

        content = f"""
Learning Objectives:
{learning_objectives}

Introduction:
{fake.paragraph(nb_sentences=3, variable_nb_sentences=True)}

Key Concepts:
{key_points}

Detailed Explanation:
{fake.paragraph(nb_sentences=4)}
{fake.paragraph(nb_sentences=3)}

Practice Exercises:
{practice_exercises}

Summary:
{fake.paragraph(nb_sentences=2)}
        """
        return content.strip()

    def generate_video_content():
        learning_objectives = "\n".join([f"- {obj}" for obj in generate_content_section(topic, "objectives")])
        key_points = "\n".join([f"- {point}" for point in generate_content_section(topic, "key_points")])

        content = f"""
Learning Objectives:
{learning_objectives}

Video Outline:
1. Introduction to {topic}
2. Core Concepts and Principles
3. Practical Demonstrations
4. Common Challenges and Solutions
5. Best Practices and Tips

Key Points to Remember:
{key_points}

After Watching:
- Practice the demonstrated techniques
- Complete the hands-on exercises
- Review the key concepts
        """
        return content.strip()

    def generate_quiz_content():
        quiz_topics = generate_content_section(topic, "key_points")
        questions = []
        for i, quiz_topic in enumerate(quiz_topics, 1):
            question = f"Question {i}: Regarding {quiz_topic}, explain how you would:"
        options = [
            f"A) {fake.sentence()}",
            f"B) {fake.sentence()}",
            f"C) {fake.sentence()}",
            f"D) {fake.sentence()}"
        ]
        questions.append(question + '\n' + '\n'.join(options))
        content = f"""Quiz Overview:
        This quiz will test your understanding of {topic}.

        {('').join(questions)}

        Note: Complete all questions and review your answers carefully."""
        return content.strip()

    content_generators = {
        'TEXT': generate_text_content,
        'VIDEO': generate_video_content,
        'QUIZ': generate_quiz_content
    }

    return content_generators[lesson_type]()


def get_valid_dates(course_created_at, course_deleted_at=None):
    """Generate valid dates based on course dates"""
    start_date = datetime.strptime(course_created_at, '%Y-%m-%d %H:%M:%S')
    if course_deleted_at:
        end_date = datetime.strptime(course_deleted_at, '%Y-%m-%d %H:%M:%S')
    else:
        end_date = datetime.now()

    created_at = fake.date_time_between(start_date=start_date, end_date=end_date)
    updated_at = fake.date_time_between(start_date=created_at, end_date=end_date)

    return created_at, updated_at


def determine_status(course_status, entity_dates, course_deleted_at):
    """Determine appropriate status based on course status and dates"""
    if course_status == 'ARCHIVED' or course_deleted_at:
        return 'ARCHIVED'
    elif course_status == 'PUBLISHED':
        return random.choice(['PUBLISHED'] * 7 + ['DRAFT'] * 3)  # 70% published, 30% draft
    else:
        return 'DRAFT'


def calculate_records_per_course(total_courses, target_chapters, target_lessons):
    """Calculate minimum number of chapters/lessons needed per course"""
    min_chapters_per_course = max(3, target_chapters // total_courses)
    max_chapters_per_course = min_chapters_per_course + 2

    min_lessons_per_chapter = max(4, target_lessons // (total_courses * min_chapters_per_course))
    max_lessons_per_chapter = min_lessons_per_chapter + 3

    return (min_chapters_per_course, max_chapters_per_course,
            min_lessons_per_chapter, max_lessons_per_chapter)


def insert_test_data(target_chapters=50, target_lessons=50):
    try:
        conn = connect_to_database()
        cursor = conn.cursor()

        # Clear existing data
        cursor.execute("SET FOREIGN_KEY_CHECKS = 0")
        cursor.execute("TRUNCATE TABLE lessons")
        cursor.execute("TRUNCATE TABLE chapters")
        cursor.execute("SET FOREIGN_KEY_CHECKS = 1")

        courses = get_course_data(cursor)
        total_courses = len(courses)

        # Calculate required records
        (min_chapters, max_chapters,
         min_lessons, max_lessons) = calculate_records_per_course(total_courses,
                                                                  target_chapters,
                                                                  target_lessons)

        chapters_created = 0
        lessons_created = 0

        print(f"""
Starting data generation with:
- Minimum {min_chapters} chapters per course
- {min_lessons}-{max_lessons} lessons per chapter
        """)

        for course in courses:
            course_id, course_title, course_status, course_created_at, course_deleted_at = course
            course_topic = extract_course_topic(course_title)
            num_chapters = random.randint(min_chapters, max_chapters)

            for chapter_order in range(1, num_chapters + 1):
                # Generate chapter
                chapter_created_at, chapter_updated_at = get_valid_dates(
                    course_created_at.strftime('%Y-%m-%d %H:%M:%S'),
                    course_deleted_at.strftime('%Y-%m-%d %H:%M:%S') if course_deleted_at else None
                )

                chapter_title = generate_chapter_title(course_topic)
                chapter_status = determine_status(course_status,
                                                  (chapter_created_at, chapter_updated_at),
                                                  course_deleted_at)

                chapter_sql = """
                INSERT INTO chapters (course_id, title, description, order_number, 
                                   status, created_at, updated_at, deleted_at)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
                """
                chapter_values = (
                    course_id,
                    chapter_title,
                    f"Comprehensive coverage of {chapter_title}",
                    chapter_order,
                    chapter_status,
                    chapter_created_at,
                    chapter_updated_at,
                    chapter_updated_at if chapter_status == 'ARCHIVED' else None
                )
                cursor.execute(chapter_sql, chapter_values)
                chapter_id = cursor.lastrowid
                chapters_created += 1

                # Generate lessons
                num_lessons = random.randint(min_lessons, max_lessons)

                for lesson_order in range(1, num_lessons + 1):
                    lesson_created_at, lesson_updated_at = get_valid_dates(
                        chapter_created_at.strftime('%Y-%m-%d %H:%M:%S'),
                        chapter_updated_at.strftime('%Y-%m-%d %H:%M:%S')
                    )

                    lesson_status = determine_status(chapter_status,
                                                     (lesson_created_at, lesson_updated_at),
                                                     chapter_updated_at if chapter_status == 'ARCHIVED' else None)

                    lesson_type = random.choice(['VIDEO', 'TEXT', 'QUIZ'])
                    lesson_title = generate_lesson_title(chapter_title, lesson_order, num_lessons)

                    lesson_sql = """
                    INSERT INTO lessons (chapter_id, title, content, order_number, type,
                                      status, created_at, updated_at, deleted_at)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
                    """
                    lesson_values = (
                        chapter_id,
                        lesson_title,
                        generate_lesson_content(lesson_type, lesson_title),
                        lesson_order,
                        lesson_type,
                        lesson_status,
                        lesson_created_at,
                        lesson_updated_at,
                        lesson_updated_at if lesson_status == 'ARCHIVED' else None
                    )
                    cursor.execute(lesson_sql, lesson_values)
                    lessons_created += 1

                if chapters_created % 10 == 0:
                    print(f"Progress: {chapters_created} chapters, {lessons_created} lessons created")

        conn.commit()
        print(f"""
Data generation completed successfully:
- {chapters_created} chapters created (Target: {target_chapters})
- {lessons_created} lessons created (Target: {target_lessons})
- Average lessons per chapter: {lessons_created / chapters_created:.1f}
- Generated with contextual titles and structured content
- Maintained proper relationships and data integrity
- All dates and statuses properly aligned

Chapter distribution:
- Minimum chapters per course: {min_chapters}
- Maximum chapters per course: {max_chapters}
- Average chapters per course: {chapters_created / total_courses:.1f}

Lesson distribution:
- Minimum lessons per chapter: {min_lessons}
- Maximum lessons per chapter: {max_lessons}
- Average lessons per chapter: {lessons_created / chapters_created:.1f}
        """)

    except mysql.connector.Error as err:
        print(f"Error: {err}")
        conn.rollback()
    finally:
        if conn.is_connected():
            cursor.close()
            conn.close()
            print("Database connection closed.")


if __name__ == "__main__":
    print("Starting chapter and lesson generation...")
    print("This will clear existing chapters and lessons before generating new ones.")
    try:
        insert_test_data(target_chapters=50, target_lessons=50)
    except Exception as e:
        print(f"An error occurred: {str(e)}")
    print("Process completed.")
</file>

<file path="src/main/resources/Python_Scripts/generate_courses_categories.py">
import mysql.connector
import random
from datetime import datetime, timedelta
from faker import Faker

# Initialize Faker
fake = Faker()

# Database configuration
db_config = {
    'host': 'localhost',
    'user': 'Huyvictory',
    'password': '12345',
    'database': 'onlinecoursemanagement'
}

def generate_unique_category_name(existing_names, base_name=None):
    """Generate a unique category name using Faker"""
    while True:
        if base_name:
            name = f"{base_name} {fake.word().capitalize()}"
        else:
            name_types = [
                lambda: f"{fake.job()} Training",
                lambda: f"{fake.word().capitalize()} Studies",
                lambda: f"Advanced {fake.word().capitalize()}",
                lambda: f"{fake.currency_name()} Management",
                lambda: f"{fake.job()} Development",
                lambda: f"Professional {fake.job()}",
                lambda: f"{fake.company_suffix()} Management",
                lambda: f"Digital {fake.word().capitalize()}",
                lambda: f"{fake.word().capitalize()} Technology",
                lambda: f"{fake.word().capitalize()} Innovation"
            ]
            name = random.choice(name_types)()

        if name not in existing_names and len(name) <= 100:
            existing_names.add(name)
            return name

def connect_to_database():
    try:
        return mysql.connector.connect(**db_config)
    except mysql.connector.Error as err:
        print(f"Error connecting to database: {err}")
        raise

def generate_random_dates():
    """Generate random created_at and updated_at dates"""
    start_date = datetime(2023, 1, 1)
    end_date = datetime(2024, 10, 26)

    created_at = fake.date_time_between(start_date=start_date, end_date=end_date)
    # updated_at should be between created_at and end_date
    updated_at = fake.date_time_between(start_date=created_at, end_date=end_date)

    return created_at, updated_at

def generate_course_description():
    return (f"This comprehensive course focuses on {fake.catch_phrase()}. "
            f"Learn essential skills in {fake.bs()}. "
            f"Master the fundamentals with hands-on projects and real-world applications. "
            f"By the end of this course, you'll be proficient in {fake.catch_phrase()}.")

def generate_categories(num_categories):
    categories = []
    existing_names = set()

    # Define main subject areas
    main_areas = [
        "Programming", "Business", "Design", "Marketing",
        "Technology", "Arts", "Engineering", "Communication",
        "Data Science", "Digital Media"
    ]

    # First, create categories based on main areas
    for area in main_areas:
        if len(categories) < num_categories:
            name = generate_unique_category_name(existing_names, area)
            created_at, updated_at = generate_random_dates()
            categories.append({
                'id': len(categories) + 1,
                'name': name,
                'created_at': created_at,
                'updated_at': updated_at,
                'deleted_at': None
            })

    # Then fill up remaining categories with random names
    while len(categories) < num_categories:
        name = generate_unique_category_name(existing_names)
        created_at, updated_at = generate_random_dates()
        categories.append({
            'id': len(categories) + 1,
            'name': name,
            'created_at': created_at,
            'updated_at': updated_at,
            'deleted_at': None
        })

    return categories

def generate_courses(num_courses, instructor_ids):
    courses = []
    existing_titles = set()

    course_prefixes = [
        "Mastering", "Advanced", "Introduction to", "Professional",
        "Complete Guide to", "Essential", "Practical", "Modern",
        "Fundamentals of", "Ultimate"
    ]

    for i in range(1, num_courses + 1):
        while True:
            prefix = random.choice(course_prefixes)
            title = f"{prefix} {fake.job()} {fake.word().capitalize()}"
            if title not in existing_titles and len(title) <= 255:
                existing_titles.add(title)
                break

        created_at, updated_at = generate_random_dates()
        status = random.choice(['DRAFT', 'PUBLISHED', 'ARCHIVED'])

        # Set deleted_at for ARCHIVED courses
        deleted_at = None
        if status == 'ARCHIVED':
            # deleted_at should be after created_at and updated_at
            deleted_at = fake.date_time_between(
                start_date=max(created_at, updated_at),
                end_date=datetime(2024, 10, 26)
            )

        courses.append({
            'id': i,
            'title': title,
            'description': generate_course_description(),
            'instructor_id': random.choice(instructor_ids),
            'status': status,
            'created_at': created_at,
            'updated_at': updated_at,
            'deleted_at': deleted_at
        })

    return courses

def insert_test_data():
    try:
        conn = connect_to_database()
        cursor = conn.cursor()

        # Clear existing data
        cursor.execute("SET FOREIGN_KEY_CHECKS = 0")
        cursor.execute("TRUNCATE TABLE course_categories")
        cursor.execute("TRUNCATE TABLE courses")
        cursor.execute("TRUNCATE TABLE categories")
        cursor.execute("SET FOREIGN_KEY_CHECKS = 1")

        # Get instructor IDs
        cursor.execute("""
            SELECT DISTINCT u.id 
            FROM users u 
            JOIN user_roles ur ON u.id = ur.user_id 
            JOIN roles r ON ur.role_id = r.id 
            WHERE r.name = 'INSTRUCTOR'
        """)
        instructor_ids = [row[0] for row in cursor.fetchall()]

        if not instructor_ids:
            print("No instructors found. Please add instructors to the database first.")
            return

        # Insert categories
        categories = generate_categories(50)
        category_sql = """
        INSERT INTO categories (id, name, created_at, updated_at, deleted_at)
        VALUES (%s, %s, %s, %s, %s)
        """
        for category in categories:
            cursor.execute(category_sql, (
                category['id'],
                category['name'],
                category['created_at'],
                category['updated_at'],
                category['deleted_at']
            ))

        # Insert courses
        courses = generate_courses(50, instructor_ids)
        course_sql = """
        INSERT INTO courses (id, title, description, instructor_id, status, 
                           created_at, updated_at, deleted_at)
        VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
        """
        for course in courses:
            cursor.execute(course_sql, (
                course['id'],
                course['title'],
                course['description'],
                course['instructor_id'],
                course['status'],
                course['created_at'],
                course['updated_at'],
                course['deleted_at']
            ))

        # Create course-category relationships
        course_category_sql = """
        INSERT INTO course_categories (course_id, category_id)
        VALUES (%s, %s)
        """

        for course in courses:
            # Only create relationships for non-archived courses
            if course['status'] != 'ARCHIVED':
                # Assign 1-3 random categories to each course
                num_categories = random.randint(1, 3)
                selected_categories = random.sample([cat['id'] for cat in categories], num_categories)

                for category_id in selected_categories:
                    cursor.execute(course_category_sql, (course['id'], category_id))

        conn.commit()
        print(f"""
Test data generated successfully:
- {len(categories)} unique categories inserted
- {len(courses)} unique courses inserted
- Course status breakdown:
  {sum(1 for c in courses if c['status'] == 'DRAFT')} DRAFT courses
  {sum(1 for c in courses if c['status'] == 'PUBLISHED')} PUBLISHED courses
  {sum(1 for c in courses if c['status'] == 'ARCHIVED')} ARCHIVED courses (with deleted_at set)
- Multiple course-category relationships created for non-archived courses

Sample courses:
{[(course['title'], course['status'], course['deleted_at'].strftime('%Y-%m-%d %H:%M:%S') if course['deleted_at'] else 'None') for course in courses[:5]]}
        """)

    except mysql.connector.Error as err:
        print(f"Error: {err}")
        conn.rollback()
    finally:
        if conn.is_connected():
            cursor.close()
            conn.close()

if __name__ == "__main__":
    insert_test_data()
</file>

<file path="src/main/resources/Python_Scripts/generate_users.py">
import mysql.connector
import random
from datetime import datetime, timedelta
import bcrypt
from faker import Faker
import unicodedata

# Initialize Faker
fake = Faker()

# Database configuration
db_config = {
    'host': 'localhost',
    'user': 'Huyvictory',
    'password': '12345',
    'database': 'onlinecoursemanagement'
}

# Fixed password for all users
FIXED_PASSWORD = "12345"


def remove_accents(input_str):
    """Remove diacritics from a string and return ASCII-only characters"""
    nfkd_form = unicodedata.normalize('NFKD', input_str)
    return u"".join([c for c in nfkd_form if not unicodedata.combining(c)])


def generate_password_hash(password):
    salt = bcrypt.gensalt()
    return bcrypt.hashpw(password.encode('utf-8'), salt).decode('utf-8')


def generate_random_date_2024():
    start_date = datetime(2024, 1, 1)
    end_date = datetime(2024, 12, 31)
    return fake.date_time_between(start_date=start_date, end_date=end_date)


def generate_unique_username(cursor, name):
    """Generate a unique username based on name"""
    # Remove accents and special characters, convert to lowercase
    base_username = remove_accents(name.lower().replace(' ', ''))
    username = base_username
    counter = 1

    while True:
        cursor.execute("SELECT COUNT(*) FROM users WHERE username = %s", (username,))
        if cursor.fetchone()[0] == 0:
            return username
        username = f"{base_username}{counter}"
        counter += 1


def generate_unique_email(cursor, name):
    """Generate a unique email based on name"""
    # Remove accents and special characters, convert to lowercase
    base_email = remove_accents(name.lower().replace(' ', '.'))
    email = f"{base_email}@{fake.free_email_domain()}"
    counter = 1

    while True:
        cursor.execute("SELECT COUNT(*) FROM users WHERE email = %s", (email,))
        if cursor.fetchone()[0] == 0:
            return email
        email = f"{base_email}{counter}@{fake.free_email_domain()}"
        counter += 1


def insert_user(cursor, role_type, count):
    users = []
    for i in range(count):
        # Generate profile based on role
        if role_type == "INSTRUCTOR":
            profile = {
                'name': fake.name(),
                'job': fake.job(),
                'profile': fake.text(max_nb_chars=200)
            }
        else:
            profile = {
                'name': fake.name()
            }

        # Generate unique username and email
        username = generate_unique_username(cursor, profile['name'])
        email = generate_unique_email(cursor, profile['name'])

        # Common user data
        created_at = generate_random_date_2024()
        updated_at = created_at
        password_hash = generate_password_hash(FIXED_PASSWORD)
        status = random.choices(['ACTIVE', 'INACTIVE'], weights=[90, 10])[0]

        # Insert user
        insert_user_sql = """
        INSERT INTO users (username, email, password_hash, real_name, status, created_at, updated_at)
        VALUES (%s, %s, %s, %s, %s, %s, %s)
        """
        user_values = (username, email, password_hash, profile['name'], status, created_at, updated_at)
        cursor.execute(insert_user_sql, user_values)
        user_id = cursor.lastrowid
        users.append({
            'id': user_id,
            'username': username,
            'email': email,
            'name': profile['name'],
            'created_at': created_at,
            'password': FIXED_PASSWORD  # Added to show in output
        })

        # Get role ID
        cursor.execute("SELECT id FROM roles WHERE name = %s", (role_type,))
        role_id = cursor.fetchone()[0]

        # Insert user_role
        insert_user_role_sql = """
        INSERT INTO user_roles (user_id, role_id, assigned_at)
        VALUES (%s, %s, %s)
        """
        user_role_values = (user_id, role_id, created_at)
        cursor.execute(insert_user_role_sql, user_role_values)

    return users


def main():
    try:
        # Connect to database
        conn = mysql.connector.connect(**db_config)
        cursor = conn.cursor()

        print(f"Starting user generation... (All users will have password: {FIXED_PASSWORD})\n")

        # Insert normal users
        print("Generating normal users...")
        normal_users = insert_user(cursor, "USER", 10)
        print(f"\nCreated {len(normal_users)} normal users:")
        for user in normal_users:
            print(f"- Name: {user['name']}")
            print(f"  Username: {user['username']}")
            print(f"  Email: {user['email']}")
            print(f"  Password: {user['password']}")
            print(f"  Created: {user['created_at']}")
            print()

        # Insert instructors
        print("\nGenerating instructors...")
        instructors = insert_user(cursor, "INSTRUCTOR", 10)
        print(f"\nCreated {len(instructors)} instructors:")
        for user in instructors:
            print(f"- Name: {user['name']}")
            print(f"  Username: {user['username']}")
            print(f"  Email: {user['email']}")
            print(f"  Password: {user['password']}")
            print(f"  Created: {user['created_at']}")
            print()

        # Commit the changes
        conn.commit()
        print("\nAll users created successfully!")
        print(f"Remember: All users have password: {FIXED_PASSWORD}")

    except mysql.connector.Error as err:
        print(f"Error: {err}")
        conn.rollback()
    finally:
        if 'conn' in locals() and conn.is_connected():
            cursor.close()
            conn.close()
            print("\nDatabase connection closed.")


if __name__ == "__main__":
    main()
</file>

</repository_files>

This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-11-02T14:46:22.142Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

For more information about Repopack, visit: https://github.com/yamadashy/repopack
</additional_info>

</file_summary>

<repository_structure>
.gitignore
.mvn/wrapper/maven-wrapper.properties
.repopackignore
pom.xml
repopack.config.json
src/main/java/com/online/course/management/project/aspect/LoggingAspect.java
src/main/java/com/online/course/management/project/aspect/RoleAuthorizationAspect.java
src/main/java/com/online/course/management/project/config/AdminInitializer.java
src/main/java/com/online/course/management/project/config/CacheConfig.java
src/main/java/com/online/course/management/project/config/DatabaseInitializer.java
src/main/java/com/online/course/management/project/config/JacksonConfig.java
src/main/java/com/online/course/management/project/config/SecurityConfig.java
src/main/java/com/online/course/management/project/config/WebConfig.java
src/main/java/com/online/course/management/project/constants/CategoryConstants.java
src/main/java/com/online/course/management/project/constants/CourseConstants.java
src/main/java/com/online/course/management/project/constants/UserConstants.java
src/main/java/com/online/course/management/project/controller/CategoryController.java
src/main/java/com/online/course/management/project/controller/CourseController.java
src/main/java/com/online/course/management/project/controller/CustomErrorController.java
src/main/java/com/online/course/management/project/controller/UserController.java
src/main/java/com/online/course/management/project/converter/StringToLocalDateTimeConverter.java
src/main/java/com/online/course/management/project/dto/CategoryDTOs.java
src/main/java/com/online/course/management/project/dto/CommonResponseDTOs.java
src/main/java/com/online/course/management/project/dto/CourseDTOS.java
src/main/java/com/online/course/management/project/dto/ErrorResponseDTO.java
src/main/java/com/online/course/management/project/dto/PaginationDto.java
src/main/java/com/online/course/management/project/dto/UserDTOs.java
src/main/java/com/online/course/management/project/entity/Category.java
src/main/java/com/online/course/management/project/entity/Course.java
src/main/java/com/online/course/management/project/entity/Role.java
src/main/java/com/online/course/management/project/entity/User.java
src/main/java/com/online/course/management/project/entity/UserRole.java
src/main/java/com/online/course/management/project/entity/UserRoleId.java
src/main/java/com/online/course/management/project/enums/CourseStatus.java
src/main/java/com/online/course/management/project/enums/RoleType.java
src/main/java/com/online/course/management/project/enums/UserStatus.java
src/main/java/com/online/course/management/project/exception/BaseException.java
src/main/java/com/online/course/management/project/exception/business/account/AccountException.java
src/main/java/com/online/course/management/project/exception/business/account/EmailAlreadyExistsException.java
src/main/java/com/online/course/management/project/exception/business/account/WrongEmailPasswordException.java
src/main/java/com/online/course/management/project/exception/business/BusinessException.java
src/main/java/com/online/course/management/project/exception/business/ForbiddenException.java
src/main/java/com/online/course/management/project/exception/business/InvalidRequestException.java
src/main/java/com/online/course/management/project/exception/business/InvalidRoleInfoException.java
src/main/java/com/online/course/management/project/exception/business/ResourceNotFoundException.java
src/main/java/com/online/course/management/project/exception/business/UnauthorizedException.java
src/main/java/com/online/course/management/project/exception/GlobalExceptionHandler.java
src/main/java/com/online/course/management/project/exception/technical/DatabaseException.java
src/main/java/com/online/course/management/project/exception/technical/ExternalServiceException.java
src/main/java/com/online/course/management/project/exception/technical/TechnicalException.java
src/main/java/com/online/course/management/project/filter/DebugFilter.java
src/main/java/com/online/course/management/project/filter/JwtAuthenticationFilter.java
src/main/java/com/online/course/management/project/mapper/CategoryMapper.java
src/main/java/com/online/course/management/project/mapper/CourseMapper.java
src/main/java/com/online/course/management/project/mapper/UserMapper.java
src/main/java/com/online/course/management/project/ProjectApplication.java
src/main/java/com/online/course/management/project/repository/ICategoryRepository.java
src/main/java/com/online/course/management/project/repository/ICourseRepository.java
src/main/java/com/online/course/management/project/repository/IRoleRepository.java
src/main/java/com/online/course/management/project/repository/IUserRepository.java
src/main/java/com/online/course/management/project/repository/IUserRoleRepository.java
src/main/java/com/online/course/management/project/security/CustomAccessDeniedHandler.java
src/main/java/com/online/course/management/project/security/CustomUserDetails.java
src/main/java/com/online/course/management/project/security/CustomUserDetailsService.java
src/main/java/com/online/course/management/project/security/JwtAuthenticationEntryPoint.java
src/main/java/com/online/course/management/project/security/JwtUtil.java
src/main/java/com/online/course/management/project/security/RequiredRole.java
src/main/java/com/online/course/management/project/security/UserSecurity.java
src/main/java/com/online/course/management/project/service/impl/CategoryServiceImpl.java
src/main/java/com/online/course/management/project/service/impl/CourseServiceImpl.java
src/main/java/com/online/course/management/project/service/impl/UserServiceImpl.java
src/main/java/com/online/course/management/project/service/interfaces/ICategoryService.java
src/main/java/com/online/course/management/project/service/interfaces/ICourseService.java
src/main/java/com/online/course/management/project/service/interfaces/IUserService.java
src/main/java/com/online/course/management/project/utils/category/CategoryServiceUtils.java
src/main/java/com/online/course/management/project/utils/exception/GlobalExceptionUtils.java
src/main/java/com/online/course/management/project/utils/generator/JwtSecretGenerator.java
src/main/java/com/online/course/management/project/utils/generator/PasswordHashGenerator.java
src/main/java/com/online/course/management/project/utils/user/UserControllerUtils.java
src/main/java/com/online/course/management/project/utils/user/UserServiceUtils.java
src/main/resources/application.properties
src/main/resources/db/migration/V10__Update_non_admin_passwords.sql
src/main/resources/db/migration/V11__Update_non_admin_passwords.sql
src/main/resources/db/migration/V2__Update_User_table.sql
src/main/resources/db/migration/V3__Add_status_to_users.sql
src/main/resources/db/migration/V4__Add_course_and_category_tables.sql
src/main/resources/db/migration/V5__Add_indexes_to_course_and_category.sql
src/main/resources/db/migration/V6__Add_course_status_validation.sql
src/main/resources/db/migration/V7__Add_course_and_category_triggers.sql
src/main/resources/db/migration/V8__Make_instructor_id_nullable.sql
src/main/resources/db/migration/V9__Add_course_archive_category_trigger.sql
src/main/resources/Python_Scripts/generate_courses_categories.py
src/main/resources/Python_Scripts/generate_users.py
src/test/java/com/online/course/management/project/config/SecurityTestConfig.java
src/test/java/com/online/course/management/project/controller/UserControllerTest.java
src/test/java/com/online/course/management/project/dto/UserDTOsValidationTest.java
src/test/java/com/online/course/management/project/ProjectApplicationTests.java
src/test/java/com/online/course/management/project/service/impl/UserServiceImplTest.java
src/test/resources/application.properties
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path=".gitignore">
HELP.md
target/
!.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/
</file>

<file path=".mvn/wrapper/maven-wrapper.properties">
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.9/apache-maven-3.9.9-bin.zip
</file>

<file path=".repopackignore">
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/

target
mvnw
mvnw.cmd
</file>

<file path="pom.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.1.5</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.online.course.management</groupId>
    <artifactId>project</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>Project</name>
    <description>Project</description>
    <url/>
    <licenses>
        <license/>
    </licenses>
    <developers>
        <developer/>
    </developers>
    <scm>
        <connection/>
        <developerConnection/>
        <tag/>
        <url/>
    </scm>
    <properties>
        <java.version>17</java.version>
        <mysql.version>8.0.33</mysql.version>
        <junit-jupiter.version>5.9.3</junit-jupiter.version>
        <mockito.version>5.3.1</mockito.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-core</artifactId>
        </dependency>
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-mysql</artifactId>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.11.5</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-cache</artifactId>
        </dependency>
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>1.5.5.Final</version>
        </dependency>
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct-processor</artifactId>
            <version>1.5.5.Final</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>com.github.ben-manes.caffeine</groupId>
            <artifactId>caffeine</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-aop</artifactId>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.datatype</groupId>
            <artifactId>jackson-datatype-jsr310</artifactId>
        </dependency>

        <!-- Test dependencies -->
        <!-- Spring Boot Starter Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.flywaydb</groupId>
                <artifactId>flyway-maven-plugin</artifactId>
                <version>9.22.3</version>
                <configuration>
                    <url>jdbc:mysql://localhost:3306/onlinecoursemanagement</url>
                    <user>Huyvictory</user>
                    <password>12345</password>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>3.1.2</version>
                <configuration>
                    <argLine>
                        -XX:+EnableDynamicAgentLoading
                        --add-opens java.base/java.lang=ALL-UNNAMED
                        --add-opens java.base/java.util=ALL-UNNAMED
                        --add-opens java.base/java.time=ALL-UNNAMED
                        -Xshare:off
                    </argLine>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>
</file>

<file path="repopack.config.json">
{
  "output": {
    "filePath": "repopack-output.txt",
    "style": "xml",
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  }
}
</file>

<file path="src/main/java/com/online/course/management/project/aspect/LoggingAspect.java">
package com.online.course.management.project.aspect;

import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

@Aspect
@Component
public class LoggingAspect {
    private static final Logger logger = LoggerFactory.getLogger(LoggingAspect.class);

    @Pointcut("execution(* com.online.course.management.project.controller.*.*(..))")
    public void controllerMethods() {
    }

    @Pointcut("execution(* com.online.course.management.project.service.*.*(..))")
    public void serviceMethods() {
    }

    @Around("controllerMethods() || serviceMethods()")
    public Object logMethodExecution(ProceedingJoinPoint joinPoint) throws Throwable {
        String className = joinPoint.getSignature().getDeclaringTypeName();
        String methodName = joinPoint.getSignature().getName();

        MDC.put("class", className);
        MDC.put("method", methodName);

        logger.info("Entering: classname={}, method={}", className, methodName);

        long startTime = System.currentTimeMillis();
        Object result = null;
        try {
            result = joinPoint.proceed();
            return result;
        } catch (Exception e) {
            logger.error("Exception in {}.{}: {}", className, methodName, e.getMessage());
            throw e;
        } finally {
            long endTime = System.currentTimeMillis();
            logger.info("Exiting: {}.{}. Execution time: {} ms", className, methodName, (endTime - startTime));
            MDC.clear();
        }
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/aspect/RoleAuthorizationAspect.java">
package com.online.course.management.project.aspect;

import com.online.course.management.project.exception.business.ForbiddenException;
import com.online.course.management.project.exception.business.UnauthorizedException;
import com.online.course.management.project.security.CustomUserDetails;
import com.online.course.management.project.security.RequiredRole;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;

import java.util.Arrays;
import java.util.Set;
import java.util.stream.Collectors;

@Aspect
@Component
public class RoleAuthorizationAspect {

    private static final Logger logger = LoggerFactory.getLogger(RoleAuthorizationAspect.class);

    @Around("@annotation(requiredRole)")
    public Object authorizeRole(ProceedingJoinPoint joinPoint, RequiredRole requiredRole) throws Throwable {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();

        if (authentication == null || !authentication.isAuthenticated()) {
            logger.warn("Unauthorized access attempt: User is not authenticated");
            throw new UnauthorizedException("User is not authenticated");
        }

        CustomUserDetails userDetails = (CustomUserDetails) authentication.getPrincipal();
        Set<String> userRoles = userDetails.getAuthorities().stream()
                .map(a -> a.getAuthority().replace("ROLE_", ""))
                .collect(Collectors.toSet());

        logger.debug("User roles: {}", userRoles);
        logger.debug("Required roles: {}", Arrays.toString(requiredRole.value()));

        boolean hasRequiredRole = Arrays.stream(requiredRole.value())
                .anyMatch(userRoles::contains);

        if (!hasRequiredRole) {
            logger.warn("Forbidden access attempt: User {} does not have the required role", userDetails.getUsername());
            throw new ForbiddenException("User does not have the required role");
        }

        logger.info("Access granted to user {} for method {}", userDetails.getUsername(), joinPoint.getSignature().getName());
        return joinPoint.proceed();
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/config/AdminInitializer.java">
package com.online.course.management.project.config;

import com.online.course.management.project.entity.Role;
import com.online.course.management.project.entity.User;
import com.online.course.management.project.enums.RoleType;
import com.online.course.management.project.repository.IRoleRepository;
import com.online.course.management.project.repository.IUserRepository;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.core.annotation.Order;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

@Component
@Order(2)
@Slf4j
public class AdminInitializer implements CommandLineRunner {
    private final IUserRepository userRepository;
    private final IRoleRepository roleRepository;
    private final PasswordEncoder passwordEncoder;

    @Autowired
    public AdminInitializer(IUserRepository userRepository, IRoleRepository roleRepository, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.roleRepository = roleRepository;
        this.passwordEncoder = passwordEncoder;
    }

    @Override
    @Transactional
    public void run(String... args) throws Exception {
        if (!userRepository.existsByEmail("admin@gmail.com")) {
            User adminUser = new User();
            adminUser.setUsername("admin");
            adminUser.setEmail("admin@gmail.com");
            adminUser.setPasswordHash(passwordEncoder.encode("admin"));
            adminUser.setRealName("Admin User");

            Role adminRole = roleRepository.findByName(RoleType.ADMIN)
                    .orElseThrow(() -> new RuntimeException("Admin role not found"));
            adminUser.addRole(adminRole);

            userRepository.save(adminUser);

            log.info("Admin user created successfully.");
        } else {
            log.info("Admin user already exists.");
        }
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/config/CacheConfig.java">
package com.online.course.management.project.config;

import com.github.benmanes.caffeine.cache.Caffeine;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.cache.caffeine.CaffeineCacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.concurrent.TimeUnit;

@Configuration
@EnableCaching
public class CacheConfig {

    @Bean
    public Caffeine caffeineConfig() {
        return Caffeine.newBuilder()
                .expireAfterWrite(60, TimeUnit.MINUTES)
                .initialCapacity(100)
                .maximumSize(500);
    }

    @Bean
    public CacheManager cacheManager(Caffeine caffeine) {
        CaffeineCacheManager caffeineCacheManager = new CaffeineCacheManager();
        caffeineCacheManager.setCaffeine(caffeine);
        return caffeineCacheManager;
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/config/DatabaseInitializer.java">
package com.online.course.management.project.config;

import com.online.course.management.project.entity.Role;
import com.online.course.management.project.enums.RoleType;
import com.online.course.management.project.repository.IRoleRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

@Component
@Order(1)
public class DatabaseInitializer implements CommandLineRunner {
    private final IRoleRepository roleRepository;

    @Autowired
    public DatabaseInitializer(IRoleRepository roleRepository) {
        this.roleRepository = roleRepository;
    }

    @Override
    public void run(String... args) {
        initializeRoles();
    }

    private void initializeRoles() {
        for (RoleType roleType : RoleType.values()) {
            if (!roleRepository.existsByName(roleType)) {
                Role role = new Role();
                role.setName(roleType);
                roleRepository.save(role);
            }
        }
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/config/JacksonConfig.java">
package com.online.course.management.project.config;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;

import java.time.ZoneId;
import java.util.TimeZone;

@Configuration
public class JacksonConfig {

    @Bean
    @Primary
    public ObjectMapper objectMapper() {
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

        // Configure to ignore unknown properties
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, true);

        // Add additional configuration for better handling of Java 8 features
        objectMapper.configure(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS, false);
        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        objectMapper.setTimeZone(TimeZone.getTimeZone(ZoneId.systemDefault()));

        return objectMapper;

    }

    @Bean
    public MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter(ObjectMapper objectMapper) {
        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
        converter.setObjectMapper(objectMapper);
        return converter;
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/config/SecurityConfig.java">
package com.online.course.management.project.config;

import com.online.course.management.project.filter.JwtAuthenticationFilter;
import com.online.course.management.project.security.CustomAccessDeniedHandler;
import com.online.course.management.project.security.CustomUserDetailsService;
import com.online.course.management.project.security.JwtAuthenticationEntryPoint;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.ProviderManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@Slf4j
public class SecurityConfig {

    private static final Logger logger = LoggerFactory.getLogger(SecurityConfig.class);

    private final CustomUserDetailsService userDetailsService;
    private final JwtAuthenticationFilter jwtAuthenticationFilter;
    private final JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;

    @Autowired
    public SecurityConfig(CustomUserDetailsService userDetailsService, JwtAuthenticationFilter jwtAuthenticationFilter, JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint) {
        this.userDetailsService = userDetailsService;
        this.jwtAuthenticationFilter = jwtAuthenticationFilter;
        this.jwtAuthenticationEntryPoint = jwtAuthenticationEntryPoint;
    }

    @Bean
    public AuthenticationManager authenticationManager(HttpSecurity http) throws Exception {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return new ProviderManager(authProvider);
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        logger.info("Configuring security filter chain");
        http
                .csrf(csrf -> {
                    csrf.disable();
                    logger.info("CSRF is disabled");
                })
                .cors(cors -> cors.disable())
                .sessionManagement(session -> {
                    session.sessionCreationPolicy(SessionCreationPolicy.STATELESS);
                    logger.info("Session management set to STATELESS");
                })
                .authorizeHttpRequests(authz -> authz
                        .requestMatchers("/api/v1/users/register", "/api/v1/users/login", "/error", "/api/v1/courses/*").permitAll()
                        .anyRequest().authenticated()
                )
                .userDetailsService(userDetailsService)
                .exceptionHandling(ex -> ex
                        .authenticationEntryPoint(jwtAuthenticationEntryPoint)
                        .accessDeniedHandler(new CustomAccessDeniedHandler())
                )
                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        logger.info("Security configuration completed");
        return http.build();
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/config/WebConfig.java">
package com.online.course.management.project.config;

import com.online.course.management.project.converter.StringToLocalDateTimeConverter;
import org.springframework.context.annotation.Configuration;
import org.springframework.format.FormatterRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addFormatters(FormatterRegistry registry) {
        registry.addConverter(new StringToLocalDateTimeConverter());
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/constants/CategoryConstants.java">
package com.online.course.management.project.constants;

public class CategoryConstants {
    public static final String BASE_PATH = "/api/v1/categories";
    public static final String RESTORE_PATH = "/{id}/restore";
    public static final String SEARCH_PATH = "/search";
    public static final String PATH_VARIABLE_PATH = "/{id}";
}
</file>

<file path="src/main/java/com/online/course/management/project/constants/CourseConstants.java">
package com.online.course.management.project.constants;

public class CourseConstants {
    public static final String BASE_PATH = "/api/v1/courses";
    public static final String CREATE_PATH = "/create";
    public static final String UPDATE_PATH = "{id}/update";
    public static final String ARCHIVE_PATH = "{id}/archive";
    public static final String UNARCHIVE_PATH = "{id}/unarchive";
    public static final String SEARCH_PATH = "/search";
    public static final String SEARCH_COURSE_INSTRUCTOR_PATH = "/search-instructor";
    public static final String SEARCH_COURSE_STATUS_PATH = "/search-status";
    public static final String SEARCH_LATEST_COURSES_PATH = "/search-latest";
    public static final String PATH_VARIABLE_PATH = "/{id}";
}
</file>

<file path="src/main/java/com/online/course/management/project/constants/UserConstants.java">
package com.online.course.management.project.constants;

public class UserConstants {
    public static final String BASE_PATH = "/api/v1/users";
    public static final String REGISTER_PATH = "/register";
    public static final String LOGIN_PATH = "/login";
    public static final String PROFILE_PATH = "/profile";
    public static final String UPDATE_ROLES_PATH = "/{id}/roles";
    public static final String SEARCH_PATH = "/search";
    public static final String ALL_PATH = "/all";
    public static final String PATH_VARIABLE_PATH = "/{id}";

}
</file>

<file path="src/main/java/com/online/course/management/project/controller/CategoryController.java">
package com.online.course.management.project.controller;

import com.online.course.management.project.constants.CategoryConstants;
import com.online.course.management.project.dto.CategoryDTOs;
import com.online.course.management.project.dto.CommonResponseDTOs;
import com.online.course.management.project.dto.PaginationDto;
import com.online.course.management.project.security.RequiredRole;
import com.online.course.management.project.service.interfaces.ICategoryService;
import jakarta.validation.Valid;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping(CategoryConstants.BASE_PATH)
@Slf4j
public class CategoryController {

    private final ICategoryService categoryService;

    @Autowired
    public CategoryController(ICategoryService categoryService) {
        this.categoryService = categoryService;
    }

    @PostMapping
    @RequiredRole({"ADMIN"})
    public ResponseEntity<CategoryDTOs.CategoryResponseDto> createCategory(@Valid @RequestBody CategoryDTOs.CreateCategoryDTO request) {
        log.info("Creating new category with name: {}", request.getName());

        CategoryDTOs.CategoryResponseDto response = categoryService.createCategory(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @PutMapping(CategoryConstants.PATH_VARIABLE_PATH)
    @RequiredRole({"ADMIN"})
    public ResponseEntity<CategoryDTOs.CategoryResponseDto> updateCategory(
            @PathVariable Long id,
            @Valid @RequestBody CategoryDTOs.UpdateCategoryDTO request) {
        log.info("Updating category with id: {}", id);
        CategoryDTOs.CategoryResponseDto response = categoryService.updateCategory(id, request);
        return ResponseEntity.ok(response);
    }

    @DeleteMapping(CategoryConstants.PATH_VARIABLE_PATH)
    @RequiredRole({"ADMIN"})
    public ResponseEntity<CommonResponseDTOs.DeleteSuccessfullyDTO> deleteCategory(@PathVariable Long id) {
        log.info("Deleting category with id: {}", id);
        categoryService.deleteCategory(id);

        CommonResponseDTOs.DeleteSuccessfullyDTO response = new CommonResponseDTOs.DeleteSuccessfullyDTO("Deleted category with id: " + id);
        return ResponseEntity.status(HttpStatus.OK).body(response);

    }

    @PostMapping(CategoryConstants.RESTORE_PATH)
    @RequiredRole({"ADMIN"})
    public ResponseEntity<CategoryDTOs.RestoreCategoryResponseDTO> restoreCategory(@PathVariable Long id) {
        log.info("Restoring category with id: {}", id);
        categoryService.restoreCategory(id);

        CategoryDTOs.RestoreCategoryResponseDTO response = new CategoryDTOs.RestoreCategoryResponseDTO("Restored category successfully");

        return ResponseEntity.ok().body(response);
    }

    @GetMapping(CategoryConstants.PATH_VARIABLE_PATH)
    public ResponseEntity<CategoryDTOs.CategoryResponseDto> getCategoryById(@PathVariable Long id) {
        log.info("Fetching category with id: {}", id);
        CategoryDTOs.CategoryResponseDto response = categoryService.getCategoryById(id);
        return ResponseEntity.ok(response);
    }

    @PostMapping(CategoryConstants.SEARCH_PATH)
    public ResponseEntity<PaginationDto.PaginationResponseDto<CategoryDTOs.CategoryResponseDto>> searchCategories(
            @Valid @RequestBody CategoryDTOs.CategorySearchDTO searchRequest) {
        log.info("Searching categories with criteria: {}", searchRequest);

        var categoriesPage = categoryService.searchCategories(CategoryDTOs.CategorySearchDTO.builder()
                .name(searchRequest.getName())
                .archived(searchRequest.getArchived())
                .fromDate(searchRequest.getFromDate())
                .toDate(searchRequest.getToDate())
                .build(), searchRequest.toPageable());

        var response = new PaginationDto.PaginationResponseDto<>(
                categoriesPage.getContent(),
                categoriesPage.getNumber() + 1,
                categoriesPage.getSize(),
                categoriesPage.getTotalElements()
        );

        return ResponseEntity.ok(response);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/controller/CourseController.java">
package com.online.course.management.project.controller;

import com.online.course.management.project.constants.CourseConstants;
import com.online.course.management.project.dto.CourseDTOS;
import com.online.course.management.project.dto.PaginationDto;
import com.online.course.management.project.enums.CourseStatus;
import com.online.course.management.project.security.RequiredRole;
import com.online.course.management.project.service.interfaces.ICourseService;
import jakarta.validation.Valid;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping(CourseConstants.BASE_PATH)
@Slf4j
public class CourseController {

    private final ICourseService courseService;

    @Autowired
    public CourseController(ICourseService courseService) {
        this.courseService = courseService;
    }

    @PostMapping(CourseConstants.CREATE_PATH)
    @RequiredRole({"ADMIN"})
    public ResponseEntity<CourseDTOS.CourseDetailsResponseDto> createCourse(@RequestBody @Valid CourseDTOS.CreateCourseRequestDTO request) {

        CourseDTOS.CourseDetailsResponseDto createdCourse = courseService.createCourse(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(createdCourse);
    }

    @PutMapping(CourseConstants.UPDATE_PATH)
    @RequiredRole({"ADMIN", "INSTRUCTOR"})
    public ResponseEntity<CourseDTOS.CourseDetailsResponseDto> updateCourse(@PathVariable @Valid long id, @RequestBody @Valid CourseDTOS.UpdateCourseRequestDTO request) {
        CourseDTOS.CourseDetailsResponseDto updatedCourse = courseService.updateCourse(id, request);
        return ResponseEntity.ok(updatedCourse);
    }

    @PatchMapping(CourseConstants.ARCHIVE_PATH)
    @RequiredRole({"ADMIN"})
    public ResponseEntity<String> archiveCourse(@PathVariable @Valid long id) {
        courseService.archiveCourse(id);
        return ResponseEntity.ok().body("Course archived successfully");
    }

    @PatchMapping(CourseConstants.UNARCHIVE_PATH)
    @RequiredRole({"ADMIN"})
    public ResponseEntity<String> unarchiveCourse(@PathVariable @Valid long id) {
        courseService.unarchiveCourse(id);
        return ResponseEntity.ok().body("Course unarchived successfully");
    }

    @PostMapping(CourseConstants.PATH_VARIABLE_PATH)
    public ResponseEntity<CourseDTOS.CourseDetailsResponseDto> getCourseById(@PathVariable @Valid long id) {
        log.info("Fetching course with id: {}", id);
        CourseDTOS.CourseDetailsResponseDto response = courseService.getCourseById(id);
        return ResponseEntity.ok(response);
    }

    @PostMapping(CourseConstants.SEARCH_COURSE_INSTRUCTOR_PATH)
    public ResponseEntity<PaginationDto.PaginationResponseDto<CourseDTOS.CourseDetailsResponseDto>> searchCoursesByInstructor(
            @Valid @RequestBody CourseDTOS.SearchInstructorCourseRequestDTO searchRequest) {
        log.info("Searching courses with criteria: {}, page: {}, size: {}",
                searchRequest, searchRequest.getPage(), searchRequest.getLimit());

        var coursesPage = courseService.getCoursesByInstructor(searchRequest.getInstructorId(), searchRequest.isIncludeArchived(), searchRequest.toPageable());

        var response = new PaginationDto.PaginationResponseDto<>(
                coursesPage.getContent(),
                coursesPage.getNumber() + 1,
                coursesPage.getSize(),
                coursesPage.getTotalElements()
        );

        return ResponseEntity.ok(response);
    }

    @PostMapping(CourseConstants.SEARCH_COURSE_STATUS_PATH)
    public ResponseEntity<PaginationDto.PaginationResponseDto<CourseDTOS.CourseDetailsResponseDto>> searchCoursesByStatus(
            @Valid @RequestBody CourseDTOS.SearchStatusRequestDTO searchRequest) {
        log.info("Searching courses with status: {}, page: {}, size: {}",
                searchRequest, searchRequest.getPage(), searchRequest.getLimit());

        var coursesPage = courseService.getCoursesByStatus(CourseStatus.valueOf(searchRequest.getStatus()), searchRequest.toPageable());

        var response = new PaginationDto.PaginationResponseDto<>(
                coursesPage.getContent(),
                coursesPage.getNumber() + 1,
                coursesPage.getSize(),
                coursesPage.getTotalElements()
        );

        return ResponseEntity.ok(response);
    }

    @PostMapping(CourseConstants.SEARCH_LATEST_COURSES_PATH)
    public ResponseEntity<List<CourseDTOS.CourseDetailsResponseDto>> searchLatestCourses(
            @Valid @RequestBody CourseDTOS.SearchLatestCoursesRequestDTO searchRequest) {
        log.info("Searching latest courses with limit: {}", searchRequest.getLimit());

        var listLatestCourses = courseService.getLatestCourses(searchRequest.getLimit());

        return ResponseEntity.ok(listLatestCourses);
    }

    @PostMapping(CourseConstants.SEARCH_PATH)
    public ResponseEntity<PaginationDto.PaginationResponseDto<CourseDTOS.CourseDetailsResponseDto>> searchCourses(
            @Valid @RequestBody CourseDTOS.SearchCourseRequestDTO searchRequest) {

        var coursesPage = courseService.searchCourses(searchRequest, searchRequest.toPageable());

        var response = new PaginationDto.PaginationResponseDto<>(
                coursesPage.getContent(),
                coursesPage.getNumber() + 1,
                coursesPage.getSize(),
                coursesPage.getTotalElements()
        );

        return ResponseEntity.ok(response);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/controller/CustomErrorController.java">
package com.online.course.management.project.controller;

import com.online.course.management.project.dto.ErrorResponseDTO;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.web.servlet.error.ErrorController;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.HttpRequestMethodNotSupportedException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.NoHandlerFoundException;

@ControllerAdvice
@Slf4j
public class CustomErrorController implements ErrorController {

    @ExceptionHandler(NoHandlerFoundException.class)
    public ResponseEntity<ErrorResponseDTO> handleNoHandlerFound(NoHandlerFoundException ex) {
        log.warn("No handler found for {} {}", ex.getHttpMethod(), ex.getRequestURL());

        ErrorResponseDTO errorResponse = new ErrorResponseDTO(
                String.format("The requested resource '%s' was not found", ex.getRequestURL()),
                HttpStatus.NOT_FOUND.value()
        );

        return new ResponseEntity<>(errorResponse, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)
    public ResponseEntity<ErrorResponseDTO> handleMethodNotSupported(HttpRequestMethodNotSupportedException ex) {
        log.warn("Method not supported: {}", ex.getMessage());

        ErrorResponseDTO errorResponse = new ErrorResponseDTO(
                String.format("The %s method is not supported for this resource. Supported methods are: %s",
                        ex.getMethod(), String.join(", ", ex.getSupportedMethods())),
                HttpStatus.METHOD_NOT_ALLOWED.value()
        );

        return new ResponseEntity<>(errorResponse, HttpStatus.METHOD_NOT_ALLOWED);
    }

    // Add a method to handle basic error paths
    @RequestMapping("/error")
    public ResponseEntity<ErrorResponseDTO> handleError() {
        ErrorResponseDTO errorResponse = new ErrorResponseDTO(
                "An error occurred processing the request",
                HttpStatus.INTERNAL_SERVER_ERROR.value()
        );
        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/controller/UserController.java">
package com.online.course.management.project.controller;

import com.online.course.management.project.constants.UserConstants;
import com.online.course.management.project.dto.PaginationDto;
import com.online.course.management.project.dto.UserDTOs;
import com.online.course.management.project.enums.RoleType;
import com.online.course.management.project.mapper.UserMapper;
import com.online.course.management.project.security.CustomUserDetails;
import com.online.course.management.project.security.JwtUtil;
import com.online.course.management.project.security.RequiredRole;
import com.online.course.management.project.service.interfaces.IUserService;
import com.online.course.management.project.utils.user.UserControllerUtils;
import com.online.course.management.project.utils.user.UserServiceUtils;
import jakarta.validation.Valid;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

import java.util.Optional;
import java.util.Set;

@RestController
@RequestMapping(UserConstants.BASE_PATH)
@Slf4j
public class UserController {

    private final IUserService userService;
    private final UserMapper userMapper;
    private final JwtUtil jwtUtil;
    private final UserControllerUtils userControllerUtils;

    @Autowired
    public UserController(IUserService userService, UserMapper userMapper, JwtUtil jwtUtil, UserControllerUtils userControllerUtils) {
        this.userService = userService;
        this.userMapper = userMapper;
        this.jwtUtil = jwtUtil;
        this.userControllerUtils = userControllerUtils;
    }

    @PostMapping(UserConstants.REGISTER_PATH)
    public ResponseEntity<UserDTOs.UserResponseDto> registerUser(@Valid @RequestBody UserDTOs.UserRegistrationDto registrationDto) {
        log.info("Received registration request for email: {}", registrationDto.getEmail());
        UserDTOs.UserResponseDto responseDto = userService.registerUser(registrationDto);
        return ResponseEntity.status(HttpStatus.CREATED).body(responseDto);
    }

    @PostMapping(UserConstants.LOGIN_PATH)
    public ResponseEntity<UserDTOs.JwtResponseDto> loginUser(@Valid @RequestBody UserDTOs.UserLoginDto loginDto) {
        log.info("Received login request for username/email: {}", loginDto.getUsernameOrEmail());
        Authentication authentication = userControllerUtils.authenticate(loginDto.getUsernameOrEmail(), loginDto.getPassword());
        String jwt = jwtUtil.generateToken((CustomUserDetails) authentication.getPrincipal());
        return ResponseEntity.ok(new UserDTOs.JwtResponseDto(jwt));
    }

    @GetMapping(UserConstants.PATH_VARIABLE_PATH)
    @RequiredRole({"USER", "ADMIN"})
    public ResponseEntity<UserDTOs.UserResponseDto> getUserById(@PathVariable Long id) {
        log.info("Fetching user with id: {}", id);
        return userService.getUserById(id)
                .map(user -> ResponseEntity.ok(userMapper.toDto(user)))
                .orElse(ResponseEntity.notFound().build());
    }

    @PutMapping(UserConstants.PROFILE_PATH)
    public ResponseEntity<UserDTOs.UserResponseDto> updateUserProfile(@Valid @RequestBody UserDTOs.UpdateProfileDto updateProfileDto) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        CustomUserDetails userDetails = (CustomUserDetails) authentication.getPrincipal();
        Long userId = userDetails.getId();

        log.info("Updating profile for user id: {}", userId);
        UserDTOs.UserResponseDto updatedUser = userService.updateUserProfile(userId, updateProfileDto);
        return ResponseEntity.ok(updatedUser);
    }

    @PutMapping(UserConstants.UPDATE_ROLES_PATH)
    @RequiredRole({"ADMIN"})
    public ResponseEntity<UserDTOs.RoleUpdateResponseDto> updateUserRoles(@PathVariable Long id, @Valid @RequestBody UserDTOs.UpdateUserRolesDto updateUserRolesDto) {
        log.info("Updating roles for user id: {}", id);

        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        CustomUserDetails currentUser = (CustomUserDetails) authentication.getPrincipal();

        Set<RoleType> validRoles = userControllerUtils.validateRoles(updateUserRolesDto.getRoles());

        var updatedRoles = userService.updateUserRoles(id, validRoles, currentUser.getId());

        UserDTOs.RoleUpdateResponseDto responseDto = new UserDTOs.RoleUpdateResponseDto(
                "Roles updated successfully",
                updatedRoles
        );
        return ResponseEntity.ok().body(responseDto);
    }

    @GetMapping(UserConstants.ALL_PATH)
    @RequiredRole({"ADMIN"})
    public ResponseEntity<PaginationDto.PaginationResponseDto> getAllUsers(@Valid PaginationDto.PaginationRequestDto paginationRequestDto) {
        int page = paginationRequestDto.getPage();
        int limit = paginationRequestDto.getLimit();

        log.info("Fetching all users with roles, page: {}, limit: {}", page, limit);


        Pageable pageable = PageRequest.of(page - 1, limit);
        Page<UserDTOs.UserWithRolesResponseDto> users = userService.getAllUsers(paginationRequestDto.toPageable());
        long totalUsers = userService.countUsers(Optional.empty());

        PaginationDto.PaginationResponseDto<UserDTOs.UserWithRolesResponseDto> response = new PaginationDto.PaginationResponseDto<>(
                users.getContent(),
                users.getNumber() + 1,
                users.getSize(),
                totalUsers
        );

        return ResponseEntity.ok().body(response);
    }

    @GetMapping(UserConstants.SEARCH_PATH)
    @RequiredRole({"ADMIN"})
    public ResponseEntity<PaginationDto.PaginationResponseDto<UserDTOs.UserWithRolesResponseDto>> searchUsers(
            @Valid UserDTOs.UserSearchRequestDto searchRequest,
            @Valid PaginationDto.PaginationRequestDto paginationRequest) {

        log.info("Searching users with criteria: {}, page: {}, size: {}",
                searchRequest, paginationRequest.getPage(), paginationRequest.getLimit());

        Page<UserDTOs.UserWithRolesResponseDto> usersPage = userService.searchUsers(
                searchRequest, paginationRequest.toPageable());
        long totalSearchedUsers = userService.countUsers(Optional.of(searchRequest));

        PaginationDto.PaginationResponseDto<UserDTOs.UserWithRolesResponseDto> response = new PaginationDto.PaginationResponseDto<>(
                usersPage.getContent(),
                usersPage.getNumber() + 1,
                usersPage.getSize(),
                totalSearchedUsers
        );

        return ResponseEntity.ok(response);
    }

    @DeleteMapping(UserConstants.PATH_VARIABLE_PATH)
    @RequiredRole({"ADMIN"})
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        log.info("Deleting user with id: {}", id);
        userService.softDeleteUser(id);
        return ResponseEntity.noContent().build();
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/converter/StringToLocalDateTimeConverter.java">
package com.online.course.management.project.converter;

import com.online.course.management.project.exception.business.InvalidRequestException;
import org.springframework.core.convert.converter.Converter;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeFormatterBuilder;
import java.time.format.DateTimeParseException;

@Component
public class StringToLocalDateTimeConverter implements Converter<String, LocalDateTime> {
    // Format for full date-time
    private static final DateTimeFormatter DATE_TIME_FORMATTER =
            DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss");

    // More lenient format for simple date that allows single digits
    private static final DateTimeFormatter LENIENT_DATE_FORMATTER =
            new DateTimeFormatterBuilder()
                    .appendPattern("yyyy-")
                    .appendPattern("M-")    // Single M allows single-digit months
                    .appendPattern("d")     // Single d allows single-digit days
                    .toFormatter();

    @Override
    public LocalDateTime convert(String source) {
        if (!StringUtils.hasText(source)) {
            return null;
        }

        try {
            // Check if it's a simple date format (no time component)
            if (!source.contains("T")) {
                LocalDate date = LocalDate.parse(source, LENIENT_DATE_FORMATTER);
                return date.atStartOfDay();
            }

            // Try parsing as full date time
            return LocalDateTime.parse(source, DATE_TIME_FORMATTER);

        } catch (DateTimeParseException e) {
            throw new InvalidRequestException(
                    "Invalid date format. Supported formats: " +
                            "yyyy-MM-dd'T'HH:mm:ss.SSS (e.g., 2024-08-27T17:29:01.187) or " +
                            "yyyy-M-d (e.g., 2024-8-27 or 2024-08-27)"
            );
        }
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/dto/CategoryDTOs.java">
package com.online.course.management.project.dto;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import jakarta.validation.constraints.AssertTrue;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.*;
import org.springframework.format.annotation.DateTimeFormat;

import java.time.LocalDateTime;

public class CategoryDTOs {

    @Data
    public static class CategoryResponseDto {
        private Long id;
        private String name;
        private Long courseCount;
        private LocalDateTime createdAt;
        private LocalDateTime updatedAt;
        private LocalDateTime deletedAt;
    }

    @Data
    public static class CreateCategoryDTO {
        @NotBlank(message = "Category name is required")
        @Size(max = 100, message = "Category name must not exceed 100 characters")
        private String name;
    }

    @Data
    public static class UpdateCategoryDTO {
        @NotBlank(message = "Category name is required")
        @Size(max = 100, message = "Category name must not exceed 100 characters")
        private String name;
    }


    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    @JsonIgnoreProperties(ignoreUnknown = false)
    @EqualsAndHashCode(callSuper = true)
    public static class CategorySearchDTO extends PaginationDto.PaginationRequestDto {
        private String name;
        private Boolean archived;

        @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)
        private LocalDateTime fromDate;

        @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)
        private LocalDateTime toDate;

        // Add validation to ensure toDate is after fromDate
        @AssertTrue(message = "toDate must be after fromDate")
        private boolean isDateRangeValid() {
            if (fromDate == null || toDate == null) {
                return true;
            }
            return toDate.isAfter(fromDate);
        }
    }

    @Data
    @AllArgsConstructor
    public static class RestoreCategoryResponseDTO {
        private String message;
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/dto/CommonResponseDTOs.java">
package com.online.course.management.project.dto;

import lombok.Data;
import org.springframework.http.HttpStatus;

public class CommonResponseDTOs {

    @Data
    public static class DeleteSuccessfullyDTO {
        private String message;
        private HttpStatus status = HttpStatus.NO_CONTENT;

        public DeleteSuccessfullyDTO(
                String message) {
            this.message = message;
        }
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/dto/CourseDTOS.java">
package com.online.course.management.project.dto;

import com.online.course.management.project.enums.CourseStatus;
import jakarta.validation.constraints.*;
import lombok.*;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.format.annotation.DateTimeFormat;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class CourseDTOS {

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class CourseDetailsResponseDto {
        private Long id;
        private String title;
        private String description;
        private CourseStatus status;
        private InstructorDetailsDto instructor;
        private Set<String> categoryNames;
        private LocalDateTime createdAt;
        private LocalDateTime updatedAt;
    }

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class InstructorDetailsDto {
        private Long id;
        private String username;
        private String email;
        private String realName;
        private Set<String> roles;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class CreateCourseRequestDTO {
        @NotBlank(message = "Course title is required")
        @Size(max = 255, message = "Title must not exceed 255 characters")
        private String title;

        @Size(max = 1000, message = "Description must not exceed 1000 characters")
        private String description;

        private Set<Long> categoryIds;

        private Long instructorId;

        private CourseStatus status = CourseStatus.DRAFT;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class UpdateCourseRequestDTO {
        @Size(max = 255, message = "Title must not exceed 255 characters")
        private String title;

        @Size(max = 1000, message = "Description must not exceed 1000 characters")
        private String description;

        private CourseStatus status;

        private Set<Long> categoryIds;

        private Long instructorId; // Optional, only for admin use
    }


    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @EqualsAndHashCode(callSuper = true)
    public static class SearchCourseRequestDTO extends PaginationDto.PaginationRequestDto {
        private String title;
        private CourseStatus status;
        private String instructorName;
        private Set<Long> categoryIds;
        private Boolean includeArchived;

        @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)
        private LocalDateTime fromDate;

        @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)
        private LocalDateTime toDate;

        private Map<String, String> sort;

        @AssertTrue(message = "toDate must be after fromDate")
        private boolean isDateRangeValid() {
            if (fromDate == null || toDate == null) {
                return true;
            }
            return toDate.isAfter(fromDate);
        }

        @Override
        public org.springframework.data.domain.Pageable toPageable() {
            return PageRequest.of(getPage() - 1, getLimit());
        }
    }


    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    @EqualsAndHashCode(callSuper = true)
    public static class SearchInstructorCourseRequestDTO extends PaginationDto.PaginationRequestDto {
        @NotNull(message = "Instructor ID must not be null")
        private Long instructorId;

        private boolean includeArchived;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    @EqualsAndHashCode(callSuper = true)
    public static class SearchStatusRequestDTO extends PaginationDto.PaginationRequestDto {
        @NotNull(message = "Status must not be null")
        private String status;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class SearchLatestCoursesRequestDTO {
        private int limit = 10;
    }

}
</file>

<file path="src/main/java/com/online/course/management/project/dto/ErrorResponseDTO.java">
package com.online.course.management.project.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;
import java.util.List;

@Getter
@Setter
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ErrorResponseDTO {
    private LocalDateTime timestamp;
    private int status;
    private String message;
    private List<String> errors;

    public ErrorResponseDTO(String message, int status) {
        this(message, status, null);
    }

    public ErrorResponseDTO(String message, int status, List<String> errors) {
        this.timestamp = LocalDateTime.now();
        this.status = status;
        this.message = message;
        this.errors = errors;
    }

}
</file>

<file path="src/main/java/com/online/course/management/project/dto/PaginationDto.java">
package com.online.course.management.project.dto;

import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import lombok.AllArgsConstructor;
import lombok.Data;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;

import java.util.List;


public class PaginationDto {

    @Data
    public static class PaginationRequestDto {

        @Min(value = 1, message = "Page index must not be less than one")
        private int page = 1;

        @Min(value = 1, message = "Limit must be greater than or equal to 1")
        @Max(value = 50, message = "Limit must be less than or equal to 50")
        private int limit = 10;

        public Pageable toPageable() {
            return PageRequest.of(page - 1, limit);
        }
    }


    @Data
    @AllArgsConstructor
    public static class PaginationResponseDto<T> {
        private List<T> data;
        private int currentPage;
        private int limit;
        private long total;

    }
}
</file>

<file path="src/main/java/com/online/course/management/project/dto/UserDTOs.java">
package com.online.course.management.project.dto;

import jakarta.validation.constraints.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import org.springframework.format.annotation.DateTimeFormat;

import java.time.LocalDateTime;
import java.util.Set;

public class UserDTOs {
    @Data
    public static class UserRegistrationDto {
        @NotBlank
        @Size(max = 50)
        @Email
        private String email;

        @NotBlank
        @Size(min = 6, max = 40, message = "Password must be between 6 and 40 characters")
        private String password;


    }

    @Data
    public static class UserLoginDto {
        @NotBlank
        @Size(max = 50)
        private String usernameOrEmail;

        @NotBlank
        @Size(min = 6, max = 40)
        private String password;
    }

    @Data
    public static class UserResponseDto {
        private Long id;
        private String username;
        private String email;
        private String realName;
        private String status;
    }

    @Data
    public static class UpdateProfileDto {
        @Size(max = 50)
        private String username;

        @Size(max = 50)
        @Email
        private String email;

        @Size(max = 100)
        private String realName;

        @Size(min = 6, max = 40)
        private String password;

        private String status;
    }

    @Data
    public static class UpdateUserRolesDto {
        @NotEmpty
        private Set<String> roles;
    }

    @Data
    @AllArgsConstructor
    public static class JwtResponseDto {
        @NotNull
        private String token;
    }

    @Data
    @AllArgsConstructor
    public static class RoleUpdateResponseDto {
        private String message;
        private Set<String> updatedRoles;
    }

    @Data
    public static class UserWithRolesResponseDto {
        private Long id;
        private String username;
        private String email;
        private String realName;
        private String status;
        private Set<String> roles;
    }

    @Data
    public static class UserSearchRequestDto {
        @Size(max = 50)
        private String username;

        @Size(max = 50)
        @Email
        private String email;

        @Size(max = 100)
        private String realName;

        private String status;

        @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)
        private LocalDateTime fromDate;

        @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)
        private LocalDateTime toDate;
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/entity/Category.java">
package com.online.course.management.project.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = "categories")
@Getter
@Setter
public class Category {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank
    @Size(max = 100)
    @Column(nullable = false, unique = true)
    private String name;

    @ManyToMany(mappedBy = "categories", fetch = FetchType.LAZY)
    private Set<Course> courses = new HashSet<>();

    @CreationTimestamp
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(nullable = false)
    private LocalDateTime updatedAt;

    @Column
    private LocalDateTime deletedAt;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Category)) return false;
        Category category = (Category) o;
        return id != null && Objects.equals(id, category.id);
    }

    @Override
    public int hashCode() {
        return getClass().hashCode();
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/entity/Course.java">
package com.online.course.management.project.entity;

import com.online.course.management.project.enums.CourseStatus;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = "courses")
@Getter
@Setter
public class Course {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank
    @Size(max = 255)
    @Column(nullable = false)
    private String title;

    @Size(max = 1000)
    @Column(columnDefinition = "TEXT")
    private String description;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "instructor_id", nullable = true)
    private User instructor;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private CourseStatus status = CourseStatus.DRAFT;

    @CreationTimestamp
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(nullable = false)
    private LocalDateTime updatedAt;

    @Column
    private LocalDateTime deletedAt;

    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE}, fetch = FetchType.LAZY)
    @JoinTable(
            name = "course_categories",
            joinColumns = @JoinColumn(name = "course_id"),
            inverseJoinColumns = @JoinColumn(name = "category_id"))
    private Set<Category> categories = new HashSet<>();

    public void addCategory(Category category) {
        categories.add(category);
        category.getCourses().add(this);
    }

    public void removeCategory(Category category) {
        categories.remove(category);
        category.getCourses().remove(this);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Course)) return false;
        Course course = (Course) o;
        return id != null && Objects.equals(id, course.id);
    }

    @Override
    public int hashCode() {
        return getClass().hashCode();
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/entity/Role.java">
package com.online.course.management.project.entity;

import com.online.course.management.project.enums.RoleType;
import jakarta.persistence.*;
import lombok.Data;

import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "roles")
@Data
public class Role {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Enumerated(EnumType.STRING)
    @Column(length = 20, unique = true, nullable = false)
    private RoleType name;

    @OneToMany(mappedBy = "role", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<UserRole> userRoles = new HashSet<>();
}
</file>

<file path="src/main/java/com/online/course/management/project/entity/User.java">
package com.online.course.management.project.entity;

import com.online.course.management.project.enums.UserStatus;
import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = "users")
@Getter
@Setter
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank
    @Size(min = 3, max = 50)
    @Column(unique = true, nullable = false)
    private String username;

    @NotBlank
    @Size(max = 50)
    @Email
    @Column(unique = true, nullable = false, length = 320)
    private String email;

    @Size(max = 100)
    @Column(name = "real_name", nullable = true)
    private String realName;

    @NotBlank
    @Size(min = 60, max = 60)
    @Column(nullable = false)
    private String passwordHash;

    @CreationTimestamp
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(nullable = false)
    private LocalDateTime updatedAt;

    @Column
    private LocalDateTime deletedAt;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private UserStatus status = UserStatus.ACTIVE;

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<UserRole> userRoles = new HashSet<>();

    // Helper methods
    public void addRole(Role role) {
        UserRole userRole = new UserRole(this, role);
        userRoles.add(userRole);
    }

    public void removeRole(Role role) {
        userRoles.removeIf(userRole -> userRole.getRole().equals(role));
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof User)) return false;
        User user = (User) o;
        return id != null && Objects.equals(id, user.id);
    }

    @Override
    public int hashCode() {
        return getClass().hashCode();
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/entity/UserRole.java">
package com.online.course.management.project.entity;

import jakarta.persistence.*;
import lombok.Data;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.LocalDateTime;
import java.util.Objects;

@Entity
@Table(name = "user_roles")
@Getter
@Setter
@NoArgsConstructor
public class UserRole {

    @EmbeddedId
    private UserRoleId id;

    @ManyToOne(fetch = FetchType.EAGER)
    @MapsId("userId")
    private User user;

    @ManyToOne(fetch = FetchType.EAGER)
    @MapsId("roleId")
    private Role role;

    @Column(nullable = false)
    private LocalDateTime assignedAt;

    public UserRole(User user, Role role) {
        this.user = user;
        this.role = role;
        this.id = new UserRoleId(user.getId(), role.getId());
        this.assignedAt = LocalDateTime.now();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof UserRole userRole)) return false;
        return Objects.equals(user.getId(), userRole.user.getId()) &&
                Objects.equals(role.getId(), userRole.role.getId());
    }

    @Override
    public int hashCode() {
        return Objects.hash(user.getId(), role.getId());
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/entity/UserRoleId.java">
package com.online.course.management.project.entity;

import jakarta.persistence.Embeddable;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Embeddable
@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserRoleId implements Serializable {

    private Long userId;
    private Long roleId;
}
</file>

<file path="src/main/java/com/online/course/management/project/enums/CourseStatus.java">
package com.online.course.management.project.enums;

public enum CourseStatus {
    DRAFT,
    PUBLISHED,
    ARCHIVED
}
</file>

<file path="src/main/java/com/online/course/management/project/enums/RoleType.java">
package com.online.course.management.project.enums;

public enum RoleType {
    USER,
    ADMIN,
    INSTRUCTOR
}
</file>

<file path="src/main/java/com/online/course/management/project/enums/UserStatus.java">
package com.online.course.management.project.enums;

public enum UserStatus {
    ACTIVE, INACTIVE, SUSPENDED
}
</file>

<file path="src/main/java/com/online/course/management/project/exception/BaseException.java">
package com.online.course.management.project.exception;

public class BaseException extends RuntimeException {
    public BaseException(String message) {
        super(message);
    }

    public BaseException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/exception/business/account/AccountException.java">
package com.online.course.management.project.exception.business.account;

import com.online.course.management.project.exception.business.BusinessException;

public class AccountException extends BusinessException {
    public AccountException(String message) {
        super(message);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/exception/business/account/EmailAlreadyExistsException.java">
package com.online.course.management.project.exception.business.account;

public class EmailAlreadyExistsException extends AccountException {
    public EmailAlreadyExistsException(String message) {
        super(message);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/exception/business/account/WrongEmailPasswordException.java">
package com.online.course.management.project.exception.business.account;

public class WrongEmailPasswordException extends AccountException {
    public WrongEmailPasswordException(String message) {
        super(message);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/exception/business/BusinessException.java">
package com.online.course.management.project.exception.business;

import com.online.course.management.project.exception.BaseException;

public class BusinessException extends BaseException {
    public BusinessException(String message) {
        super(message);
    }

    public BusinessException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/exception/business/ForbiddenException.java">
package com.online.course.management.project.exception.business;

public class ForbiddenException extends BusinessException {
    public ForbiddenException(String message) {
        super(message);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/exception/business/InvalidRequestException.java">
package com.online.course.management.project.exception.business;

public class InvalidRequestException extends BusinessException {
    public InvalidRequestException(String message) {
        super(message);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/exception/business/InvalidRoleInfoException.java">
package com.online.course.management.project.exception.business;

public class InvalidRoleInfoException extends BusinessException {
    public InvalidRoleInfoException(String message) {
        super(message);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/exception/business/ResourceNotFoundException.java">
package com.online.course.management.project.exception.business;

public class ResourceNotFoundException extends BusinessException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/exception/business/UnauthorizedException.java">
package com.online.course.management.project.exception.business;

public class UnauthorizedException extends BusinessException {
    public UnauthorizedException(String message) {
        super(message);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/exception/GlobalExceptionHandler.java">
package com.online.course.management.project.exception;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.exc.InvalidFormatException;
import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;
import com.online.course.management.project.dto.ErrorResponseDTO;
import com.online.course.management.project.exception.business.*;
import com.online.course.management.project.exception.business.account.AccountException;
import com.online.course.management.project.exception.business.account.EmailAlreadyExistsException;
import com.online.course.management.project.exception.business.account.WrongEmailPasswordException;
import com.online.course.management.project.exception.technical.DatabaseException;
import com.online.course.management.project.exception.technical.ExternalServiceException;
import com.online.course.management.project.exception.technical.TechnicalException;
import com.online.course.management.project.utils.exception.GlobalExceptionUtils;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.security.core.AuthenticationException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

import java.util.*;
import java.util.stream.Collectors;

@ControllerAdvice
@Slf4j
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponseDTO> handleBusinessException(BusinessException ex) {
        log.warn("Business exception occurred: {}", ex.getMessage());
        HttpStatus status = HttpStatus.BAD_REQUEST;
        if (ex instanceof ResourceNotFoundException) {
            status = HttpStatus.NOT_FOUND;
        } else if (ex instanceof UnauthorizedException) {
            status = HttpStatus.UNAUTHORIZED;
        } else if (ex instanceof ForbiddenException) {
            status = HttpStatus.FORBIDDEN;
        } else if (ex instanceof AccountException) {
            if (ex instanceof EmailAlreadyExistsException) {
                status = HttpStatus.CONFLICT;
            } else if (ex instanceof WrongEmailPasswordException) {
                status = HttpStatus.UNAUTHORIZED;
            }

        }
        ErrorResponseDTO errorResponse = new ErrorResponseDTO(ex.getMessage(), status.value());
        return new ResponseEntity<>(errorResponse, status);
    }

    @ExceptionHandler(TechnicalException.class)
    public ResponseEntity<ErrorResponseDTO> handleTechnicalException(TechnicalException ex) {
        log.error("Technical exception occurred: {}", ex.getMessage(), ex);
        HttpStatus status = HttpStatus.INTERNAL_SERVER_ERROR;
        String message = "An internal error occurred";

        if (ex instanceof DatabaseException) {
            message = "A database error occurred";
        } else if (ex instanceof ExternalServiceException) {
            message = "An error occurred with an external service";
            status = HttpStatus.BAD_GATEWAY;
        }

        ErrorResponseDTO errorResponse = new ErrorResponseDTO(message, status.value());
        return new ResponseEntity<>(errorResponse, status);
    }

    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex,
            HttpHeaders headers,
            HttpStatusCode status,
            WebRequest request) {
        log.warn("Validation failed: {}", ex.getMessage());
        List<String> errors = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .map(error -> error.getField() + ": " + error.getDefaultMessage())
                .collect(Collectors.toList());

        ErrorResponseDTO errorResponse = new ErrorResponseDTO("Validation failed", HttpStatus.BAD_REQUEST.value(), errors);
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(AuthenticationException.class)
    public ResponseEntity<ErrorResponseDTO> handleAuthenticationException(AuthenticationException ex) {
        log.warn("Authentication failed: {}", ex.getMessage());
        ErrorResponseDTO errorResponse = new ErrorResponseDTO("Authentication failed", HttpStatus.UNAUTHORIZED.value());
        return new ResponseEntity<>(errorResponse, HttpStatus.UNAUTHORIZED);
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ErrorResponseDTO> handleIllegalArgumentException(IllegalArgumentException ex) {
        log.warn("Illegal argument exception occurred: {}", ex.getMessage());
        ErrorResponseDTO errorResponse = new ErrorResponseDTO(ex.getMessage(), HttpStatus.BAD_REQUEST.value());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponseDTO> handleGenericException(Exception ex) {
        log.error("Unexpected error occurred: {}", ex.getMessage(), ex);
        ErrorResponseDTO errorResponse = new ErrorResponseDTO("An unexpected error occurred", HttpStatus.INTERNAL_SERVER_ERROR.value());
        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }

    @Override
    protected ResponseEntity<Object> handleHttpMessageNotReadable(
            HttpMessageNotReadableException ex,
            HttpHeaders headers,
            HttpStatusCode status,
            WebRequest request) {

        String message;
        if (ex.getCause() instanceof UnrecognizedPropertyException unrecognizedProp) {
            // Handle unknown field error
            message = String.format(
                    "Unknown field: '%s'. Allowed fields are: %s",
                    unrecognizedProp.getPropertyName(),
                    String.join(", ", GlobalExceptionUtils.getKnownProperties(new HashSet<>(unrecognizedProp.getKnownPropertyIds())))
            );
        } else if (ex.getCause() instanceof InvalidFormatException invalidFormat) {
            // Handle enum parsing errors
            if (invalidFormat.getTargetType() != null && invalidFormat.getTargetType().isEnum()) {
                try {
                    ObjectMapper objectMapper = new ObjectMapper();
                    message = String.format("Invalid value for enum field: %s",
                            objectMapper.writeValueAsString(Map.of(
                                    "field", invalidFormat.getPath().get(0).getFieldName(),
                                    "invalidValue", invalidFormat.getValue(),
                                    "allowedValues", Arrays.stream(invalidFormat.getTargetType().getEnumConstants())
                                            .map(Object::toString)
                                            .collect(Collectors.toList())
                            ))
                    );
                } catch (JsonProcessingException e) {
                    message = "Invalid request body. Please check your JSON format and field types.";
                }
            } else {
                // Handle other format errors
                message = String.format("Invalid value for field '%s': %s",
                        invalidFormat.getPath().get(0).getFieldName(),
                        invalidFormat.getValue());
            }
        } else {
            // Handle other JSON parsing errors
            message = "Invalid request body. Please check your JSON format and field types.";
        }

        ErrorResponseDTO errorResponse = new ErrorResponseDTO(
                message,
                HttpStatus.BAD_REQUEST.value()
        );

        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }


}
</file>

<file path="src/main/java/com/online/course/management/project/exception/technical/DatabaseException.java">
package com.online.course.management.project.exception.technical;

public class DatabaseException extends TechnicalException {
    public DatabaseException(String message) {
        super(message);
    }

    public DatabaseException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/exception/technical/ExternalServiceException.java">
package com.online.course.management.project.exception.technical;

public class ExternalServiceException extends TechnicalException {
    public ExternalServiceException(String message) {
        super(message);
    }

    public ExternalServiceException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/exception/technical/TechnicalException.java">
package com.online.course.management.project.exception.technical;

import com.online.course.management.project.exception.BaseException;

public class TechnicalException extends BaseException {
    public TechnicalException(String message) {
        super(message);
    }

    public TechnicalException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/filter/DebugFilter.java">
package com.online.course.management.project.filter;

import jakarta.servlet.*;
import jakarta.servlet.http.HttpServletRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;

public class DebugFilter implements Filter {

    private static final Logger logger = LoggerFactory.getLogger(DebugFilter.class);

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest httpRequest = (HttpServletRequest) servletRequest;
        logger.info("Incoming request: {} {}", httpRequest.getMethod(), httpRequest.getRequestURI());
        filterChain.doFilter(servletRequest, servletResponse);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/filter/JwtAuthenticationFilter.java">
package com.online.course.management.project.filter;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.online.course.management.project.dto.ErrorResponseDTO;
import com.online.course.management.project.security.CustomUserDetailsService;
import com.online.course.management.project.security.JwtUtil;
import io.jsonwebtoken.ExpiredJwtException;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;

@Component
@Slf4j
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    private final JwtUtil jwtUtil;
    private final CustomUserDetailsService userDetailsService;
    private final ObjectMapper objectMapper;

    @Autowired
    public JwtAuthenticationFilter(JwtUtil jwtUtil, CustomUserDetailsService userDetailsService, ObjectMapper objectMapper) {
        this.jwtUtil = jwtUtil;
        this.userDetailsService = userDetailsService;
        this.objectMapper = objectMapper;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {

        try {
            // Skip authentication for permitted paths
            if (shouldSkipAuthentication(request)) {
                filterChain.doFilter(request, response);
                return;
            }

            String jwt = getJwtFromRequest(request);

            // If no token is present, handle accordingly
            if (jwt == null) {
                handleMissingToken(response);
                return;
            }

            try {
                if (jwtUtil.validateToken(jwt)) {
                    String username = jwtUtil.extractUsername(jwt);
                    UserDetails userDetails = userDetailsService.loadUserByUsername(username);

                    UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                    authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                    SecurityContextHolder.getContext().setAuthentication(authentication);
                    filterChain.doFilter(request, response);
                }
            } catch (ExpiredJwtException e) {
                handleTokenError(response, "JWT token has expired", HttpStatus.UNAUTHORIZED);
            } catch (Exception e) {
                handleTokenError(response, "Invalid JWT token", HttpStatus.UNAUTHORIZED);
            }
        } catch (Exception e) {
            handleTokenError(response, "Authentication failed", HttpStatus.UNAUTHORIZED);
        }
    }

    private boolean shouldSkipAuthentication(HttpServletRequest request) {
        String path = request.getServletPath();
        log.info("Checking if request should be skipped: {}", path);

        // Define patterns for public endpoints
        List<String> publicEndpoints = Arrays.asList("/api/v1/users/login", "/api/v1/users/register", "/error");

        // Check exact matches first
        if (publicEndpoints.contains(path) || request.getMethod().equals("OPTIONS")) {
            return true;
        }

        // Check course-related patterns
        if (path.matches("/api/v1/courses/\\d+") ||    // Matches /courses/{id}
                path.equals("/api/v1/courses/search") || path.equals("/api/v1/courses/search-instructor") || path.equals("/api/v1/courses/search-status") || path.equals("/api/v1/courses/search-latest")) {    // Matches /courses/search
            return request.getMethod().equals("POST");   // Only allow POST requests
        }

        return false;
    }

    private String getJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }

    private void handleMissingToken(HttpServletResponse response) throws IOException {
        handleTokenError(response, "Authentication required", HttpStatus.UNAUTHORIZED);
    }

    private void handleTokenError(HttpServletResponse response, String message, HttpStatus status) throws IOException {
        response.setStatus(status.value());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding("UTF-8");

        ErrorResponseDTO errorResponse = new ErrorResponseDTO(message, status.value());

        objectMapper.writeValue(response.getOutputStream(), errorResponse);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/mapper/CategoryMapper.java">
package com.online.course.management.project.mapper;

import com.online.course.management.project.dto.CategoryDTOs;
import com.online.course.management.project.entity.Category;
import com.online.course.management.project.enums.CourseStatus;
import org.mapstruct.*;

@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE)
public interface CategoryMapper {

    @Mapping(target = "courseCount", expression = "java(countActiveCourses(category))")
    CategoryDTOs.CategoryResponseDto toDto(Category category);

    Category toEntity(CategoryDTOs.CreateCategoryDTO createCategoryRequest);

    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    void updateCategoryFromDto(CategoryDTOs.UpdateCategoryDTO updateCategoryRequest, @MappingTarget Category category);

    default Long countActiveCourses(Category category) {
        if (category.getCourses() == null) return 0L;
        return category.getCourses().stream()
                .filter(course -> course.getDeletedAt() == null
                        && course.getStatus() != CourseStatus.ARCHIVED)
                .count();
    }

}
</file>

<file path="src/main/java/com/online/course/management/project/mapper/CourseMapper.java">
package com.online.course.management.project.mapper;

import com.online.course.management.project.dto.CourseDTOS;
import com.online.course.management.project.entity.Category;
import com.online.course.management.project.entity.Course;
import com.online.course.management.project.entity.User;
import org.mapstruct.*;

import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

@Mapper(componentModel = "spring",
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public interface CourseMapper {

    @Mapping(target = "instructor", source = "instructor")
    @Mapping(target = "categoryNames", expression = "java(mapCategoryNames(course))")
    CourseDTOS.CourseDetailsResponseDto toDto(Course course);

    @Mapping(target = "roles", expression = "java(mapUserRoles(user))")
    CourseDTOS.InstructorDetailsDto toInstructorDto(User user);

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "instructor", ignore = true)
    @Mapping(target = "categories", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "deletedAt", ignore = true)
    Course toEntity(CourseDTOS.CreateCourseRequestDTO dto);

    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "instructor", ignore = true)
    @Mapping(target = "categories", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "deletedAt", ignore = true)
    void updateCourseFromDto(CourseDTOS.UpdateCourseRequestDTO dto, @MappingTarget Course course);

    default Set<String> mapCategoryNames(Course course) {
        if (course.getCategories() == null) return new HashSet<>();
        return course.getCategories().stream()
                .map(Category::getName)
                .collect(Collectors.toSet());
    }

    default Set<String> mapUserRoles(User user) {
        if (user.getUserRoles() == null) return new HashSet<>();
        return user.getUserRoles().stream()
                .map(userRole -> userRole.getRole().getName().name())
                .collect(Collectors.toSet());
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/mapper/UserMapper.java">
package com.online.course.management.project.mapper;

import com.online.course.management.project.dto.UserDTOs;
import com.online.course.management.project.entity.User;
import com.online.course.management.project.entity.UserRole;
import com.online.course.management.project.enums.UserStatus;
import org.mapstruct.*;
import org.springframework.stereotype.Component;

import java.util.Set;
import java.util.stream.Collectors;

@Mapper(componentModel = "spring", unmappedSourcePolicy = ReportingPolicy.IGNORE)
public interface UserMapper {

    @Mapping(target = "passwordHash", ignore = true)
    @Mapping(target = "userRoles", ignore = true)
    User toEntity(UserDTOs.UserRegistrationDto dto);


    UserDTOs.UserResponseDto toDto(User user);

    @Mapping(target = "roles", expression = "java(mapRoles(user.getUserRoles()))")
    UserDTOs.UserWithRolesResponseDto toUserWithRolesDto(User user);

    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    void updateUserFromDto(UserDTOs.UpdateProfileDto dto, @MappingTarget User user);

    default Set<String> mapRoles(Set<UserRole> userRoles) {
        return userRoles.stream()
                .map(userRole -> userRole.getRole().getName().name())
                .collect(Collectors.toSet());
    }


}
</file>

<file path="src/main/java/com/online/course/management/project/ProjectApplication.java">
package com.online.course.management.project;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

@SpringBootApplication
@EnableCaching
@EnableAspectJAutoProxy
public class ProjectApplication {

    public static void main(String[] args) {
        SpringApplication.run(ProjectApplication.class, args);
    }

}
</file>

<file path="src/main/java/com/online/course/management/project/repository/ICategoryRepository.java">
package com.online.course.management.project.repository;

import com.online.course.management.project.entity.Category;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.Optional;

@Repository
public interface ICategoryRepository extends JpaRepository<Category, Long>, JpaSpecificationExecutor<Category> {
    // Create & update operations
    @Override
    <S extends Category> S save(S category);

    // Read operations
    Optional<Category> findById(Long id);

    boolean existsByName(String name);

    @Query("""
            SELECT c FROM Category c 
            WHERE (:archived IS NULL 
                OR (:archived = true AND c.deletedAt IS NOT NULL)
                OR (:archived = false AND c.deletedAt IS NULL)
            )
            AND (:name IS NULL OR LOWER(c.name) LIKE LOWER(CONCAT('%', :name, '%')))
            AND (:fromDate IS NULL OR c.createdAt >= :fromDate)
            AND (:toDate IS NULL OR c.createdAt <= :toDate)
            """)
    Page<Category> searchCategories(
            @Param("name") String name,
            @Param("fromDate") LocalDateTime fromDate,
            @Param("toDate") LocalDateTime toDate,
            @Param("archived") Boolean archived,
            Pageable pageable
    );

    @Query("""
            SELECT COUNT(c) FROM Category c 
            WHERE (:archived IS NULL 
                OR (:archived = true AND c.deletedAt IS NOT NULL)
                OR (:archived = false AND c.deletedAt IS NULL)
            )
            AND (:name IS NULL OR LOWER(c.name) LIKE LOWER(CONCAT('%', :name, '%')))
            AND (:fromDate IS NULL OR c.createdAt >= :fromDate)
            AND (:toDate IS NULL OR c.createdAt <= :toDate)
            """)
    long countCategories(

            @Param("name") String name,
            @Param("fromDate") LocalDateTime fromDate,
            @Param("toDate") LocalDateTime toDate,
            @Param("archived") Boolean archived
    );

    // Delete operations (soft delete)
    @Modifying
    @Query("UPDATE Category c SET c.deletedAt = CURRENT_TIMESTAMP WHERE c.id = :id")
    void softDeleteCategory(@Param("id") Long id);

    // Restore operation
    @Modifying
    @Query("UPDATE Category c SET c.deletedAt = NULL, c.updatedAt = CURRENT_TIMESTAMP WHERE c.id = :id")
    void restoreCategory(@Param("id") Long id);

}
</file>

<file path="src/main/java/com/online/course/management/project/repository/ICourseRepository.java">
package com.online.course.management.project.repository;

import com.online.course.management.project.entity.Course;
import com.online.course.management.project.enums.CourseStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.Set;

@Repository
public interface ICourseRepository extends JpaRepository<Course, Long>, JpaSpecificationExecutor<Course> {

    // Create & update operations
    @Override
    <S extends Course> S save(S course);


    @Query(value = """
             SELECT DISTINCT
                 c.*,
                 u.id as instructor_user_id,
                 u.username as instructor_username,
                 u.email as instructor_email,
                 u.real_name as instructor_name,
                 GROUP_CONCAT(DISTINCT cat.name ORDER BY cat.name) as category_names
             FROM courses c
             LEFT JOIN users u ON c.instructor_id = u.id
             LEFT JOIN course_categories cc ON c.id = cc.course_id
             LEFT JOIN categories cat ON cc.category_id = cat.id
            WHERE c.instructor_id = :instructorId
             AND (IF(:includeArchived = true, true, c.status != 'ARCHIVED'))
             GROUP BY c.id, u.id, u.username, u.email, u.real_name
             """,
            countQuery = """
                    SELECT COUNT(DISTINCT c.id)
                    FROM courses c
                    WHERE c.instructor_id = :instructorId
                    AND (CASE\s
                        WHEN :includeArchived = true THEN true
                        ELSE c.status != 'ARCHIVED'
                    END)
                    """,
            nativeQuery = true)
    Page<Course> findByInstructorId(
            @Param("instructorId") Long instructorId,
            @Param("includeArchived") Boolean includeArchived,
            Pageable pageable
    );

    @Query(value = """
            SELECT DISTINCT c.*,
                u.username as instructor_username,
                u.email as instructor_email,
                u.real_name as instructor_name,
                GROUP_CONCAT(DISTINCT cat.name ORDER BY cat.name) as category_names
            FROM courses c
            LEFT JOIN users u ON c.instructor_id = u.id
            LEFT JOIN course_categories cc ON c.id = cc.course_id
            LEFT JOIN categories cat ON cc.category_id = cat.id
            WHERE c.id = :id 
            GROUP BY c.id, u.username, u.email, u.real_name
            HAVING c.id IS NOT NULL
            """, nativeQuery = true)
    Optional<Course> findByIdWithDetails(@Param("id") Long id);

    @Query(value = """
            SELECT DISTINCT
                c.*,
                u.username as instructor_username,
                u.email as instructor_email,
                u.real_name as instructor_name,
                GROUP_CONCAT(DISTINCT cat.name ORDER BY cat.name) as category_names
            FROM courses c
            LEFT JOIN users u ON c.instructor_id = u.id
            LEFT JOIN course_categories cc ON c.id = cc.course_id
            LEFT JOIN categories cat ON cc.category_id = cat.id
            WHERE c.status = :status
            GROUP BY c.id, u.username, u.email, u.real_name
            """,
            countQuery = """
                        SELECT COUNT(DISTINCT c.id)
                        FROM courses c
                        WHERE c.status = :status
                    """,
            nativeQuery = true)
    Page<Course> findByStatus(
            @Param("status") String status,
            Pageable pageable
    );

    @Query(value = """
            SELECT DISTINCT
                c.*,
                u.username as instructor_username,
                u.email as instructor_email,
                u.real_name as instructor_name,
                GROUP_CONCAT(DISTINCT cat.name ORDER BY cat.name) as category_names
            FROM courses c
            LEFT JOIN users u ON c.instructor_id = u.id
            LEFT JOIN course_categories cc ON c.id = cc.course_id
            LEFT JOIN categories cat ON cc.category_id = cat.id
            WHERE c.status != 'ARCHIVED'
            AND c.deleted_at IS NULL
            GROUP BY c.id, u.username, u.email, u.real_name
            ORDER BY c.created_at DESC
            LIMIT :limit
            """, nativeQuery = true)
    List<Course> findLatestCourses(@Param("limit") int limit);

    @Query(value = """
            SELECT DISTINCT
                        c.*,
                        u.username as instructor_username,
                        u.email as instructor_email,
                        u.real_name as instructor_name,
                        GROUP_CONCAT(DISTINCT cat.name ORDER BY cat.name) as category_names
                    FROM courses c
                    LEFT JOIN users u ON c.instructor_id = u.id
                    LEFT JOIN course_categories cc ON c.id = cc.course_id
                    LEFT JOIN categories cat ON cc.category_id = cat.id
                    WHERE (:title IS NULL OR LOWER(c.title) LIKE CONCAT('%', LOWER(:title), '%'))
                    AND (IF(:includeArchived = true, true, c.status != 'ARCHIVED'))
                    AND (:status IS NULL OR c.status = :status)
                    AND (:instructorName IS NULL OR LOWER(u.real_name) LIKE CONCAT('%', LOWER(:instructorName), '%'))
                    AND (:fromDate IS NULL OR c.created_at >= :fromDate)
                    AND (:toDate IS NULL OR c.created_at <= :toDate)
                    AND cc.category_id IN (:categoryIds)
                    GROUP BY\s
                        c.id,
                        u.id,
                        u.username,
                        u.email,
                        u.real_name,
                        c.status,
                        c.updated_at,
                        c.created_at
            """,
            countQuery = """
                    SELECT COUNT(c.id)
                        FROM courses c
                        JOIN course_categories cc ON c.id = cc.course_id
                        LEFT JOIN users u ON c.instructor_id = u.id
                        WHERE (:title IS NULL OR LOWER(c.title) LIKE CONCAT('%', LOWER(:title), '%'))
                        AND (IF(:includeArchived = true, true, c.status != 'ARCHIVED'))
                        AND (:status IS NULL OR c.status = :status)
                        AND (:instructorName IS NULL OR LOWER(u.real_name) LIKE CONCAT('%', LOWER(:instructorName), '%'))
                        AND (:fromDate IS NULL OR c.created_at >= :fromDate)
                        AND (:toDate IS NULL OR c.created_at <= :toDate)
                        AND cc.category_id IN (:categoryIds)
                    """,
            nativeQuery = true)
    Page<Course> searchCourses(
            @Param("title") String title,
            @Param("status") String status,
            @Param("instructorName") String instructorName,
            @Param("fromDate") LocalDateTime fromDate,
            @Param("toDate") LocalDateTime toDate,
            @Param("categoryIds") Set<Long> categoryIds,
            @Param("includeArchived") Boolean includeArchived,
            Pageable pageable
    );

    // Archive operation (special form of soft delete)
    @Modifying
    @Query(value = """
            UPDATE courses
            SET status = 'ARCHIVED',
                deleted_at = CURRENT_TIMESTAMP,
                updated_at = CURRENT_TIMESTAMP
            WHERE id = :courseId
            """, nativeQuery = true)
    void archiveCourse(@Param("courseId") Long courseId);

    @Modifying
    @Query(value = """
            UPDATE courses
            SET status = 'DRAFT',
                deleted_at = NULL,
                updated_at = CURRENT_TIMESTAMP
            WHERE id = :courseId
            AND status = 'ARCHIVED'
            """, nativeQuery = true)
    void unarchiveCourse(@Param("courseId") Long courseId);

    @Modifying
    @Query(value = """
            INSERT INTO course_categories (course_id, category_id)
            VALUES (:courseId, :categoryId)
            """, nativeQuery = true)
    void addCourseCategory(
            @Param("courseId") Long courseId,
            @Param("categoryId") Long categoryId
    );

}
</file>

<file path="src/main/java/com/online/course/management/project/repository/IRoleRepository.java">
package com.online.course.management.project.repository;

import com.online.course.management.project.entity.Role;
import com.online.course.management.project.enums.RoleType;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface IRoleRepository extends JpaRepository<Role, Long> {
    Optional<Role> findByName(RoleType name);
    boolean existsByName(RoleType name);
}
</file>

<file path="src/main/java/com/online/course/management/project/repository/IUserRepository.java">
package com.online.course.management.project.repository;

import com.online.course.management.project.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;


import java.util.Optional;

@Repository
public interface IUserRepository extends JpaRepository<User, Long>, JpaSpecificationExecutor<User> {
    Optional<User> findByUsername(String username);

    Optional<User> findByEmail(String email);

    Optional<User> findByUsernameOrEmail(String username, String email);

    boolean existsByUsername(String username);

    boolean existsByEmail(String email);


    @Query("SELECT u FROM User u LEFT JOIN FETCH u.userRoles WHERE u.username = :username OR u.email = :email")
    Optional<User> findByUsernameOrEmailWithRoles(@Param("username") String username, @Param("email") String email);
}
</file>

<file path="src/main/java/com/online/course/management/project/repository/IUserRoleRepository.java">
package com.online.course.management.project.repository;

import com.online.course.management.project.entity.UserRole;
import com.online.course.management.project.entity.UserRoleId;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface IUserRoleRepository extends JpaRepository<UserRole, UserRoleId> {
    List<UserRole> findByUserId(Long userId);

    List<UserRole> findByRoleId(Long roleId);
}
</file>

<file path="src/main/java/com/online/course/management/project/security/CustomAccessDeniedHandler.java">
package com.online.course.management.project.security;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.online.course.management.project.dto.ErrorResponseDTO;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.stereotype.Component;

import java.io.IOException;

@Component
public class CustomAccessDeniedHandler implements AccessDeniedHandler {

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response,
                       AccessDeniedException accessDeniedException) throws IOException {
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setStatus(HttpStatus.FORBIDDEN.value());

        ErrorResponseDTO errorResponse = new ErrorResponseDTO(
                "Access denied: You don't have permission to access this resource",
                HttpStatus.FORBIDDEN.value()
        );

        objectMapper.writeValue(response.getOutputStream(), errorResponse);
    }

}
</file>

<file path="src/main/java/com/online/course/management/project/security/CustomUserDetails.java">
package com.online.course.management.project.security;

import com.online.course.management.project.entity.User;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.stream.Collectors;

public class CustomUserDetails implements UserDetails {

    private final User user;

    public CustomUserDetails(User user) {
        this.user = user;
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return user.getUserRoles().stream()
                .map(userRole -> new SimpleGrantedAuthority("ROLE_" + userRole.getRole().getName().name()))
                .collect(Collectors.toSet());
    }

    @Override
    public String getPassword() {
        return user.getPasswordHash();
    }

    @Override
    public String getUsername() {
        return user.getUsername();
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return user.getDeletedAt() == null;
    }

    public Long getId() {
        return user.getId();
    }

    public String getEmail() {
        return user.getEmail();
    }

    public String getRealName() {
        return user.getRealName();
    }


    public User getUser() {
        return user;
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/security/CustomUserDetailsService.java">
package com.online.course.management.project.security;

import com.online.course.management.project.entity.User;
import com.online.course.management.project.repository.IUserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class CustomUserDetailsService implements UserDetailsService {

    private final IUserRepository userRepository;

    @Autowired
    public CustomUserDetailsService(IUserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    @Transactional(readOnly = true)
    public UserDetails loadUserByUsername(String usernameOrEmail) throws UsernameNotFoundException {
        User user = userRepository.findByUsernameOrEmailWithRoles(usernameOrEmail, usernameOrEmail)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with username or email: " + usernameOrEmail));

        return new CustomUserDetails(user);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/security/JwtAuthenticationEntryPoint.java">
package com.online.course.management.project.security;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.online.course.management.project.dto.ErrorResponseDTO;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;

@Component
public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    private final ObjectMapper objectMapper;

    @Autowired
    public JwtAuthenticationEntryPoint(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
    }

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) throws IOException {

        response.setStatus(HttpStatus.UNAUTHORIZED.value());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);

        String message;
        if (request.getAttribute("expired") != null) {
            message = "JWT token has expired";
        } else if (request.getAttribute("invalid") != null) {
            message = "Invalid JWT token";
        } else if (authException != null && authException.getMessage() != null) {
            message = authException.getMessage();
        } else {
            message = "Authentication required: Please provide a valid JWT token";
        }

        ErrorResponseDTO errorResponse = new ErrorResponseDTO(
                message,
                HttpStatus.UNAUTHORIZED.value()
        );

        objectMapper.writeValue(response.getOutputStream(), errorResponse);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/security/JwtUtil.java">
package com.online.course.management.project.security;

import io.jsonwebtoken.*;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

@Component
public class JwtUtil {

    @Value("${jwt.secret}")
    private String secret;

    @Value("${jwt.expiration}")
    private Long expiration;

    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    private Claims extractAllClaims(String token) {
        return Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody();
    }

    public Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    public String generateToken(UserDetails userDetails) {
        Map<String, Object> claims = new HashMap<>();
        return createToken(claims, userDetails.getUsername());
    }

    private String createToken(Map<String, Object> claims, String subject) {
        return Jwts.builder().setClaims(claims).setSubject(subject).setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(new Date(System.currentTimeMillis() + expiration * 1000))
                .signWith(SignatureAlgorithm.HS256, secret).compact();
    }

    // New method to validate token without UserDetails
    public Boolean validateToken(String token) {
        Jwts.parser().setSigningKey(secret).parseClaimsJws(token);
        return !isTokenExpired(token);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/security/RequiredRole.java">
package com.online.course.management.project.security;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RequiredRole {
    String[] value();
}
</file>

<file path="src/main/java/com/online/course/management/project/security/UserSecurity.java">
package com.online.course.management.project.security;

import com.online.course.management.project.entity.User;
import com.online.course.management.project.repository.IUserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;

@Component("userSecurity")
public class UserSecurity {
    private final IUserRepository userRepository;

    @Autowired
    public UserSecurity(IUserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public boolean isUserOwner(Authentication authentication, Long userId) {
        String username = authentication.getName();
        User user = userRepository.findByUsername(username).orElse(null);
        return user != null && user.getId().equals(userId);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/service/impl/CategoryServiceImpl.java">
package com.online.course.management.project.service.impl;

import com.online.course.management.project.dto.CategoryDTOs;
import com.online.course.management.project.entity.Category;
import com.online.course.management.project.exception.business.ForbiddenException;
import com.online.course.management.project.exception.business.ResourceNotFoundException;
import com.online.course.management.project.mapper.CategoryMapper;
import com.online.course.management.project.repository.ICategoryRepository;
import com.online.course.management.project.service.interfaces.ICategoryService;
import com.online.course.management.project.utils.category.CategoryServiceUtils;
import jakarta.transaction.Transactional;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.util.stream.Collectors;

@Service
@Slf4j
public class CategoryServiceImpl implements ICategoryService {

    private final ICategoryRepository categoryRepository;
    private final CategoryMapper categoryMapper;
    private final CategoryServiceUtils categoryServiceUtils;

    @Autowired
    public CategoryServiceImpl(ICategoryRepository categoryRepository, CategoryMapper categoryMapper, CategoryServiceUtils categoryServiceUtils) {
        this.categoryRepository = categoryRepository;
        this.categoryMapper = categoryMapper;
        this.categoryServiceUtils = categoryServiceUtils;
    }

    @Override
    @Transactional
    public CategoryDTOs.CategoryResponseDto createCategory(CategoryDTOs.CreateCategoryDTO request) {
        log.info("Creating new category with name: {}", request.getName());

        if (isCategoryNameExist(request.getName())) {
            throw new IllegalArgumentException("Category with name already exists");
        }

        if (request.getName() == null || request.getName().isEmpty()) {
            throw new IllegalArgumentException("Category name cannot be empty");
        }

        Category category = categoryMapper.toEntity(request);
        Category savedCategory = categoryRepository.save(category);

        return categoryMapper.toDto(savedCategory);
    }

    @Override
    @Transactional
    public CategoryDTOs.CategoryResponseDto updateCategory(Long id, CategoryDTOs.UpdateCategoryDTO request) {
        log.info("Updating category with id: {}", id);


        if (isCategoryNameExist(request.getName())) {
            throw new IllegalArgumentException("Category with name already exists");
        }

        Category category = categoryServiceUtils.getCategoryOrThrow(id);

        categoryMapper.updateCategoryFromDto(request, category);

        Category updatedCategory = categoryRepository.save(category);

        return categoryMapper.toDto(updatedCategory);
    }

    @Override
    @Transactional
    @CacheEvict(value = "categories", key = "#id")
    public void deleteCategory(Long id) {
        log.info("Soft deleting category with id: {}", id);

        Category category = categoryServiceUtils.getCategoryOrThrow(id);

        if (category.getDeletedAt() != null) {
            throw new ForbiddenException("Cannot delete archived category");
        }

        categoryRepository.softDeleteCategory(id);
    }

    @Override
    @Cacheable(value = "categories", key = "#id")
    public CategoryDTOs.CategoryResponseDto getCategoryById(Long id) {
        log.info("Fetching category with id: {}", id);

        return categoryMapper.toDto(categoryServiceUtils.getCategoryOrThrow(id));
    }

    @Override
    public boolean isCategoryNameExist(String categoryName) {
        return categoryRepository.existsByName(categoryName);
    }


    @Override
    public Page<CategoryDTOs.CategoryResponseDto> searchCategories(CategoryDTOs.CategorySearchDTO request, Pageable pageable) {
        log.info("Searching categories with criteria: {}", request);

        Page<Category> categories = categoryRepository.searchCategories(
                request.getName(),
                request.getFromDate(),
                request.getToDate(),
                request.getArchived(),
                pageable
        );

        long totalCount = categoryRepository.countCategories(
                request.getName(),
                request.getFromDate(),
                request.getToDate(),
                request.getArchived()
        );

        return new PageImpl<>(
                categories.getContent().stream()
                        .map(categoryMapper::toDto)
                        .collect(Collectors.toList()),
                pageable,
                totalCount
        );
    }

    @Override
    @Transactional
    @CacheEvict(value = "categories", key = "#id")
    public void restoreCategory(Long id) {
        log.info("Restoring category with id: {}", id);

        Category category = categoryServiceUtils.getCategoryOrThrow(id);

        if (category.getDeletedAt() == null) {
            throw new IllegalArgumentException("Category is not soft deleted");
        }

        categoryRepository.restoreCategory(id);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/service/impl/CourseServiceImpl.java">
package com.online.course.management.project.service.impl;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.online.course.management.project.dto.CourseDTOS;
import com.online.course.management.project.entity.Category;
import com.online.course.management.project.entity.Course;
import com.online.course.management.project.entity.User;
import com.online.course.management.project.enums.CourseStatus;
import com.online.course.management.project.enums.RoleType;
import com.online.course.management.project.exception.business.ForbiddenException;
import com.online.course.management.project.exception.business.InvalidRequestException;
import com.online.course.management.project.exception.business.ResourceNotFoundException;
import com.online.course.management.project.mapper.CourseMapper;
import com.online.course.management.project.repository.ICategoryRepository;
import com.online.course.management.project.repository.ICourseRepository;
import com.online.course.management.project.repository.IUserRepository;
import com.online.course.management.project.security.CustomUserDetails;
import com.online.course.management.project.service.interfaces.ICourseService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

@Service
@Slf4j
public class CourseServiceImpl implements ICourseService {

    private final ICourseRepository courseRepository;
    private final IUserRepository userRepository;
    private final ICategoryRepository categoryRepository;
    private final CourseMapper courseMapper;

    private static final String DEFAULT_SORT_FIELD = "created_at";
    private static final String DEFAULT_SORT_ORDER = "desc";

    @Autowired
    public CourseServiceImpl(
            ICourseRepository courseRepository,
            IUserRepository userRepository,
            ICategoryRepository categoryRepository,
            CourseMapper courseMapper) {
        this.courseRepository = courseRepository;
        this.userRepository = userRepository;
        this.categoryRepository = categoryRepository;
        this.courseMapper = courseMapper;
    }

    @Override
    @Transactional
    @CacheEvict(value = "courses", allEntries = true)
    public CourseDTOS.CourseDetailsResponseDto createCourse(CourseDTOS.CreateCourseRequestDTO request) {
        log.info("Creating new course with title: {}", request.getTitle());

        Course course = courseMapper.toEntity(request);

        if (request.getInstructorId() != null) {
            User instructor = determineInstructor(request.getInstructorId());
            course.setInstructor(instructor);
        }

        // Important: Initialize the categories set if null
        if (course.getCategories() == null) {
            course.setCategories(new HashSet<>());
        }

        if (request.getCategoryIds() != null && !request.getCategoryIds().isEmpty()) {
            Set<Category> categories = validateCategories(request.getCategoryIds());
            for (Category category : categories) {
                course.addCategory(category);
            }
        }

        Course savedCourse = courseRepository.save(course);
        return courseMapper.toDto(savedCourse);
    }

    @Override
    @Transactional
    @CacheEvict(value = "courses", key = "#id")
    public CourseDTOS.CourseDetailsResponseDto updateCourse(Long id, CourseDTOS.UpdateCourseRequestDTO request) {
        log.info("Updating course with id: {}", id);

        Course course = getCourseWithValidation(id);

        if (request.getInstructorId() != null) {
            User newInstructor = determineInstructor(request.getInstructorId());
            course.setInstructor(newInstructor);
        }

        // If status is being updated, validate the transition
        if (request.getStatus() != null) {
            try {
                validateCourseStatus(course.getStatus(), request.getStatus());
            } catch (JsonProcessingException e) {
                throw new InvalidRequestException("Error processing status validation");
            }

            // Handle archived status and deletedAt
            if (request.getStatus() == CourseStatus.ARCHIVED) {
                course.setDeletedAt(LocalDateTime.now());
            } else if (course.getStatus() == CourseStatus.ARCHIVED && request.getStatus() != CourseStatus.ARCHIVED) {
                // If transitioning from ARCHIVED to another status, clear deletedAt
                course.setDeletedAt(null);
            }
        }

        courseMapper.updateCourseFromDto(request, course);

        if (request.getCategoryIds() != null && !request.getCategoryIds().isEmpty()) {
            updateCourseCategories(course, request.getCategoryIds());
        }

        Course updatedCourse = courseRepository.save(course);
        return courseMapper.toDto(updatedCourse);
    }

    @Override
    @Transactional
    @CacheEvict(value = "courses", key = "#id")
    public void archiveCourse(Long id) {
        log.info("Archiving course with id: {}", id);
        getCourseWithValidation(id);
        courseRepository.archiveCourse(id);
    }

    @Override
    @Transactional
    @CacheEvict(value = "courses", key = "#id")
    public void unarchiveCourse(Long id) {
        log.info("Unarchiving course with id: {}", id);
        getCourseWithValidation(id);
        courseRepository.unarchiveCourse(id);
    }

    @Override
    @Transactional(readOnly = true)
    @Cacheable(value = "courses", key = "#id")
    public CourseDTOS.CourseDetailsResponseDto getCourseById(Long id) {
        log.info("Fetching course with id: {}", id);
        Course course = GetCourseWithoutValidation(id);
        return courseMapper.toDto(course);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<CourseDTOS.CourseDetailsResponseDto> searchCourses(
            CourseDTOS.SearchCourseRequestDTO request,
            Pageable pageable) {
        log.info("Searching courses with criteria: {}", request);

        // Validate and create sort if provided in request
        if (request.getSort() != null && !request.getSort().isEmpty()) {
            validateSortFields(request.getSort());
            pageable = PageRequest.of(
                    pageable.getPageNumber(),
                    pageable.getPageSize(),
                    createSort(request.getSort())
            );
        } else {
            // Use default sort if none provided
            pageable = PageRequest.of(
                    pageable.getPageNumber(),
                    pageable.getPageSize(),
                    Sort.by(Sort.Direction.DESC, DEFAULT_SORT_FIELD)
            );
        }

        return courseRepository.searchCourses(
                request.getTitle(),
                request.getStatus() != null ? request.getStatus().name() : null,
                request.getInstructorName(),
                request.getFromDate(),
                request.getToDate(),
                request.getCategoryIds(),
                request.getIncludeArchived(),
                pageable
        ).map(courseMapper::toDto);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<CourseDTOS.CourseDetailsResponseDto> getCoursesByInstructor(
            Long instructorId,
            boolean includeArchived,
            Pageable pageable) {
        log.info("Fetching courses for instructor: {}, includeArchived: {}",
                instructorId, includeArchived);

        if (!userRepository.existsById(instructorId)) {
            throw new ResourceNotFoundException("Instructor not found");
        }

        pageable = PageRequest.of(
                pageable.getPageNumber(),
                pageable.getPageSize(),
                Sort.by(Sort.Direction.DESC, DEFAULT_SORT_FIELD)
        );

        return courseRepository.findByInstructorId(instructorId, includeArchived, pageable)
                .map(courseMapper::toDto);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<CourseDTOS.CourseDetailsResponseDto> getCoursesByStatus(
            CourseStatus status,
            Pageable pageable) {
        log.info("Fetching courses with status: {}", status);

        // Use default sort if none provided

        pageable = PageRequest.of(
                pageable.getPageNumber(),
                pageable.getPageSize(),
                Sort.by(Sort.Direction.DESC, DEFAULT_SORT_FIELD)
        );

        return courseRepository.findByStatus(status.name(), pageable)
                .map(courseMapper::toDto);
    }

    @Override
    @Transactional(readOnly = true)
    @Cacheable(value = "latestCourses", key = "#limit")
    public List<CourseDTOS.CourseDetailsResponseDto> getLatestCourses(int limit) {
        log.info("Fetching latest {} courses", limit);
        return courseRepository.findLatestCourses(limit)
                .stream()
                .map(courseMapper::toDto)
                .collect(Collectors.toList());
    }


    // Helper methods
    private User determineInstructor(Long instructorId) {
        if (instructorId != null) {

            User instructor = userRepository.findById(instructorId)
                    .orElseThrow(() -> new ResourceNotFoundException("Instructor not found"));
            validateInstructorRole(instructor);
            return instructor;
        }
        return getCurrentUser();
    }

    private Set<Category> validateCategories(Set<Long> categoryIds) {
        if (categoryIds == null || categoryIds.isEmpty()) {
            throw new InvalidRequestException("Category IDs must not be empty");
        }

        try {
            ObjectMapper objectMapper = new ObjectMapper();

            // Find all categories
            Set<Category> foundCategories = new HashSet<>(categoryRepository.findAllById(categoryIds));

            // Check for non-existent categories
            if (foundCategories.size() != categoryIds.size()) {
                Set<Long> foundIds = foundCategories.stream()
                        .map(Category::getId)
                        .collect(Collectors.toSet());

                Set<Long> notFoundIds = categoryIds.stream()
                        .filter(id -> !foundIds.contains(id))
                        .collect(Collectors.toSet());

                String notFoundMessage = String.format("Categories not found: %s",
                        objectMapper.writeValueAsString(
                                notFoundIds.stream()
                                        .map(id -> Map.of(
                                                "id", id,
                                                "nameCategory", "Not Found"
                                        ))
                                        .collect(Collectors.toList())
                        )
                );

                throw new ResourceNotFoundException(notFoundMessage);
            }

            // Check for deleted categories
            Set<Category> deletedCategories = foundCategories.stream()
                    .filter(cat -> cat.getDeletedAt() != null)
                    .collect(Collectors.toSet());

            if (!deletedCategories.isEmpty()) {
                String deletedCategoriesMessage = String.format("Cannot use deleted categories: %s",
                        objectMapper.writeValueAsString(
                                deletedCategories.stream()
                                        .map(cat -> Map.of(
                                                "id", cat.getId(),
                                                "nameCategory", cat.getName()
                                        ))
                                        .collect(Collectors.toList())
                        )
                );

                throw new InvalidRequestException(deletedCategoriesMessage);
            }

            return foundCategories;

        } catch (JsonProcessingException e) {
            throw new InvalidRequestException("Error processing category validation");
        }
    }

    private void updateCourseCategories(Course course, Set<Long> categoryIds) {
        Set<Category> validCategories = validateCategories(categoryIds);
        course.getCategories().clear();
        validCategories.forEach(course::addCategory);

    }

    private Course getCourseWithValidation(Long id) {
        Course course = courseRepository.findByIdWithDetails(id)
                .orElseThrow(() -> new ResourceNotFoundException("Course not found"));
        validateCourseAccess(course);
        return course;
    }

    private Course GetCourseWithoutValidation(Long id) {
        return courseRepository.findByIdWithDetails(id)
                .orElseThrow(() -> new ResourceNotFoundException("Course not found"));
    }

    private User getCurrentUser() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        CustomUserDetails userDetails = (CustomUserDetails) authentication.getPrincipal();
        return userDetails.getUser();
    }

    private void validateCourseAccess(Course course) {
        if (!hasAdminRole() && !isInstructor(course)) {
            throw new ForbiddenException("You don't have permission to modify this course");
        }
    }

    private boolean isInstructor(Course course) {
        return course.getInstructor().getId().equals(getCurrentUser().getId());
    }

    private boolean hasAdminRole() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        return authentication.getAuthorities().stream()
                .anyMatch(a -> a.getAuthority().equals("ROLE_ADMIN"));
    }

    private void validateInstructorRole(User user) {
        boolean isInstructor = user.getUserRoles().stream()
                .anyMatch(role -> role.getRole().getName() == RoleType.INSTRUCTOR);
        if (!isInstructor) {
            throw new InvalidRequestException("User is not an instructor");
        }
    }

    // Update the helper method to handle Sort conversion
    private Sort createSort(Map<String, String> sortParams) {
        log.info("Sort params received: {}", sortParams);

        if (sortParams == null || sortParams.isEmpty()) {
            return Sort.by(Sort.Direction.DESC, DEFAULT_SORT_FIELD);
        }

        // Define mapping of sort fields to actual columns
        Map<String, String> fieldMappings = Map.of(
                "title", "title",
                "created_at", "created_at",
                "updated_at", "updated_at",
                "status", "status",
                "username", "instructor_username",
                "email", "instructor_email"
        );

        // Create sort orders dynamically
        List<Sort.Order> orders = sortParams.entrySet().stream()
                .map(entry -> {
                    String mappedField = fieldMappings.getOrDefault(entry.getKey(), entry.getKey());
                    Sort.Direction direction = entry.getValue().equalsIgnoreCase("asc") ?
                            Sort.Direction.ASC : Sort.Direction.DESC;

                    log.info("Creating sort order - field: {}, mapped to: {}, direction: {}",
                            entry.getKey(), mappedField, direction);

                    return new Sort.Order(direction, mappedField);
                })
                .collect(Collectors.toList());

        log.info("Final sort orders: {}", orders);
        return Sort.by(orders);
    }

    // Update the helper method to include all valid sort fields
    private void validateSortFields(Map<String, String> sort) {
        Set<String> validFields = Set.of(
                "title",
                "created_at",
                "updated_at",
                "status",
                "username",
                "email"
        );

        // Validate fields
        Set<String> invalidFields = sort.keySet().stream()
                .filter(field -> !validFields.contains(field))
                .collect(Collectors.toSet());

        if (!invalidFields.isEmpty()) {
            throw new InvalidRequestException(
                    "Invalid sort fields: " + String.join(", ", invalidFields) +
                            ". Valid fields are: " + String.join(", ", validFields)
            );
        }

        // Validate directions
        sort.values().forEach(direction -> {
            if (!direction.equalsIgnoreCase("asc") && !direction.equalsIgnoreCase("desc")) {
                throw new InvalidRequestException(
                        "Invalid sort direction: " + direction + ". Must be 'asc' or 'desc'"
                );
            }
        });
    }

    private void validateCourseStatus(CourseStatus currentStatus, CourseStatus newStatus) throws JsonProcessingException {
        if (newStatus == null) {
            throw new InvalidRequestException("Course status cannot be null");
        }

        // If it's a new course (currentStatus is null), only allow DRAFT
        if (currentStatus == null && newStatus != CourseStatus.DRAFT) {
            throw new InvalidRequestException(
                    String.format("New course must be created with status DRAFT, received: %s", newStatus)
            );
        }

        // Define valid transitions for each status
        Map<CourseStatus, Set<CourseStatus>> validTransitions = Map.of(
                CourseStatus.DRAFT, Set.of(CourseStatus.PUBLISHED, CourseStatus.ARCHIVED),
                CourseStatus.PUBLISHED, Set.of(CourseStatus.DRAFT, CourseStatus.ARCHIVED),
                CourseStatus.ARCHIVED, Set.of(CourseStatus.DRAFT)
        );


        // If current status exists, validate the transition
        if (currentStatus != null && !validTransitions.get(currentStatus).contains(newStatus)) {
            try {

                CourseStatus.valueOf(newStatus.name());
                ObjectMapper objectMapper = new ObjectMapper();
                String errorMessage = String.format("Invalid status transition: %s",
                        objectMapper.writeValueAsString(Map.of(
                                "currentStatus", currentStatus,
                                "newStatus", newStatus,
                                "allowedTransitions", validTransitions.get(currentStatus)
                        ))
                );
                throw new InvalidRequestException(errorMessage);
            } catch (IllegalArgumentException e) {
                ObjectMapper objectMapper = new ObjectMapper();
                String errorMessage = String.format("Invalid course status: %s",
                        objectMapper.writeValueAsString(Map.of(
                                "providedStatus", newStatus,
                                "allowedStatuses", Arrays.stream(CourseStatus.values())
                                        .map(Enum::name)
                                        .collect(Collectors.toList())
                        ))
                );
                throw new InvalidRequestException(errorMessage);
            }
        }
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/service/impl/UserServiceImpl.java">
package com.online.course.management.project.service.impl;

import com.online.course.management.project.dto.UserDTOs;
import com.online.course.management.project.entity.Role;
import com.online.course.management.project.entity.User;
import com.online.course.management.project.enums.RoleType;
import com.online.course.management.project.exception.business.ForbiddenException;
import com.online.course.management.project.exception.business.ResourceNotFoundException;
import com.online.course.management.project.mapper.UserMapper;
import com.online.course.management.project.repository.IRoleRepository;
import com.online.course.management.project.repository.IUserRepository;
import com.online.course.management.project.service.interfaces.IUserService;
import com.online.course.management.project.utils.user.UserServiceUtils;
import jakarta.transaction.Transactional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import lombok.extern.slf4j.Slf4j;

import java.time.LocalDateTime;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

@Service
@Slf4j
public class UserServiceImpl implements IUserService {

    private final IUserRepository userRepository;
    private final IRoleRepository roleRepository;
    private final PasswordEncoder passwordEncoder;
    private final UserMapper userMapper;
    private final UserServiceUtils userServiceUtils;

    @Autowired
    public UserServiceImpl(IUserRepository userRepository, IRoleRepository roleRepository, PasswordEncoder passwordEncoder, UserMapper userMapper, UserServiceUtils userServiceUtils) {
        this.userRepository = userRepository;
        this.roleRepository = roleRepository;
        this.passwordEncoder = passwordEncoder;
        this.userMapper = userMapper;
        this.userServiceUtils = userServiceUtils;
    }

    @Override
    @Transactional
    public UserDTOs.UserResponseDto registerUser(UserDTOs.UserRegistrationDto registrationDto) {
        log.info("Registering new user with email: {}", registrationDto.getEmail());
        userServiceUtils.validateNewUser(registrationDto);
        User user = userServiceUtils.createUserFromDto(registrationDto);
        userServiceUtils.assignDefaultRole(user);
        User savedUser = userRepository.save(user);

        log.info("User registered successfully with id: {}", savedUser.getId());
        return userMapper.toDto(savedUser);
    }


    @Override
    @Transactional
    public UserDTOs.UserResponseDto updateUserProfile(Long userId, UserDTOs.UpdateProfileDto updateProfileDto) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User not found"));

        userMapper.updateUserFromDto(updateProfileDto, user);

        if (updateProfileDto.getPassword() != null) {

            if (user.getUserRoles().stream().anyMatch(role -> role.getRole().getName() == RoleType.ADMIN)) {
                throw new ForbiddenException("Can not change password for admin user");
            }

            user.setPasswordHash(passwordEncoder.encode(updateProfileDto.getPassword()));
        }

        User updatedUser = userRepository.save(user);
        return userMapper.toDto(updatedUser);
    }

    /**
     * @param userId
     * @param newRoles
     * @param currentUserId
     */
    @Override
    @Transactional
    public Set<String> updateUserRoles(Long userId, Set<RoleType> newRoles, Long currentUserId) {

        log.info("Updating roles for user {}. New roles: {}", userId, newRoles);

        User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User not found"));


        boolean isInitialAdmin = "admin@gmail.com".equals(user.getEmail());
        boolean isCurrentlyAdmin = user.getUserRoles().stream()
                .anyMatch(userRole -> userRole.getRole().getName() == RoleType.ADMIN);
        boolean isAttemptingToAssignAdminRole = newRoles.contains(RoleType.ADMIN);

        // Prevent assigning ADMIN role to non-admin users
        if (!isCurrentlyAdmin && isAttemptingToAssignAdminRole) {
            throw new ForbiddenException("Cannot assign ADMIN role to a non-admin user");
        }

        boolean isRemovingAdminRole = isCurrentlyAdmin && !isAttemptingToAssignAdminRole;

        // Prevent removing ADMIN role from the initial admin account
        if (isInitialAdmin && isRemovingAdminRole) {
            throw new ForbiddenException("Cannot remove ADMIN role from the initial admin account");
        }

        // If the current user is updating their own roles
        if (userId.equals(currentUserId) && isRemovingAdminRole) {
            // Prevent users from removing their own ADMIN role
            throw new ForbiddenException("You cannot remove your own ADMIN role");

        }

        Set<Role> rolesToSet = newRoles.stream()
                .map(roleType -> roleRepository.findByName(roleType)
                        .orElseThrow(() -> new ResourceNotFoundException("Role not found: " + roleType)))
                .collect(Collectors.toSet());

        // log old roles of user
        log.info("Current user roles: {}", user.getUserRoles().stream()
                .map(ur -> ur.getRole().getName().name())
                .collect(Collectors.toSet()));

        // Clear existing roles and add new ones
        user.getUserRoles().clear();
        for (Role role : rolesToSet) {
            user.addRole(role);
        }

        User savedUser = userRepository.save(user);

        // Log the roles after saving
        Set<String> updatedRoles = savedUser.getUserRoles().stream()
                .map(userRole -> userRole.getRole().getName().name())
                .collect(Collectors.toSet());
        log.info("Updated roles for user {}: {}", userId, updatedRoles);

        return updatedRoles;
    }

    /**
     * @param pageable
     * @return
     */
    @Override
    public Page<UserDTOs.UserWithRolesResponseDto> getAllUsers(Pageable pageable) {
        Page<User> users = userRepository.findAll(pageable);
        return users.map(userMapper::toUserWithRolesDto);
    }


    @Override
    public Page<UserDTOs.UserWithRolesResponseDto> searchUsers(UserDTOs.UserSearchRequestDto searchUsersPayload, Pageable pageable) {
        Specification<User> querySpecification = userServiceUtils.createSpecification(searchUsersPayload);

        Page<User> users = userRepository.findAll(querySpecification, pageable);
        return users.map(userMapper::toUserWithRolesDto);
    }

    @Override
    public long countUsers(Optional<UserDTOs.UserSearchRequestDto> searchUsersPayload) {
        if (searchUsersPayload.isPresent()) {
            Specification<User> querySpecification = userServiceUtils.createSpecification(searchUsersPayload.get());
            return userRepository.count(querySpecification);
        } else {
            return userRepository.count();
        }
    }

    @Override
    @Cacheable(value = "users", key = "#id")
    public Optional<User> getUserById(Long id) {
        log.debug("Fetching user with id: {}", id);
        return userRepository.findById(id);
    }

    @Override
    public Optional<User> getUserByUsername(String username) {
        return userRepository.findByUsername(username);
    }

    @Override
    public Optional<User> getUserByEmail(String email) {
        return userRepository.findByEmail(email);
    }

    @Override
    @Transactional
    @CacheEvict(value = "users", key = "#user.id")
    public User updateUser(User user) {
        log.info("Updating user with id: {}", user.getId());
        return userRepository.save(user);
    }

    @Override
    @Transactional
    public void softDeleteUser(Long id) {


        userRepository.findById(id).ifPresent(user -> {

            if (user.getUserRoles().stream().anyMatch(role -> role.getRole().getName() == RoleType.ADMIN)) {
                throw new ForbiddenException("Can not delete admin user");
            }

            user.setDeletedAt(LocalDateTime.now());
            userRepository.save(user);
        });
    }

    @Override
    public boolean existsByUsername(String username) {
        return userRepository.existsByUsername(username);
    }

    @Override
    public boolean existsByEmail(String email) {
        return userRepository.existsByEmail(email);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/service/interfaces/ICategoryService.java">
package com.online.course.management.project.service.interfaces;

import com.online.course.management.project.dto.CategoryDTOs;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

public interface ICategoryService {
    CategoryDTOs.CategoryResponseDto createCategory(CategoryDTOs.CreateCategoryDTO request);

    CategoryDTOs.CategoryResponseDto updateCategory(Long id, CategoryDTOs.UpdateCategoryDTO request);

    void deleteCategory(Long id);

    CategoryDTOs.CategoryResponseDto getCategoryById(Long id);

    boolean isCategoryNameExist(String categoryName);

    Page<CategoryDTOs.CategoryResponseDto> searchCategories(CategoryDTOs.CategorySearchDTO request, Pageable pageable);

    void restoreCategory(Long id);
}
</file>

<file path="src/main/java/com/online/course/management/project/service/interfaces/ICourseService.java">
package com.online.course.management.project.service.interfaces;

import com.online.course.management.project.dto.CourseDTOS;
import com.online.course.management.project.enums.CourseStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.List;
import java.util.Optional;
import java.util.Set;

public interface ICourseService {
    /**
     * Creates a new course
     */
    CourseDTOS.CourseDetailsResponseDto createCourse(CourseDTOS.CreateCourseRequestDTO request);

    /**
     * Updates an existing course
     */
    CourseDTOS.CourseDetailsResponseDto updateCourse(Long id, CourseDTOS.UpdateCourseRequestDTO request);

    /**
     * Archives a course (soft delete)
     */
    void archiveCourse(Long id);

    /**
     * Restores an archived course
     */
    void unarchiveCourse(Long id);

    /**
     * Gets course details by ID
     */
    CourseDTOS.CourseDetailsResponseDto getCourseById(Long id);

    /**
     * Searches courses with filters and pagination
     */
    Page<CourseDTOS.CourseDetailsResponseDto> searchCourses(CourseDTOS.SearchCourseRequestDTO request, Pageable pageable);

    /**
     * Gets courses by instructor with pagination
     */
    Page<CourseDTOS.CourseDetailsResponseDto> getCoursesByInstructor(Long instructorId, boolean includeArchived, Pageable pageable);

    /**
     * Gets courses by status with pagination
     */
    Page<CourseDTOS.CourseDetailsResponseDto> getCoursesByStatus(CourseStatus status, Pageable pageable);

    /**
     * Gets the latest courses
     */
    List<CourseDTOS.CourseDetailsResponseDto> getLatestCourses(int limit);
}
</file>

<file path="src/main/java/com/online/course/management/project/service/interfaces/IUserService.java">
package com.online.course.management.project.service.interfaces;

import com.online.course.management.project.dto.UserDTOs;
import com.online.course.management.project.entity.User;
import com.online.course.management.project.enums.RoleType;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.time.LocalDateTime;
import java.util.Optional;
import java.util.Set;

public interface IUserService {
    UserDTOs.UserResponseDto registerUser(UserDTOs.UserRegistrationDto userRegistrationDto);

    Optional<User> getUserById(Long id);

    Optional<User> getUserByUsername(String username);

    Optional<User> getUserByEmail(String email);

    User updateUser(User user);

    void softDeleteUser(Long id);

    boolean existsByUsername(String username);

    boolean existsByEmail(String email);

    UserDTOs.UserResponseDto updateUserProfile(Long userId, UserDTOs.UpdateProfileDto updateProfileDto);

    Set<String> updateUserRoles(Long userId, Set<RoleType> roleNames, Long currentUserId);

    Page<UserDTOs.UserWithRolesResponseDto> getAllUsers(Pageable pageable);

    Page<UserDTOs.UserWithRolesResponseDto> searchUsers(
            UserDTOs.UserSearchRequestDto searchUsersPayload,
            Pageable pageable
    );

    long countUsers(Optional<UserDTOs.UserSearchRequestDto> searchUsersPayload);
}
</file>

<file path="src/main/java/com/online/course/management/project/utils/category/CategoryServiceUtils.java">
package com.online.course.management.project.utils.category;

import com.online.course.management.project.entity.Category;
import com.online.course.management.project.exception.business.ResourceNotFoundException;
import com.online.course.management.project.repository.ICategoryRepository;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

@Component
@Slf4j
public class CategoryServiceUtils {

    private final ICategoryRepository categoryRepository;

    public CategoryServiceUtils(ICategoryRepository categoryRepository) {
        this.categoryRepository = categoryRepository;
    }

    public Category getCategoryOrThrow(Long id) {
        return categoryRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Category not found with id: " + id));
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/utils/exception/GlobalExceptionUtils.java">
package com.online.course.management.project.utils.exception;

import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class GlobalExceptionUtils {
    public static List<String> getKnownProperties(Set<?> knownPropertyIds) {
        if (knownPropertyIds == null) {
            return List.of();
        }
        return knownPropertyIds.stream()
                .map(Object::toString)
                .sorted()
                .collect(Collectors.toList());
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/utils/generator/JwtSecretGenerator.java">
package com.online.course.management.project.utils.generator;

import java.security.SecureRandom;
import java.util.Base64;

public class JwtSecretGenerator {
    public static void main(String[] args) {
        SecureRandom random = new SecureRandom();
        byte[] secret = new byte[32]; // 256 bits
        random.nextBytes(secret);
        String encodedSecret = Base64.getEncoder().encodeToString(secret);
        System.out.println("Generated JWT Secret Key: " + encodedSecret);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/utils/generator/PasswordHashGenerator.java">
package com.online.course.management.project.utils.generator;

import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

public class PasswordHashGenerator {
    public static void main(String[] args) {
        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
        String password = "123456";
        String hash = encoder.encode(password);
        System.out.println("BCrypt hash for password '" + password + "':");
        System.out.println(hash);
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/utils/user/UserControllerUtils.java">
package com.online.course.management.project.utils.user;

import com.online.course.management.project.enums.RoleType;
import com.online.course.management.project.exception.business.InvalidRoleInfoException;
import com.online.course.management.project.exception.business.UnauthorizedException;
import com.online.course.management.project.exception.business.account.EmailAlreadyExistsException;
import com.online.course.management.project.exception.business.account.WrongEmailPasswordException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.stereotype.Component;

import java.util.HashSet;
import java.util.Set;

@Component
@Slf4j
public class UserControllerUtils {

    private final AuthenticationManager authenticationManager;

    public UserControllerUtils(AuthenticationManager authenticationManager) {
        this.authenticationManager = authenticationManager;
    }

    public Authentication authenticate(String usernameOrEmail, String password) {
        try {
            return authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(usernameOrEmail, password));
        } catch (AuthenticationException e) {
            log.error("Error during authentication", e);
            throw new WrongEmailPasswordException("Invalid username/email or password");
        }
    }

    public Set<RoleType> validateRoles(Set<String> roles) {
        Set<RoleType> validRoles = new HashSet<>();
        Set<String> invalidRoles = new HashSet<>();

        for (String role : roles) {
            try {
                validRoles.add(RoleType.valueOf(role.toUpperCase()));
            } catch (IllegalArgumentException e) {
                invalidRoles.add(role);
            }
        }

        if (!invalidRoles.isEmpty()) {
            throw new InvalidRoleInfoException("Invalid role(s) provided: " + String.join(", ", invalidRoles));
        }

        return validRoles;
    }
}
</file>

<file path="src/main/java/com/online/course/management/project/utils/user/UserServiceUtils.java">
package com.online.course.management.project.utils.user;

import com.online.course.management.project.dto.UserDTOs;
import com.online.course.management.project.entity.Role;
import com.online.course.management.project.entity.User;
import com.online.course.management.project.enums.RoleType;
import com.online.course.management.project.enums.UserStatus;
import com.online.course.management.project.exception.business.account.AccountException;
import com.online.course.management.project.exception.business.ResourceNotFoundException;
import com.online.course.management.project.exception.business.account.EmailAlreadyExistsException;
import com.online.course.management.project.mapper.UserMapper;
import com.online.course.management.project.repository.IRoleRepository;
import com.online.course.management.project.repository.IUserRepository;
import jakarta.persistence.criteria.Predicate;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;

@Component
@Slf4j
public class UserServiceUtils {
    private final IUserRepository userRepository;
    private final IRoleRepository roleRepository;
    private final UserMapper userMapper;
    private final PasswordEncoder passwordEncoder;


    public UserServiceUtils(IUserRepository userRepository, IRoleRepository roleRepository, UserMapper userMapper, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.roleRepository = roleRepository;
        this.userMapper = userMapper;
        this.passwordEncoder = passwordEncoder;

    }

    public String generateUsernameFromEmail(String email) {
        String baseUsername = email.split("@")[0];
        String username = baseUsername;
        int suffix = 1;

        while (userRepository.existsByUsername(username)) {
            username = baseUsername + suffix;
            suffix++;
        }

        return username;
    }

    public void assignDefaultRole(User user) {
        Role userRole = roleRepository.findByName(RoleType.USER)
                .orElseThrow(() -> new ResourceNotFoundException("Default user role not found"));
        user.addRole(userRole);
    }

    public void validateNewUser(UserDTOs.UserRegistrationDto registrationDto) {
        if (userRepository.existsByEmail(registrationDto.getEmail())) {
            throw new EmailAlreadyExistsException("Email already exists: " + registrationDto.getEmail());
        }
    }

    public User createUserFromDto(UserDTOs.UserRegistrationDto registrationDto) {
        User user = userMapper.toEntity(registrationDto);
        user.setUsername(generateUsernameFromEmail(registrationDto.getEmail()));
        user.setPasswordHash(passwordEncoder.encode(registrationDto.getPassword()));
        return user;
    }

    public Specification<User> createSpecification(UserDTOs.UserSearchRequestDto searchUsersPayload) {
        return (root, query, criteriaBuilder) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (searchUsersPayload.getUsername() != null && !searchUsersPayload.getUsername().isEmpty()) {
                predicates.add(criteriaBuilder.like(criteriaBuilder.lower(root.get("username")), "%" + searchUsersPayload.getUsername().toLowerCase() + "%"));
            }
            if (searchUsersPayload.getEmail() != null && !searchUsersPayload.getEmail().isEmpty()) {
                predicates.add(criteriaBuilder.like(criteriaBuilder.lower(root.get("email")), "%" + searchUsersPayload.getEmail().toLowerCase() + "%"));
            }
            if (searchUsersPayload.getRealName() != null && !searchUsersPayload.getRealName().isEmpty()) {
                predicates.add(criteriaBuilder.like(criteriaBuilder.lower(root.get("realName")), "%" + searchUsersPayload.getRealName().toLowerCase() + "%"));
            }
            if (searchUsersPayload.getStatus() != null && !searchUsersPayload.getStatus().isEmpty()) {
                predicates.add(criteriaBuilder.equal(root.get("status"), UserStatus.valueOf(searchUsersPayload.getStatus().toUpperCase())));
            }
            if (searchUsersPayload.getFromDate() != null) {
                predicates.add(criteriaBuilder.greaterThanOrEqualTo(root.get("createdAt"), searchUsersPayload.getFromDate()));
            }
            if (searchUsersPayload.getToDate() != null) {
                predicates.add(criteriaBuilder.lessThanOrEqualTo(root.get("createdAt"), searchUsersPayload.getToDate()));
            }

            return criteriaBuilder.and(predicates.toArray(new Predicate[0]));
        };
    }


}
</file>

<file path="src/main/resources/application.properties">
spring.datasource.url=jdbc:mysql://localhost:3306/onlinecoursemanagement
spring.datasource.username=Huyvictory
spring.datasource.password=12345
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
# JPA / Hibernate properties
spring.jpa.hibernate.ddl-auto=validate
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
spring.jpa.properties.hibernate.format_sql=true
# Flyway configuration
spring.flyway.enabled=true
spring.flyway.locations=classpath:db/migration
spring.flyway.baseline-version=7
spring.flyway.baseline-on-migrate=true
# Logging
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
logging.level.root=INFO
logging.level.org.springframework.security=DEBUG
logging.level.com.online.course.management.project=DEBUG
logging.pattern.console=%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(%5p) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %clr([%X{class}]){yellow} %clr([%X{method}]){yellow} %m%n%wEx
# JWT configuration
jwt.secret=tfHDo2eVbfqEZFAjEisFcgGpdyUuB7OrmqkW2J++4CY=
jwt.expiration=3600
# Cache configuration
spring.cache.type=caffeine
spring.cache.caffeine.spec=maximumSize=500,expireAfterWrite=60m
# Output
spring.output.ansi.enabled=ALWAYS
# Exception handling
spring.mvc.throw-exception-if-no-handler-found=true
spring.web.resources.add-mappings=false
spring.jackson.deserialization.fail-on-unknown-properties=true
server.error.path=/error
</file>

<file path="src/main/resources/db/migration/V10__Update_non_admin_passwords.sql">
-- V10__Update_non_admin_passwords.sql

-- Create a temporary function to generate BCrypt hash
DELIMITER //

DROP FUNCTION IF EXISTS bcrypt_hash//
CREATE FUNCTION bcrypt_hash(password VARCHAR(255)) RETURNS VARCHAR(255)
    DETERMINISTIC
BEGIN
    -- BCrypt hash for password '123456'
    -- This is equivalent to BCryptPasswordEncoder.encode("123456")
RETURN '$2a$10$wtXh4Q7bsC.6y4D.yKvbl.X9D4TNeSXz70rCz63PVtb9xoyxC0Jly';
END//

DELIMITER ;

-- Update passwords for all non-admin users
UPDATE users u
    LEFT JOIN user_roles ur ON u.id = ur.user_id
    LEFT JOIN roles r ON ur.role_id = r.id
    SET u.password_hash = bcrypt_hash('123456')
WHERE u.email != 'admin@gmail.com'  -- Exclude admin user
  AND (r.name != 'ADMIN' OR r.name IS NULL);  -- Extra safety check for non-admin users

-- Log the number of updated users
SELECT CONCAT('Updated passwords for ', ROW_COUNT(), ' users') as migration_log;

-- Clean up
DROP FUNCTION IF EXISTS bcrypt_hash;
</file>

<file path="src/main/resources/db/migration/V11__Update_non_admin_passwords.sql">
-- V10__Update_non_admin_passwords.sql

-- Create a temporary function to generate BCrypt hash
DELIMITER //

DROP FUNCTION IF EXISTS bcrypt_hash//
CREATE FUNCTION bcrypt_hash(password VARCHAR(255)) RETURNS VARCHAR(255)
    DETERMINISTIC
BEGIN
    -- BCrypt hash for password '123456'
    -- This is equivalent to BCryptPasswordEncoder.encode("123456")
RETURN '$2a$10$wtXh4Q7bsC.6y4D.yKvbl.X9D4TNeSXz70rCz63PVtb9xoyxC0Jly';
END//

DELIMITER ;

-- Update passwords for all non-admin users
UPDATE users u
    LEFT JOIN user_roles ur ON u.id = ur.user_id
    LEFT JOIN roles r ON ur.role_id = r.id
    SET u.password_hash = bcrypt_hash('123456')
WHERE u.email != 'admin@gmail.com'  -- Exclude admin user
  AND (r.name != 'ADMIN' OR r.name IS NULL);  -- Extra safety check for non-admin users

-- Log the number of updated users
SELECT CONCAT('Updated passwords for ', ROW_COUNT(), ' users') as migration_log;

-- Clean up
DROP FUNCTION IF EXISTS bcrypt_hash;
</file>

<file path="src/main/resources/db/migration/V2__Update_User_table.sql">
-- V2__Update_user_table.sql

-- Rename 'name' column to 'real_name' if it exists
SET @renameColumn = (SELECT IF(
                                    EXISTS(SELECT *
                                           FROM information_schema.COLUMNS
                                           WHERE TABLE_SCHEMA = DATABASE()
                                             AND TABLE_NAME = 'users'
                                             AND COLUMN_NAME = 'name'),
                                    'ALTER TABLE users CHANGE COLUMN name real_name VARCHAR(100)',
                                    'SELECT 1'
                            ));
PREPARE renameStmt FROM @renameColumn;
EXECUTE renameStmt;
DEALLOCATE PREPARE renameStmt;

-- Add 'real_name' column if it doesn't exist
SET @addColumn = (SELECT IF(
                                 NOT EXISTS(SELECT *
                                            FROM information_schema.COLUMNS
                                            WHERE TABLE_SCHEMA = DATABASE()
                                              AND TABLE_NAME = 'users'
                                              AND COLUMN_NAME = 'real_name'),
                                 'ALTER TABLE users ADD COLUMN real_name VARCHAR(100)',
                                 'SELECT 1'
                         ));
PREPARE addStmt FROM @addColumn;
EXECUTE addStmt;
DEALLOCATE PREPARE addStmt;

-- Add other new columns if they don't exist
SET @addCreatedAt = (SELECT IF(
                                    NOT EXISTS(SELECT *
                                               FROM information_schema.COLUMNS
                                               WHERE TABLE_SCHEMA = DATABASE()
                                                 AND TABLE_NAME = 'users'
                                                 AND COLUMN_NAME = 'created_at'),
                                    'ALTER TABLE users ADD COLUMN created_at DATETIME',
                                    'SELECT 1'
                            ));
PREPARE addCreatedAtStmt FROM @addCreatedAt;
EXECUTE addCreatedAtStmt;
DEALLOCATE PREPARE addCreatedAtStmt;

SET @addUpdatedAt = (SELECT IF(
                                    NOT EXISTS(SELECT *
                                               FROM information_schema.COLUMNS
                                               WHERE TABLE_SCHEMA = DATABASE()
                                                 AND TABLE_NAME = 'users'
                                                 AND COLUMN_NAME = 'updated_at'),
                                    'ALTER TABLE users ADD COLUMN updated_at DATETIME',
                                    'SELECT 1'
                            ));
PREPARE addUpdatedAtStmt FROM @addUpdatedAt;
EXECUTE addUpdatedAtStmt;
DEALLOCATE PREPARE addUpdatedAtStmt;

SET @addDeletedAt = (SELECT IF(
                                    NOT EXISTS(SELECT *
                                               FROM information_schema.COLUMNS
                                               WHERE TABLE_SCHEMA = DATABASE()
                                                 AND TABLE_NAME = 'users'
                                                 AND COLUMN_NAME = 'deleted_at'),
                                    'ALTER TABLE users ADD COLUMN deleted_at DATETIME',
                                    'SELECT 1'
                            ));
PREPARE addDeletedAtStmt FROM @addDeletedAt;
EXECUTE addDeletedAtStmt;
DEALLOCATE PREPARE addDeletedAtStmt;

-- Modify existing columns
ALTER TABLE users
    MODIFY COLUMN username VARCHAR(50) NOT NULL,
    MODIFY COLUMN email VARCHAR(320) NOT NULL,
    MODIFY COLUMN password_hash VARCHAR(60) NOT NULL;

-- Add unique constraints if they don't exist
SET @addUsernameConstraint = (SELECT IF(
                                             NOT EXISTS(SELECT *
                                                        FROM information_schema.TABLE_CONSTRAINTS
                                                        WHERE CONSTRAINT_SCHEMA = DATABASE()
                                                          AND TABLE_NAME = 'users'
                                                          AND CONSTRAINT_NAME = 'uk_users_username'),
                                             'ALTER TABLE users ADD CONSTRAINT uk_users_username UNIQUE (username)',
                                             'SELECT 1'
                                     ));
PREPARE usernameConstraintStmt FROM @addUsernameConstraint;
EXECUTE usernameConstraintStmt;
DEALLOCATE PREPARE usernameConstraintStmt;

SET @addEmailConstraint = (SELECT IF(
                                          NOT EXISTS(SELECT *
                                                     FROM information_schema.TABLE_CONSTRAINTS
                                                     WHERE CONSTRAINT_SCHEMA = DATABASE()
                                                       AND TABLE_NAME = 'users'
                                                       AND CONSTRAINT_NAME = 'uk_users_email'),
                                          'ALTER TABLE users ADD CONSTRAINT uk_users_email UNIQUE (email)',
                                          'SELECT 1'
                                  ));
PREPARE emailConstraintStmt FROM @addEmailConstraint;
EXECUTE emailConstraintStmt;
DEALLOCATE PREPARE emailConstraintStmt;

-- Update existing rows to set created_at and updated_at if they are NULL
UPDATE users
SET created_at = NOW(),
    updated_at = NOW()
WHERE created_at IS NULL
   OR updated_at IS NULL;
</file>

<file path="src/main/resources/db/migration/V3__Add_status_to_users.sql">
-- V3__Add_status_to_users.sql

-- Add status column if it doesn't exist
SET
@addStatus = (SELECT IF(
    NOT EXISTS(
        SELECT * FROM information_schema.COLUMNS
        WHERE TABLE_SCHEMA = DATABASE()
        AND TABLE_NAME = 'users'
        AND COLUMN_NAME = 'status'
    ),
    'ALTER TABLE users ADD COLUMN status VARCHAR(20) NOT NULL DEFAULT "ACTIVE"',
    'SELECT 1'
));

PREPARE addStatusStmt FROM @addStatus;
EXECUTE addStatusStmt;
DEALLOCATE PREPARE addStatusStmt;

-- Update existing rows to set status if they are NULL
UPDATE users
SET status = 'ACTIVE'
WHERE status IS NULL;

-- Add constraint to ensure status is one of the allowed values
ALTER TABLE users
    ADD CONSTRAINT chk_users_status
        CHECK (status IN ('ACTIVE', 'INACTIVE', 'SUSPENDED'));
</file>

<file path="src/main/resources/db/migration/V4__Add_course_and_category_tables.sql">
-- V4__Add_course_and_category_tables.sql

-- Drop any tables that might have been partially created
DROP TABLE IF EXISTS course_categories;
DROP TABLE IF EXISTS courses;
DROP TABLE IF EXISTS categories;

-- Create Categories table if not exists
SET @createCategories = (SELECT IF(
                                        NOT EXISTS(SELECT *
                                                   FROM information_schema.TABLES
                                                   WHERE TABLE_SCHEMA = DATABASE()
                                                     AND TABLE_NAME = 'categories'),
                                        'CREATE TABLE categories (
                                            id BIGINT AUTO_INCREMENT PRIMARY KEY,
                                            name VARCHAR(100) NOT NULL UNIQUE,
                                            created_at DATETIME NOT NULL,
                                            updated_at DATETIME NOT NULL,
                                            deleted_at DATETIME
                                        )',
                                        'SELECT 1'
                                ));

PREPARE createCategoriesStmt FROM @createCategories;
EXECUTE createCategoriesStmt;
DEALLOCATE PREPARE createCategoriesStmt;

-- Create Courses table if not exists
SET @createCourses = (SELECT IF(
                                     NOT EXISTS(SELECT *
                                                FROM information_schema.TABLES
                                                WHERE TABLE_SCHEMA = DATABASE()
                                                  AND TABLE_NAME = 'courses'),
                                     'CREATE TABLE courses (
                                         id BIGINT AUTO_INCREMENT PRIMARY KEY,
                                         title VARCHAR(255) NOT NULL,
                                         description TEXT,
                                         instructor_id BIGINT NOT NULL,
                                         status VARCHAR(20) NOT NULL,
                                         created_at DATETIME NOT NULL,
                                         updated_at DATETIME NOT NULL,
                                         deleted_at DATETIME,
                                         FOREIGN KEY (instructor_id) REFERENCES users(id),
                                         CONSTRAINT chk_courses_status CHECK (status IN ("DRAFT", "PUBLISHED", "ARCHIVED"))
                                     )',
                                     'SELECT 1'
                             ));

PREPARE createCoursesStmt FROM @createCourses;
EXECUTE createCoursesStmt;
DEALLOCATE PREPARE createCoursesStmt;

-- Create Course_Categories junction table if not exists
SET @createCourseCategories = (SELECT IF(
                                              NOT EXISTS(SELECT *
                                                         FROM information_schema.TABLES
                                                         WHERE TABLE_SCHEMA = DATABASE()
                                                           AND TABLE_NAME = 'course_categories'),
                                              'CREATE TABLE course_categories (
                                                  course_id BIGINT NOT NULL,
                                                  category_id BIGINT NOT NULL,
                                                  PRIMARY KEY (course_id, category_id),
                                                  FOREIGN KEY (course_id) REFERENCES courses(id),
                                                  FOREIGN KEY (category_id) REFERENCES categories(id)
                                              )',
                                              'SELECT 1'
                                      ));

PREPARE createCourseCategoriesStmt FROM @createCourseCategories;
EXECUTE createCourseCategoriesStmt;
DEALLOCATE PREPARE createCourseCategoriesStmt;
</file>

<file path="src/main/resources/db/migration/V5__Add_indexes_to_course_and_category.sql">
-- V5__Add_indexes_to_course_and_category.sql

-- Add index for instructor_id in courses table
CREATE INDEX idx_courses_instructor ON courses(instructor_id);

-- Add index for status in courses table
CREATE INDEX idx_courses_status ON courses(status);

-- Add index for deleted_at in courses table
CREATE INDEX idx_courses_deleted_at ON courses(deleted_at);

-- Add index for deleted_at in categories table
CREATE INDEX idx_categories_deleted_at ON categories(deleted_at);

-- Add index for name in categories table for faster lookups
CREATE INDEX idx_categories_name ON categories(name);
</file>

<file path="src/main/resources/db/migration/V6__Add_course_status_validation.sql">
-- V6__Add_course_status_validation.sql

-- Drop existing constraint if it exists
SET @constraint_name = (
    SELECT CONSTRAINT_NAME
    FROM information_schema.TABLE_CONSTRAINTS
    WHERE TABLE_NAME = 'courses'
    AND CONSTRAINT_TYPE = 'CHECK'
    AND CONSTRAINT_SCHEMA = DATABASE()
);

SET @drop_sql = IF(@constraint_name IS NOT NULL,
    CONCAT('ALTER TABLE courses DROP CONSTRAINT ', @constraint_name),
    'SELECT 1'
);

PREPARE stmt FROM @drop_sql;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

-- Add new constraint that enforces archived course logic
ALTER TABLE courses
    ADD CONSTRAINT chk_courses_status_deleted
        CHECK (
            (status = 'ARCHIVED' AND deleted_at IS NOT NULL) OR
            (status != 'ARCHIVED' AND deleted_at IS NULL)
            );

-- Drop existing trigger if exists
DROP TRIGGER IF EXISTS trg_course_archive_before_update;

-- Create trigger for handling course archiving
CREATE TRIGGER trg_course_archive_before_update
    BEFORE UPDATE ON courses
    FOR EACH ROW
BEGIN
    IF NEW.status = 'ARCHIVED' AND OLD.status != 'ARCHIVED' THEN
        SET NEW.deleted_at = CURRENT_TIMESTAMP;
        SET NEW.updated_at = CURRENT_TIMESTAMP;
    ELSEIF NEW.status != 'ARCHIVED' AND OLD.status = 'ARCHIVED' THEN
        SET NEW.deleted_at = NULL;
        SET NEW.updated_at = CURRENT_TIMESTAMP;
END IF;
END;

-- Update any existing inconsistent data
UPDATE courses
SET deleted_at = CURRENT_TIMESTAMP
WHERE status = 'ARCHIVED' AND deleted_at IS NULL;

UPDATE courses
SET deleted_at = NULL
WHERE status != 'ARCHIVED' AND deleted_at IS NOT NULL;
</file>

<file path="src/main/resources/db/migration/V7__Add_course_and_category_triggers.sql">
-- V7__Add_course_and_category_triggers.sql

-- Drop existing triggers if they exist
DROP TRIGGER IF EXISTS trg_course_archive_before_update;
DROP TRIGGER IF EXISTS trg_category_soft_delete_before_update;
DROP TRIGGER IF EXISTS trg_course_category_validation;

-- Create trigger for handling course archiving
CREATE TRIGGER trg_course_archive_before_update
    BEFORE UPDATE
    ON courses
    FOR EACH ROW
BEGIN
    -- When archiving a course
    IF NEW.status = 'ARCHIVED' AND OLD.status != 'ARCHIVED' THEN
        SET NEW.deleted_at = CURRENT_TIMESTAMP;
        SET NEW.updated_at = CURRENT_TIMESTAMP;
    -- When un-archiving a course
    ELSEIF NEW.status != 'ARCHIVED' AND OLD.status = 'ARCHIVED' THEN
        SET NEW.deleted_at = NULL;
        SET NEW.updated_at = CURRENT_TIMESTAMP;
END IF;
END;

-- Create trigger for handling category soft delete
CREATE TRIGGER trg_category_soft_delete_before_update
    BEFORE UPDATE
    ON categories
    FOR EACH ROW
BEGIN
    -- When soft deleting a category
    IF NEW.deleted_at IS NOT NULL AND OLD.deleted_at IS NULL THEN
        -- Delete all course-category relationships for this category
    DELETE
    FROM course_categories
    WHERE category_id = OLD.id;

    SET NEW.updated_at = CURRENT_TIMESTAMP;
    -- When restoring a category
    ELSEIF NEW.deleted_at IS NULL AND OLD.deleted_at IS NOT NULL THEN
        SET NEW.updated_at = CURRENT_TIMESTAMP;
END IF;
END;

-- Create trigger to prevent invalid course-category relationships
CREATE TRIGGER trg_course_category_validation
    BEFORE INSERT
    ON course_categories
    FOR EACH ROW
BEGIN
    DECLARE course_status VARCHAR(20);
    DECLARE category_deleted_at DATETIME;

    -- Get course status
    SELECT status, deleted_at
    INTO course_status
    FROM courses
    WHERE id = NEW.course_id;

    -- Get category deleted_at
    SELECT deleted_at
    INTO category_deleted_at
    FROM categories
    WHERE id = NEW.category_id;

    -- Prevent adding relationships for archived courses or deleted categories
    IF course_status = 'ARCHIVED' OR category_deleted_at IS NOT NULL THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Cannot create relationship: Course is archived or Category is deleted';
END IF;
END;

-- Update any existing inconsistent data
UPDATE courses
SET deleted_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE status = 'ARCHIVED'
  AND deleted_at IS NULL;

UPDATE courses
SET deleted_at = NULL,
    updated_at = CURRENT_TIMESTAMP
WHERE status != 'ARCHIVED' AND deleted_at IS NOT NULL;

-- Remove any invalid course-category relationships
DELETE
cc FROM course_categories cc
INNER JOIN courses c ON cc.course_id = c.id
WHERE c.status = 'ARCHIVED';

DELETE
cc FROM course_categories cc
INNER JOIN categories cat ON cc.category_id = cat.id
WHERE cat.deleted_at IS NOT NULL;
</file>

<file path="src/main/resources/db/migration/V8__Make_instructor_id_nullable.sql">
-- V8__Make_instructor_id_nullable.sql

-- First, drop the foreign key constraint if it exists
SET @constraint_name = (
    SELECT CONSTRAINT_NAME
    FROM information_schema.KEY_COLUMN_USAGE
    WHERE TABLE_NAME = 'courses'
    AND COLUMN_NAME = 'instructor_id'
    AND REFERENCED_TABLE_NAME = 'users'
    AND CONSTRAINT_SCHEMA = DATABASE()
);

SET @drop_fk_sql = IF(
    @constraint_name IS NOT NULL,
    CONCAT('ALTER TABLE courses DROP FOREIGN KEY ', @constraint_name),
    'SELECT 1'
);

PREPARE stmt FROM @drop_fk_sql;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

-- Now modify the instructor_id column to be nullable
ALTER TABLE courses
    MODIFY COLUMN instructor_id BIGINT NULL;

-- Re-add the foreign key constraint but allow NULL values
ALTER TABLE courses
    ADD CONSTRAINT fk_courses_instructor
        FOREIGN KEY (instructor_id) REFERENCES users(id);

-- Add an index on instructor_id if it doesn't exist already
SET @index_exists = (
    SELECT COUNT(*)
    FROM information_schema.STATISTICS
    WHERE TABLE_SCHEMA = DATABASE()
    AND TABLE_NAME = 'courses'
    AND INDEX_NAME = 'idx_courses_instructor'
);

SET @create_index_sql = IF(
    @index_exists = 0,
    'CREATE INDEX idx_courses_instructor ON courses(instructor_id)',
    'SELECT 1'
);

PREPARE stmt FROM @create_index_sql;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
</file>

<file path="src/main/resources/db/migration/V9__Add_course_archive_category_trigger.sql">
-- V9__Add_course_archive_category_trigger.sql

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS trg_course_archive_status_update;

DELIMITER //

CREATE TRIGGER trg_course_archive_status_update
    AFTER UPDATE ON courses
    FOR EACH ROW
BEGIN
    -- When course is archived, remove all its category associations
    IF NEW.status = 'ARCHIVED' AND OLD.status != 'ARCHIVED' THEN
        -- Log the removal (optional, for debugging)
        -- INSERT INTO logs (message) VALUES (CONCAT('Removing categories for archived course: ', NEW.id));

    DELETE FROM course_categories
    WHERE course_id = NEW.id;
END IF;
END//

DELIMITER ;
</file>

<file path="src/main/resources/Python_Scripts/generate_courses_categories.py">
import mysql.connector
import random
from datetime import datetime, timedelta
from faker import Faker

# Initialize Faker
fake = Faker()

# Database configuration
db_config = {
    'host': 'localhost',
    'user': 'Huyvictory',
    'password': '12345',
    'database': 'onlinecoursemanagement'
}

def generate_unique_category_name(existing_names, base_name=None):
    """Generate a unique category name using Faker"""
    while True:
        if base_name:
            name = f"{base_name} {fake.word().capitalize()}"
        else:
            name_types = [
                lambda: f"{fake.job()} Training",
                lambda: f"{fake.word().capitalize()} Studies",
                lambda: f"Advanced {fake.word().capitalize()}",
                lambda: f"{fake.currency_name()} Management",
                lambda: f"{fake.job()} Development",
                lambda: f"Professional {fake.job()}",
                lambda: f"{fake.company_suffix()} Management",
                lambda: f"Digital {fake.word().capitalize()}",
                lambda: f"{fake.word().capitalize()} Technology",
                lambda: f"{fake.word().capitalize()} Innovation"
            ]
            name = random.choice(name_types)()

        if name not in existing_names and len(name) <= 100:
            existing_names.add(name)
            return name

def connect_to_database():
    try:
        return mysql.connector.connect(**db_config)
    except mysql.connector.Error as err:
        print(f"Error connecting to database: {err}")
        raise

def generate_random_dates():
    """Generate random created_at and updated_at dates"""
    start_date = datetime(2023, 1, 1)
    end_date = datetime(2024, 10, 26)

    created_at = fake.date_time_between(start_date=start_date, end_date=end_date)
    # updated_at should be between created_at and end_date
    updated_at = fake.date_time_between(start_date=created_at, end_date=end_date)

    return created_at, updated_at

def generate_course_description():
    return (f"This comprehensive course focuses on {fake.catch_phrase()}. "
            f"Learn essential skills in {fake.bs()}. "
            f"Master the fundamentals with hands-on projects and real-world applications. "
            f"By the end of this course, you'll be proficient in {fake.catch_phrase()}.")

def generate_categories(num_categories):
    categories = []
    existing_names = set()

    # Define main subject areas
    main_areas = [
        "Programming", "Business", "Design", "Marketing",
        "Technology", "Arts", "Engineering", "Communication",
        "Data Science", "Digital Media"
    ]

    # First, create categories based on main areas
    for area in main_areas:
        if len(categories) < num_categories:
            name = generate_unique_category_name(existing_names, area)
            created_at, updated_at = generate_random_dates()
            categories.append({
                'id': len(categories) + 1,
                'name': name,
                'created_at': created_at,
                'updated_at': updated_at,
                'deleted_at': None
            })

    # Then fill up remaining categories with random names
    while len(categories) < num_categories:
        name = generate_unique_category_name(existing_names)
        created_at, updated_at = generate_random_dates()
        categories.append({
            'id': len(categories) + 1,
            'name': name,
            'created_at': created_at,
            'updated_at': updated_at,
            'deleted_at': None
        })

    return categories

def generate_courses(num_courses, instructor_ids):
    courses = []
    existing_titles = set()

    course_prefixes = [
        "Mastering", "Advanced", "Introduction to", "Professional",
        "Complete Guide to", "Essential", "Practical", "Modern",
        "Fundamentals of", "Ultimate"
    ]

    for i in range(1, num_courses + 1):
        while True:
            prefix = random.choice(course_prefixes)
            title = f"{prefix} {fake.job()} {fake.word().capitalize()}"
            if title not in existing_titles and len(title) <= 255:
                existing_titles.add(title)
                break

        created_at, updated_at = generate_random_dates()
        status = random.choice(['DRAFT', 'PUBLISHED', 'ARCHIVED'])

        # Set deleted_at for ARCHIVED courses
        deleted_at = None
        if status == 'ARCHIVED':
            # deleted_at should be after created_at and updated_at
            deleted_at = fake.date_time_between(
                start_date=max(created_at, updated_at),
                end_date=datetime(2024, 10, 26)
            )

        courses.append({
            'id': i,
            'title': title,
            'description': generate_course_description(),
            'instructor_id': random.choice(instructor_ids),
            'status': status,
            'created_at': created_at,
            'updated_at': updated_at,
            'deleted_at': deleted_at
        })

    return courses

def insert_test_data():
    try:
        conn = connect_to_database()
        cursor = conn.cursor()

        # Clear existing data
        cursor.execute("SET FOREIGN_KEY_CHECKS = 0")
        cursor.execute("TRUNCATE TABLE course_categories")
        cursor.execute("TRUNCATE TABLE courses")
        cursor.execute("TRUNCATE TABLE categories")
        cursor.execute("SET FOREIGN_KEY_CHECKS = 1")

        # Get instructor IDs
        cursor.execute("""
            SELECT DISTINCT u.id 
            FROM users u 
            JOIN user_roles ur ON u.id = ur.user_id 
            JOIN roles r ON ur.role_id = r.id 
            WHERE r.name = 'INSTRUCTOR'
        """)
        instructor_ids = [row[0] for row in cursor.fetchall()]

        if not instructor_ids:
            print("No instructors found. Please add instructors to the database first.")
            return

        # Insert categories
        categories = generate_categories(50)
        category_sql = """
        INSERT INTO categories (id, name, created_at, updated_at, deleted_at)
        VALUES (%s, %s, %s, %s, %s)
        """
        for category in categories:
            cursor.execute(category_sql, (
                category['id'],
                category['name'],
                category['created_at'],
                category['updated_at'],
                category['deleted_at']
            ))

        # Insert courses
        courses = generate_courses(50, instructor_ids)
        course_sql = """
        INSERT INTO courses (id, title, description, instructor_id, status, 
                           created_at, updated_at, deleted_at)
        VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
        """
        for course in courses:
            cursor.execute(course_sql, (
                course['id'],
                course['title'],
                course['description'],
                course['instructor_id'],
                course['status'],
                course['created_at'],
                course['updated_at'],
                course['deleted_at']
            ))

        # Create course-category relationships
        course_category_sql = """
        INSERT INTO course_categories (course_id, category_id)
        VALUES (%s, %s)
        """

        for course in courses:
            # Only create relationships for non-archived courses
            if course['status'] != 'ARCHIVED':
                # Assign 1-3 random categories to each course
                num_categories = random.randint(1, 3)
                selected_categories = random.sample([cat['id'] for cat in categories], num_categories)

                for category_id in selected_categories:
                    cursor.execute(course_category_sql, (course['id'], category_id))

        conn.commit()
        print(f"""
Test data generated successfully:
- {len(categories)} unique categories inserted
- {len(courses)} unique courses inserted
- Course status breakdown:
  {sum(1 for c in courses if c['status'] == 'DRAFT')} DRAFT courses
  {sum(1 for c in courses if c['status'] == 'PUBLISHED')} PUBLISHED courses
  {sum(1 for c in courses if c['status'] == 'ARCHIVED')} ARCHIVED courses (with deleted_at set)
- Multiple course-category relationships created for non-archived courses

Sample courses:
{[(course['title'], course['status'], course['deleted_at'].strftime('%Y-%m-%d %H:%M:%S') if course['deleted_at'] else 'None') for course in courses[:5]]}
        """)

    except mysql.connector.Error as err:
        print(f"Error: {err}")
        conn.rollback()
    finally:
        if conn.is_connected():
            cursor.close()
            conn.close()

if __name__ == "__main__":
    insert_test_data()
</file>

<file path="src/main/resources/Python_Scripts/generate_users.py">
import mysql.connector
import random
from datetime import datetime, timedelta
import bcrypt
from faker import Faker
import unicodedata

# Initialize Faker
fake = Faker()

# Database configuration
db_config = {
    'host': 'localhost',
    'user': 'Huyvictory',
    'password': '12345',
    'database': 'onlinecoursemanagement'
}

# Fixed password for all users
FIXED_PASSWORD = "12345"


def remove_accents(input_str):
    """Remove diacritics from a string and return ASCII-only characters"""
    nfkd_form = unicodedata.normalize('NFKD', input_str)
    return u"".join([c for c in nfkd_form if not unicodedata.combining(c)])


def generate_password_hash(password):
    salt = bcrypt.gensalt()
    return bcrypt.hashpw(password.encode('utf-8'), salt).decode('utf-8')


def generate_random_date_2024():
    start_date = datetime(2024, 1, 1)
    end_date = datetime(2024, 12, 31)
    return fake.date_time_between(start_date=start_date, end_date=end_date)


def generate_unique_username(cursor, name):
    """Generate a unique username based on name"""
    # Remove accents and special characters, convert to lowercase
    base_username = remove_accents(name.lower().replace(' ', ''))
    username = base_username
    counter = 1

    while True:
        cursor.execute("SELECT COUNT(*) FROM users WHERE username = %s", (username,))
        if cursor.fetchone()[0] == 0:
            return username
        username = f"{base_username}{counter}"
        counter += 1


def generate_unique_email(cursor, name):
    """Generate a unique email based on name"""
    # Remove accents and special characters, convert to lowercase
    base_email = remove_accents(name.lower().replace(' ', '.'))
    email = f"{base_email}@{fake.free_email_domain()}"
    counter = 1

    while True:
        cursor.execute("SELECT COUNT(*) FROM users WHERE email = %s", (email,))
        if cursor.fetchone()[0] == 0:
            return email
        email = f"{base_email}{counter}@{fake.free_email_domain()}"
        counter += 1


def insert_user(cursor, role_type, count):
    users = []
    for i in range(count):
        # Generate profile based on role
        if role_type == "INSTRUCTOR":
            profile = {
                'name': fake.name(),
                'job': fake.job(),
                'profile': fake.text(max_nb_chars=200)
            }
        else:
            profile = {
                'name': fake.name()
            }

        # Generate unique username and email
        username = generate_unique_username(cursor, profile['name'])
        email = generate_unique_email(cursor, profile['name'])

        # Common user data
        created_at = generate_random_date_2024()
        updated_at = created_at
        password_hash = generate_password_hash(FIXED_PASSWORD)
        status = random.choices(['ACTIVE', 'INACTIVE'], weights=[90, 10])[0]

        # Insert user
        insert_user_sql = """
        INSERT INTO users (username, email, password_hash, real_name, status, created_at, updated_at)
        VALUES (%s, %s, %s, %s, %s, %s, %s)
        """
        user_values = (username, email, password_hash, profile['name'], status, created_at, updated_at)
        cursor.execute(insert_user_sql, user_values)
        user_id = cursor.lastrowid
        users.append({
            'id': user_id,
            'username': username,
            'email': email,
            'name': profile['name'],
            'created_at': created_at,
            'password': FIXED_PASSWORD  # Added to show in output
        })

        # Get role ID
        cursor.execute("SELECT id FROM roles WHERE name = %s", (role_type,))
        role_id = cursor.fetchone()[0]

        # Insert user_role
        insert_user_role_sql = """
        INSERT INTO user_roles (user_id, role_id, assigned_at)
        VALUES (%s, %s, %s)
        """
        user_role_values = (user_id, role_id, created_at)
        cursor.execute(insert_user_role_sql, user_role_values)

    return users


def main():
    try:
        # Connect to database
        conn = mysql.connector.connect(**db_config)
        cursor = conn.cursor()

        print(f"Starting user generation... (All users will have password: {FIXED_PASSWORD})\n")

        # Insert normal users
        print("Generating normal users...")
        normal_users = insert_user(cursor, "USER", 10)
        print(f"\nCreated {len(normal_users)} normal users:")
        for user in normal_users:
            print(f"- Name: {user['name']}")
            print(f"  Username: {user['username']}")
            print(f"  Email: {user['email']}")
            print(f"  Password: {user['password']}")
            print(f"  Created: {user['created_at']}")
            print()

        # Insert instructors
        print("\nGenerating instructors...")
        instructors = insert_user(cursor, "INSTRUCTOR", 10)
        print(f"\nCreated {len(instructors)} instructors:")
        for user in instructors:
            print(f"- Name: {user['name']}")
            print(f"  Username: {user['username']}")
            print(f"  Email: {user['email']}")
            print(f"  Password: {user['password']}")
            print(f"  Created: {user['created_at']}")
            print()

        # Commit the changes
        conn.commit()
        print("\nAll users created successfully!")
        print(f"Remember: All users have password: {FIXED_PASSWORD}")

    except mysql.connector.Error as err:
        print(f"Error: {err}")
        conn.rollback()
    finally:
        if 'conn' in locals() and conn.is_connected():
            cursor.close()
            conn.close()
            print("\nDatabase connection closed.")


if __name__ == "__main__":
    main()
</file>

<file path="src/test/java/com/online/course/management/project/config/SecurityTestConfig.java">
package com.online.course.management.project.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.online.course.management.project.dto.ErrorResponseDTO;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.http.MediaType;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@TestConfiguration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityTestConfig {

    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        mapper.registerModule(new JavaTimeModule());
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        return mapper;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http, ObjectMapper objectMapper) throws Exception {
        http
                .csrf(csrf -> csrf.disable())
                .sessionManagement(session ->
                        session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/api/v1/users/register", "/api/v1/users/login").permitAll()
                        .anyRequest().authenticated()
                )
                .addFilterBefore(new OncePerRequestFilter() {
                    @Override
                    protected void doFilterInternal(HttpServletRequest request,
                                                    HttpServletResponse response,
                                                    FilterChain filterChain) throws ServletException, IOException {
                        String authHeader = request.getHeader("Authorization");
                        if (authHeader != null && authHeader.startsWith("Bearer ")) {
                            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
                            response.setContentType(MediaType.APPLICATION_JSON_VALUE);
                            ErrorResponseDTO errorResponse = new ErrorResponseDTO(
                                    "Invalid token",
                                    HttpServletResponse.SC_UNAUTHORIZED
                            );
                            objectMapper.writeValue(response.getOutputStream(), errorResponse);
                            return;
                        }
                        filterChain.doFilter(request, response);
                    }
                }, UsernamePasswordAuthenticationFilter.class)
                .exceptionHandling(ex -> ex
                        .authenticationEntryPoint((request, response, authException) -> {
                            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
                            response.setContentType(MediaType.APPLICATION_JSON_VALUE);
                            objectMapper.writeValue(
                                    response.getOutputStream(),
                                    new ErrorResponseDTO("Unauthorized", HttpServletResponse.SC_UNAUTHORIZED)
                            );
                        })
                );

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
</file>

<file path="src/test/java/com/online/course/management/project/controller/UserControllerTest.java">
package com.online.course.management.project.controller;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.online.course.management.project.aspect.RoleAuthorizationAspect;
import com.online.course.management.project.config.SecurityTestConfig;
import com.online.course.management.project.dto.PaginationDto;
import com.online.course.management.project.dto.UserDTOs;
import com.online.course.management.project.entity.Role;
import com.online.course.management.project.entity.User;
import com.online.course.management.project.enums.RoleType;
import com.online.course.management.project.mapper.UserMapper;
import com.online.course.management.project.security.CustomUserDetails;
import com.online.course.management.project.security.CustomUserDetailsService;
import com.online.course.management.project.security.JwtUtil;
import com.online.course.management.project.service.interfaces.IUserService;
import com.online.course.management.project.utils.user.UserControllerUtils;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.context.annotation.EnableAspectJAutoProxy;
import org.springframework.context.annotation.Import;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.http.MediaType;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;

import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.jwt;

import org.springframework.test.web.servlet.MockMvc;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.test.web.servlet.ResultActions;

import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.authentication;
import static org.hamcrest.Matchers.containsInAnyOrder;

import java.util.*;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@WebMvcTest(UserController.class)
@Import({SecurityTestConfig.class, RoleAuthorizationAspect.class})  // Add RoleAuthorizationAspect
@EnableAspectJAutoProxy(proxyTargetClass = true)
class UserControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private IUserService userService;

    @MockBean
    private UserMapper userMapper;


    @MockBean
    private CustomUserDetailsService customUserDetailsService;

    @MockBean
    private JwtUtil jwtUtil;

    @MockBean
    private UserControllerUtils userControllerUtils;

    private ObjectMapper objectMapper;

    @BeforeEach
    void setUp() {
        objectMapper = new ObjectMapper();
    }

    private ResultActions performDeleteWithRole(Long userId, String roleType) throws Exception {
        // Create Role entity
        Role role = new Role();
        role.setName(RoleType.valueOf(roleType));

        // Create User entity with role
        User mockUser = new User();
        mockUser.setId(1L);
        mockUser.setUsername(roleType.toLowerCase());
        mockUser.setEmail(roleType.toLowerCase() + "@example.com");
        mockUser.addRole(role);  // Important: Add role to user entity

        // Create CustomUserDetails
        CustomUserDetails userDetails = new CustomUserDetails(mockUser);

        // Create Authentication with both principal and authorities
        List<GrantedAuthority> authorities = List.of(
                new SimpleGrantedAuthority("ROLE_" + roleType)
        );
        Authentication auth = new UsernamePasswordAuthenticationToken(
                userDetails,  // This must be CustomUserDetails with proper User entity
                null,
                authorities
        );

        // Set up SecurityContext
        SecurityContext securityContext = mock(SecurityContext.class);
        when(securityContext.getAuthentication()).thenReturn(auth);
        SecurityContextHolder.setContext(securityContext);

        // Perform request with authentication
        return mockMvc.perform(delete("/api/v1/users/{id}", userId)
                .with(authentication(auth)));
    }

    @Test
    void registerUser_Success() throws Exception {
        // Arrange
        UserDTOs.UserRegistrationDto registrationDto = new UserDTOs.UserRegistrationDto();
        registrationDto.setEmail("test@example.com");
        registrationDto.setPassword("password123");

        UserDTOs.UserResponseDto responseDto = new UserDTOs.UserResponseDto();
        responseDto.setId(1L);
        responseDto.setEmail("test@example.com");
        responseDto.setUsername("test");

        when(userService.registerUser(any(UserDTOs.UserRegistrationDto.class)))
                .thenReturn(responseDto);

        // Act & Assert
        mockMvc.perform(post("/api/v1/users/register")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(registrationDto)))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.id").value(1L))
                .andExpect(jsonPath("$.email").value("test@example.com"));
    }

    @Test
    void loginUser_Success() throws Exception {
        // Arrange
        UserDTOs.UserLoginDto loginDto = new UserDTOs.UserLoginDto();
        loginDto.setUsernameOrEmail("test@example.com");
        loginDto.setPassword("password123");

        CustomUserDetails userDetails = mock(CustomUserDetails.class);
        Authentication authentication = new UsernamePasswordAuthenticationToken(userDetails, null);
        String token = "test-jwt-token";

        when(userControllerUtils.authenticate(anyString(), anyString())).thenReturn(authentication);
        when(jwtUtil.generateToken(any(CustomUserDetails.class))).thenReturn(token);

        // Act & Assert
        mockMvc.perform(post("/api/v1/users/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(loginDto)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.token").value(token));
    }

    @Test
    void updateUserRoles_Success() throws Exception {
        // Arrange
        Long userId = 1L;
        Set<String> roles = new HashSet<>();
        roles.add("USER");
        roles.add("INSTRUCTOR");

        UserDTOs.UpdateUserRolesDto updateRolesDto = new UserDTOs.UpdateUserRolesDto();
        updateRolesDto.setRoles(roles);

        Role adminRole = new Role();
        adminRole.setName(RoleType.ADMIN);

        // Create CustomUserDetails instead of using default User
        User mockUser = new User();
        mockUser.setId(1L);
        mockUser.setUsername("admin");
        mockUser.setEmail("admin@example.com");
        mockUser.addRole(adminRole);
        CustomUserDetails userDetails = new CustomUserDetails(mockUser);
        Authentication auth = new UsernamePasswordAuthenticationToken(
                userDetails,
                null,
                Collections.singleton(new SimpleGrantedAuthority("ROLE_ADMIN"))
        );

        // Mock the SecurityContext
        SecurityContext securityContext = mock(SecurityContext.class);
        when(securityContext.getAuthentication()).thenReturn(auth);
        SecurityContextHolder.setContext(securityContext);

        // Mock the validateRoles method
        when(userControllerUtils.validateRoles(anySet())).thenReturn(
                new HashSet<>(Arrays.asList(RoleType.USER, RoleType.INSTRUCTOR))
        );

        // Mock the service call
        when(userService.updateUserRoles(eq(userId), anySet(), any())).thenReturn(roles);

        // Act & Assert
        mockMvc.perform(put("/api/v1/users/{id}/roles", userId)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(updateRolesDto))
                        .with(authentication(auth))) // Add authentication to the request
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value("Roles updated successfully"))
                .andExpect(jsonPath("$.updatedRoles").isArray())
                .andExpect(jsonPath("$.updatedRoles", containsInAnyOrder("USER", "INSTRUCTOR")));

        verify(userService).updateUserRoles(eq(userId), any(), eq(1L));
    }


    @Test
    void deleteUser_RoleBasedAccess() throws Exception {
        Long userId = 1L;
        doNothing().when(userService).softDeleteUser(userId);

        // Test ADMIN access
        performDeleteWithRole(userId, "ADMIN")
                .andExpect(status().isNoContent());

        // Test USER access
        performDeleteWithRole(userId, "USER")
                .andExpect(status().isForbidden());

        // Test INSTRUCTOR access
        performDeleteWithRole(userId, "INSTRUCTOR")
                .andExpect(status().isForbidden());
    }

    @Test
    void deleteUser_Unauthorized() throws Exception {
        // Arrange
        Long userId = 1L;

        // Act & Assert
        mockMvc.perform(delete("/api/v1/users/{id}", userId)
                        .header("Authorization", "Bearer invalid-token"))
                .andDo(print())
                .andExpect(status().isUnauthorized());

        verify(userService, never()).softDeleteUser(anyLong());
    }

    @Test
    void getAllUsers_Success() throws Exception {
        // Arrange

        Role adminRole = new Role();
        adminRole.setName(RoleType.ADMIN);

        // Create CustomUserDetails instead of using default User
        User mockUser = new User();
        mockUser.setId(1L);
        mockUser.setUsername("admin");
        mockUser.setEmail("admin@example.com");
        mockUser.addRole(adminRole);

        CustomUserDetails userDetails = new CustomUserDetails(mockUser);
        Authentication auth = new UsernamePasswordAuthenticationToken(
                userDetails,
                null,
                Collections.singleton(new SimpleGrantedAuthority("ROLE_ADMIN"))
        );

        // Mock the SecurityContext
        SecurityContext securityContext = mock(SecurityContext.class);
        when(securityContext.getAuthentication()).thenReturn(auth);
        SecurityContextHolder.setContext(securityContext);

        // Mock pagination request
        PaginationDto.PaginationRequestDto paginationRequest = new PaginationDto.PaginationRequestDto();
        paginationRequest.setPage(1);
        paginationRequest.setLimit(10);

        PageRequest pageRequest = PageRequest.of(0, 10);
        when(userService.getAllUsers(any()))
                .thenReturn(new PageImpl<>(new ArrayList<>(), pageRequest, 0));
        when(userService.countUsers(any())).thenReturn(0L);

        // Act & Assert
        mockMvc.perform(get("/api/v1/users/all")
                        .param("page", "1")
                        .param("limit", "10"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.currentPage").value(1))
                .andExpect(jsonPath("$.limit").value(10))
                .andExpect(jsonPath("$.total").value(0))
                .andExpect(jsonPath("$.data").isArray());
    }
}
</file>

<file path="src/test/java/com/online/course/management/project/dto/UserDTOsValidationTest.java">
package com.online.course.management.project.dto;

import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.ValidatorFactory;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.Set;

import static org.junit.jupiter.api.Assertions.*;

public class UserDTOsValidationTest {
    private Validator validator;

    @BeforeEach
    void setUp() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        validator = factory.getValidator();
    }

    @Test
    void userRegistrationDto_ValidData() {
        UserDTOs.UserRegistrationDto dto = new UserDTOs.UserRegistrationDto();
        dto.setEmail("test@example.com");
        dto.setPassword("password123");

        Set<ConstraintViolation<UserDTOs.UserRegistrationDto>> violations = validator.validate(dto);
        assertTrue(violations.isEmpty());
    }

    @Test
    void userRegistrationDto_InvalidEmail() {
        UserDTOs.UserRegistrationDto dto = new UserDTOs.UserRegistrationDto();
        dto.setEmail("invalid-email");
        dto.setPassword("password123");

        Set<ConstraintViolation<UserDTOs.UserRegistrationDto>> violations = validator.validate(dto);
        assertFalse(violations.isEmpty());
        assertEquals(1, violations.size());
        assertEquals("must be a well-formed email address", violations.iterator().next().getMessage());
    }

    @Test
    void userRegistrationDto_EmptyEmail() {
        UserDTOs.UserRegistrationDto dto = new UserDTOs.UserRegistrationDto();
        dto.setPassword("password123");

        Set<ConstraintViolation<UserDTOs.UserRegistrationDto>> violations = validator.validate(dto);
        assertFalse(violations.isEmpty());
        assertEquals(1, violations.size());
        assertEquals("must not be blank", violations.iterator().next().getMessage());
    }

    @Test
    void userRegistrationDto_PasswordTooShort() {
        UserDTOs.UserRegistrationDto dto = new UserDTOs.UserRegistrationDto();
        dto.setEmail("test@example.com");
        dto.setPassword("short");

        Set<ConstraintViolation<UserDTOs.UserRegistrationDto>> violations = validator.validate(dto);
        assertFalse(violations.isEmpty());
        assertEquals(1, violations.size());
        assertEquals("Password must be between 6 and 40 characters", violations.iterator().next().getMessage());
    }

    @Test
    void userRegistrationDto_PasswordTooLong() {
        UserDTOs.UserRegistrationDto dto = new UserDTOs.UserRegistrationDto();
        dto.setEmail("test@example.com");
        dto.setPassword("a".repeat(41));

        Set<ConstraintViolation<UserDTOs.UserRegistrationDto>> violations = validator.validate(dto);
        assertFalse(violations.isEmpty());
        assertEquals(1, violations.size());
        assertEquals("Password must be between 6 and 40 characters", violations.iterator().next().getMessage());
    }
}
</file>

<file path="src/test/java/com/online/course/management/project/ProjectApplicationTests.java">
package com.online.course.management.project;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ProjectApplicationTests {

    @Test
    void contextLoads() {
    }

}
</file>

<file path="src/test/java/com/online/course/management/project/service/impl/UserServiceImplTest.java">
package com.online.course.management.project.service.impl;

import com.online.course.management.project.dto.UserDTOs;

import com.online.course.management.project.entity.Role;
import com.online.course.management.project.entity.User;

import com.online.course.management.project.enums.RoleType;
import com.online.course.management.project.enums.UserStatus;
import com.online.course.management.project.exception.business.ForbiddenException;
import com.online.course.management.project.exception.business.account.EmailAlreadyExistsException;
import com.online.course.management.project.mapper.UserMapper;

import com.online.course.management.project.repository.IRoleRepository;
import com.online.course.management.project.repository.IUserRepository;
import com.online.course.management.project.utils.user.UserServiceUtils;

import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.Test;

import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;


import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@Slf4j
public class UserServiceImplTest {

    @Mock
    private IUserRepository userRepository;
    @Mock
    private IRoleRepository roleRepository;
    @Mock
    private UserMapper userMapper;
    @Mock
    private UserServiceUtils userServiceUtils;

    @InjectMocks
    private UserServiceImpl userService;

    @Test
    void registerUser_SuccessfulRegistration() {
        UserDTOs.UserRegistrationDto registrationDto = new UserDTOs.UserRegistrationDto();
        registrationDto.setEmail("test@example.com");
        registrationDto.setPassword("password123");

        User user = new User();
        user.setId(1L);
        user.setEmail("test@example.com");
        user.setUsername("testuser");
        user.setStatus(UserStatus.ACTIVE);

        UserDTOs.UserResponseDto userResponseDto = new UserDTOs.UserResponseDto();
        userResponseDto.setId(1L);
        userResponseDto.setEmail("test@example.com");
        userResponseDto.setUsername("test");
        userResponseDto.setStatus("ACTIVE");

        when(userServiceUtils.createUserFromDto(any())).thenReturn(user);
        when(userRepository.save(any(User.class))).thenReturn(user);
        when(userMapper.toDto(any(User.class))).thenReturn(userResponseDto);

        UserDTOs.UserResponseDto result = userService.registerUser(registrationDto);

        assertNotNull(result);
        assertEquals("test@example.com", result.getEmail());
        assertEquals("test", result.getUsername());
        verify(userServiceUtils).validateNewUser(registrationDto);
        verify(userServiceUtils).createUserFromDto(registrationDto);
        verify(userServiceUtils).assignDefaultRole(user);
        verify(userRepository).save(user);
    }

    @Test
    void registerUser_EmailAlreadyExists() {
        UserDTOs.UserRegistrationDto registrationDto = new UserDTOs.UserRegistrationDto();
        registrationDto.setEmail("existing@example.com");
        registrationDto.setPassword("password123");

        doThrow(new EmailAlreadyExistsException("Email already exists"))
                .when(userServiceUtils).validateNewUser(any());

        assertThrows(EmailAlreadyExistsException.class, () -> userService.registerUser(registrationDto));
    }

    @Test
    void updateUserRoles_AssignAdminToNonAdmin_ThrowsForbiddenException() {
        Long userId = 1L;
        Long currentUserId = 2L;
        Set<RoleType> newRoles = new HashSet<>(Collections.singletonList(RoleType.ADMIN));

        User normalUser = new User();
        normalUser.setId(userId);

        User adminUser = new User();
        adminUser.setId(currentUserId);
        Role adminRole = new Role();
        adminRole.setName(RoleType.ADMIN);
        adminUser.addRole(adminRole);

        when(userRepository.findById(userId)).thenReturn(Optional.of(normalUser));
//        when(userRepository.findById(currentUserId)).thenReturn(Optional.of(adminUser));

        assertThrows(ForbiddenException.class, () -> userService.updateUserRoles(userId, newRoles, currentUserId));
    }

    @Test
    void updateUserRoles_RemoveAdminFromInitialAdmin_ThrowsForbiddenException() {
        Long userId = 1L;
        Long currentUserId = 2L;
        Set<RoleType> newRoles = new HashSet<>(Collections.singletonList(RoleType.USER));

        User initialAdminUser = new User();
        initialAdminUser.setId(userId);
        initialAdminUser.setEmail("admin@gmail.com");
        Role adminRole = new Role();
        adminRole.setName(RoleType.ADMIN);
        initialAdminUser.addRole(adminRole);

        User adminUser = new User();
        adminUser.setId(currentUserId);
        adminUser.addRole(adminRole);

        when(userRepository.findById(userId)).thenReturn(Optional.of(initialAdminUser));

        assertThrows(ForbiddenException.class, () -> userService.updateUserRoles(userId, newRoles, currentUserId));
    }

    @Test
    void updateUserRoles_AdminRemovingOwnAdminRole_ThrowsForbiddenException() {
        Long userId = 2L;
        Set<RoleType> newRoles = new HashSet<>(Collections.singletonList(RoleType.USER));

        User adminUser = new User();
        adminUser.setId(userId);
        Role adminRole = new Role();
        adminRole.setName(RoleType.ADMIN);
        adminUser.addRole(adminRole);

        when(userRepository.findById(userId)).thenReturn(Optional.of(adminUser));

        assertThrows(ForbiddenException.class, () -> userService.updateUserRoles(userId, newRoles, userId));
    }


    @Test
    void updateUserRoles_SuccessfulUpdate() {
        Long userId = 1L;
        Long currentUserId = 2L;
        Set<RoleType> newRoles = new HashSet<>(Arrays.asList(RoleType.USER, RoleType.INSTRUCTOR));

        Role userRole = new Role();
        userRole.setId(1L);
        userRole.setName(RoleType.USER);

        Role instructorRole = new Role();
        instructorRole.setId(2L);
        instructorRole.setName(RoleType.INSTRUCTOR);

        Role adminRole = new Role();
        adminRole.setId(3L);
        adminRole.setName(RoleType.ADMIN);

        User normalUser = new User();
        normalUser.setId(userId);
        normalUser.addRole(userRole);

        User adminUser = new User();
        adminUser.setId(currentUserId);
        adminUser.addRole(adminRole);

        when(userRepository.findById(userId)).thenReturn(Optional.of(normalUser));
        //when(userRepository.findById(currentUserId)).thenReturn(Optional.of(adminUser));
        when(roleRepository.findByName(RoleType.USER)).thenReturn(Optional.of(userRole));
        when(roleRepository.findByName(RoleType.INSTRUCTOR)).thenReturn(Optional.of(instructorRole));

        // This is the key change
        when(userRepository.save(any(User.class))).thenAnswer(invocation -> {
            User savedUser = invocation.getArgument(0);
            // Clear existing roles and add new ones to simulate actual persistence
            savedUser.getUserRoles().clear();
            for (RoleType role : newRoles) {
                if (role == RoleType.USER) {
                    savedUser.addRole(userRole);
                }
                if (role == RoleType.INSTRUCTOR) {
                    savedUser.addRole(instructorRole);
                }
            }
            return savedUser;
        });

        Set<String> result = userService.updateUserRoles(userId, newRoles, currentUserId);

        log.info("Updated roles: {}", result);

        assertEquals(2, result.size(), "Expected 2 roles, but got: " + result.size() + " roles: " + result);
        assertTrue(result.contains("USER"), "USER role is missing from the result");
        assertTrue(result.contains("INSTRUCTOR"), "INSTRUCTOR role is missing from the result");
        verify(userRepository).save(any(User.class));
    }

    @Test
    void getAllUsers_SuccessfulRetrieval() {
        User user = new User();
        user.setId(1L);
        user.setEmail("test@example.com");
        user.setUsername("testuser");
        user.setStatus(UserStatus.ACTIVE);

        Page<User> userPage = new PageImpl<>(Collections.singletonList(user));
        when(userRepository.findAll(any(Pageable.class))).thenReturn(userPage);
        when(userMapper.toUserWithRolesDto(any(User.class))).thenReturn(new UserDTOs.UserWithRolesResponseDto());

        Page<UserDTOs.UserWithRolesResponseDto> result = userService.getAllUsers(Pageable.unpaged());

        assertNotNull(result);
        assertEquals(1, result.getTotalElements());
    }

    @Test
    void getUserById_UserFound() {
        User user = new User();
        user.setId(1L);
        user.setEmail("test@example.com");
        user.setUsername("testuser");
        user.setStatus(UserStatus.ACTIVE);

        when(userRepository.findById(1L)).thenReturn(Optional.of(user));

        Optional<User> result = userService.getUserById(1L);

        assertTrue(result.isPresent());
        assertEquals(user, result.get());
    }

    @Test
    void getUserById_UserNotFound() {
        when(userRepository.findById(1L)).thenReturn(Optional.empty());

        Optional<User> result = userService.getUserById(1L);

        assertFalse(result.isPresent());
    }

    @Test
    void softDeleteUser_SuccessfulDelete() {
        User user = new User();
        user.setId(1L);
        user.setEmail("test@example.com");
        user.setUsername("testuser");
        user.setStatus(UserStatus.ACTIVE);

        when(userRepository.findById(1L)).thenReturn(Optional.of(user));

        userService.softDeleteUser(1L);

        verify(userRepository).save(user);
        assertNotNull(user.getDeletedAt());
    }

    @Test
    void softDeleteUser_AdminUser() {
        User adminUser = new User();
        adminUser.setId(1L);
        Role adminRole = new Role();
        adminRole.setName(RoleType.ADMIN);
        adminUser.addRole(adminRole);

        when(userRepository.findById(1L)).thenReturn(Optional.of(adminUser));

        assertThrows(ForbiddenException.class, () -> userService.softDeleteUser(1L));
    }
}
</file>

<file path="src/test/resources/application.properties">
jwt.secret=testSecretKeyForTestingPurposesOnlyDoNotUseInProduction
jwt.expiration=3600
</file>

</repository_files>
